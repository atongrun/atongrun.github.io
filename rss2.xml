<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>孙菜菜</title>
    <link>https://atong.run/</link>
    
    <atom:link href="https://atong.run/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>万千不如意，睡得着就过得去</description>
    <pubDate>Fri, 17 Feb 2023 08:47:47 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>9、高并发内存池-性能测试及优化</title>
      <link>https://atong.run/posts/1573212312/</link>
      <guid>https://atong.run/posts/1573212312/</guid>
      <pubDate>Fri, 17 Feb 2023 08:45:32 GMT</pubDate>
      
        
        
      <description>&lt;h1&gt;多线程环境下对比malloc测试&lt;/h1&gt;
&lt;h2 id=&quot;测试代码&quot;&gt;测试代码&lt;/h2&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/spa</description>
        
      
      
      
      <content:encoded><![CDATA[<h1>多线程环境下对比malloc测试</h1><h2 id="测试代码">测试代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;ConcurrentAlloc.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ntimes 一轮申请和释放内存的次数</span></span><br><span class="line"><span class="comment">// rounds 轮次</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BenchmarkMalloc</span><span class="params">(<span class="type">size_t</span> ntimes, <span class="type">size_t</span> nworks, <span class="type">size_t</span> rounds)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">std::vector&lt;std::thread&gt; <span class="title">vthread</span><span class="params">(nworks)</span></span>;</span><br><span class="line">std::atomic&lt;<span class="type">size_t</span>&gt; malloc_costtime = <span class="number">0</span>;</span><br><span class="line">std::atomic&lt;<span class="type">size_t</span>&gt; free_costtime = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> k = <span class="number">0</span>; k &lt; nworks; ++k)</span><br><span class="line">&#123;</span><br><span class="line">vthread[k] = std::<span class="built_in">thread</span>([&amp;, k]() &#123;</span><br><span class="line">std::vector&lt;<span class="type">void</span>*&gt; v;</span><br><span class="line">v.<span class="built_in">reserve</span>(ntimes);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; rounds; ++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">size_t</span> begin1 = <span class="built_in">clock</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; ntimes; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//v.push_back(malloc(16));</span></span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="built_in">malloc</span>((<span class="number">16</span> + i) % <span class="number">8192</span> + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">size_t</span> end1 = <span class="built_in">clock</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> begin2 = <span class="built_in">clock</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; ntimes; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">free</span>(v[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">size_t</span> end2 = <span class="built_in">clock</span>();</span><br><span class="line">v.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">malloc_costtime += (end1 - begin1);</span><br><span class="line">free_costtime += (end2 - begin2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; t : vthread)</span><br><span class="line">&#123;</span><br><span class="line">t.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; nworks &lt;&lt; <span class="string">&quot;个线程并发执行&quot;</span> &lt;&lt; rounds &lt;&lt; <span class="string">&quot;轮次，每轮次malloc &quot;</span> &lt;&lt; ntimes &lt;&lt; <span class="string">&quot;次：花费：&quot;</span> &lt;&lt; malloc_costtime &lt;&lt; <span class="string">&quot; ms&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; nworks &lt;&lt; <span class="string">&quot;个线程并发执行&quot;</span> &lt;&lt; rounds &lt;&lt; <span class="string">&quot;轮次，每轮次free &quot;</span> &lt;&lt; ntimes &lt;&lt; <span class="string">&quot;次：花费：&quot;</span> &lt;&lt; free_costtime &lt;&lt; <span class="string">&quot; ms&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; nworks &lt;&lt; <span class="string">&quot;个线程并发malloc&amp;free&quot;</span> &lt;&lt; nworks * rounds * ntimes &lt;&lt; <span class="string">&quot;总计花费：&quot;</span> &lt;&lt; malloc_costtime + free_costtime &lt;&lt; <span class="string">&quot; ms&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 单轮次申请释放次数 线程数 轮次</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BenchmarkConcurrentMalloc</span><span class="params">(<span class="type">size_t</span> ntimes, <span class="type">size_t</span> nworks, <span class="type">size_t</span> rounds)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">std::vector&lt;std::thread&gt; <span class="title">vthread</span><span class="params">(nworks)</span></span>;</span><br><span class="line">std::atomic&lt;<span class="type">size_t</span>&gt; malloc_costtime = <span class="number">0</span>;</span><br><span class="line">std::atomic&lt;<span class="type">size_t</span>&gt; free_costtime = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> k = <span class="number">0</span>; k &lt; nworks; ++k)</span><br><span class="line">&#123;</span><br><span class="line">vthread[k] = std::<span class="built_in">thread</span>([&amp;]() &#123;</span><br><span class="line">std::vector&lt;<span class="type">void</span>*&gt; v;</span><br><span class="line">v.<span class="built_in">reserve</span>(ntimes);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; rounds; ++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">size_t</span> begin1 = <span class="built_in">clock</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; ntimes; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//v.push_back(ConcurrentAlloc(16));</span></span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="built_in">ConcurrentAlloc</span>((<span class="number">16</span> + i) % <span class="number">8192</span> + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">size_t</span> end1 = <span class="built_in">clock</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> begin2 = <span class="built_in">clock</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; ntimes; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">ConcurrentFree</span>(v[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">size_t</span> end2 = <span class="built_in">clock</span>();</span><br><span class="line">v.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">malloc_costtime += (end1 - begin1);</span><br><span class="line">free_costtime += (end2 - begin2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; t : vthread)</span><br><span class="line">&#123;</span><br><span class="line">t.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; nworks &lt;&lt; <span class="string">&quot;个线程并发执行&quot;</span> &lt;&lt; rounds &lt;&lt; <span class="string">&quot;轮次，每轮次concurrent alloc &quot;</span> &lt;&lt; ntimes &lt;&lt; <span class="string">&quot;次：花费：&quot;</span> &lt;&lt; malloc_costtime &lt;&lt; <span class="string">&quot; ms&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; nworks &lt;&lt; <span class="string">&quot;个线程并发执行&quot;</span> &lt;&lt; rounds &lt;&lt; <span class="string">&quot;轮次，每轮次concurrent dealloc &quot;</span> &lt;&lt; ntimes &lt;&lt; <span class="string">&quot;次：花费：&quot;</span> &lt;&lt; free_costtime &lt;&lt; <span class="string">&quot; ms&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; nworks &lt;&lt; <span class="string">&quot;个线程并发concurrent alloc&amp;dealloc&quot;</span> &lt;&lt; nworks * rounds * ntimes &lt;&lt; <span class="string">&quot;总计花费：&quot;</span> &lt;&lt; malloc_costtime + free_costtime &lt;&lt; <span class="string">&quot; ms&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">size_t</span> n = <span class="number">10000</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;==========================================================&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">BenchmarkConcurrentMalloc</span>(n, <span class="number">4</span>, <span class="number">10</span>);</span><br><span class="line">cout &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">BenchmarkMalloc</span>(n, <span class="number">4</span>, <span class="number">10</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;==========================================================&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="申请释放固定内存大小">申请释放固定内存大小</h2><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202302171300120.png" alt="image.png"></p><h2 id="申请释放不同内存大小">申请释放不同内存大小</h2><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202302171303359.png" alt="image.png"></p><h1>性能瓶颈分析</h1><blockquote><p>上述测试发现，我们的内存池比malloc还是差一些的，但是不大容易知道到底是代码的哪一个部分消耗的性能较多，不知道性能的瓶颈在哪里，这时候可以使用性能分析工具</p></blockquote><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202302171413680.png" alt="image.png"></p><p>打开性能探查器，可用工具类，检测项打上对号</p><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202302171414904.png" alt="image.png"></p><p>点击开始</p><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202302171430934.png" alt="image.png"></p><p>可以发现MapObjectToSpan所花费时间非常长，因为涉及到锁的竞争问题，那么我们应该如何进行优化呢？</p><h1>基数树优化</h1><blockquote><p>这里使用基数树进行优化，基数树实际是一个分层的哈希表，根据所分层数，可以分为单层基数树、二层基数树、三层基数树</p></blockquote><h2 id="单层基数树">单层基数树</h2><blockquote><p>单层基数树使用的是直接定址法，在32位平台下，最多分成2^32/2^13次方个页，我们直接开2^(31-13)次方大小的数组</p></blockquote><p>这这里可以用非类型模板参数，将次方传入，1&lt;&lt; BITS 就是2的BITS次方。直接开这么长的数组</p><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202302171521406.png" alt="image.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> BITS&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TCMalloc_PageMap1</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> LENGTH = <span class="number">1</span> &lt;&lt; BITS;</span><br><span class="line"><span class="type">void</span>** array_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uintptr_t</span> Number;</span><br><span class="line"></span><br><span class="line"><span class="comment">//explicit TCMalloc_PageMap1(void* (*allocator)(size_t)) &#123;</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">TCMalloc_PageMap1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//array_ = reinterpret_cast&lt;void**&gt;((*allocator)(sizeof(void*) &lt;&lt; BITS));</span></span><br><span class="line"><span class="type">size_t</span> size = <span class="built_in">sizeof</span>(<span class="type">void</span>*) &lt;&lt; BITS;</span><br><span class="line"><span class="type">size_t</span> alignSize = SizeClass::_RoundUp(size, <span class="number">1</span> &lt;&lt; PAGE_SHIFT);</span><br><span class="line">array_ = (<span class="type">void</span>**)<span class="built_in">SystemAlloc</span>(alignSize &gt;&gt; PAGE_SHIFT);</span><br><span class="line"><span class="built_in">memset</span>(array_, <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="type">void</span>*) &lt;&lt; BITS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return the current value for KEY.  Returns NULL if not yet set,</span></span><br><span class="line"><span class="comment">// or if k is out of range.</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">get</span><span class="params">(Number k)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> ((k &gt;&gt; BITS) &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> array_[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// REQUIRES &quot;k&quot; is in range &quot;[0,2^BITS-1]&quot;.</span></span><br><span class="line"><span class="comment">// REQUIRES &quot;k&quot; has been ensured before.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Sets the value &#x27;v&#x27; for key &#x27;k&#x27;.</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(Number k, <span class="type">void</span>* v)</span> </span>&#123;</span><br><span class="line">array_[k] = v;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="二层基数树">二层基数树</h2><blockquote><p>假设同样在32位平台下，最多分成2^32/2^13  = 2^19次方个页，最多用19个比特位可以标识，用二层得基数树，第一层只用5个比特位，做直接定址，对应的下标存的元素是 void* values[LEAF_LENGTH]，剩下的14位可以总共映射 length = 1&lt;&lt;14个数据</p></blockquote><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202302171526874.png" alt="image.png"></p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Two-level radix tree</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> BITS&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TCMalloc_PageMap2</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">// Put 32 entries in the root and (2^BITS)/32 entries in each leaf.</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> ROOT_BITS = <span class="number">5</span>; <span class="comment">//第一层对应页号的前5个比特位</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> ROOT_LENGTH = <span class="number">1</span> &lt;&lt; ROOT_BITS; <span class="comment">//第一层存储元素的个数 2^5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> LEAF_BITS = BITS - ROOT_BITS;<span class="comment">//第二层对应页号的其余比特位 19-5=14</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> LEAF_LENGTH = <span class="number">1</span> &lt;&lt; LEAF_BITS; <span class="comment">//第二层存储元素的个数 2^14</span></span><br><span class="line"><span class="comment">// Leaf node</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Leaf</span> &#123;</span><br><span class="line"><span class="type">void</span>* values[LEAF_LENGTH];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Leaf* root_[ROOT_LENGTH];             <span class="comment">// Pointers to 32 child nodes</span></span><br><span class="line"><span class="type">void</span>* (*allocator_)(<span class="type">size_t</span>);          <span class="comment">// Memory allocator</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uintptr_t</span> Number;</span><br><span class="line"></span><br><span class="line"><span class="comment">//explicit TCMalloc_PageMap2(void* (*allocator)(size_t)) &#123;</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">TCMalloc_PageMap2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//allocator_ = allocator;</span></span><br><span class="line"><span class="built_in">memset</span>(root_, <span class="number">0</span>, <span class="built_in">sizeof</span>(root_));</span><br><span class="line"></span><br><span class="line"><span class="built_in">PreallocateMoreMemory</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">get</span><span class="params">(Number k)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="type">const</span> Number i1 = k &gt;&gt; LEAF_BITS;  <span class="comment">// 右移14位，得到前5位</span></span><br><span class="line"><span class="type">const</span> Number i2 = k &amp; (LEAF_LENGTH - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> ((k &gt;&gt; BITS) &gt; <span class="number">0</span> || root_[i1] == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> root_[i1]-&gt;values[i2];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(Number k, <span class="type">void</span>* v)</span> </span>&#123;</span><br><span class="line"><span class="type">const</span> Number i1 = k &gt;&gt; LEAF_BITS;</span><br><span class="line"><span class="comment">// 1000 0000 0000 000-1 = 0111 1111 1111 11</span></span><br><span class="line"><span class="comment">// 相与获得后14位</span></span><br><span class="line"><span class="type">const</span> Number i2 = k &amp; (LEAF_LENGTH - <span class="number">1</span>); </span><br><span class="line"><span class="built_in">ASSERT</span>(i1 &lt; ROOT_LENGTH);</span><br><span class="line">root_[i1]-&gt;values[i2] = v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 确保映射[start ， start+n-1]页号的空间是开好的</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Ensure</span><span class="params">(Number start, <span class="type">size_t</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (Number key = start; key &lt;= start + n - <span class="number">1</span>;) &#123;</span><br><span class="line"><span class="type">const</span> Number i1 = key &gt;&gt; LEAF_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check for overflow</span></span><br><span class="line"><span class="keyword">if</span> (i1 &gt;= ROOT_LENGTH)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Make 2nd level node if necessary</span></span><br><span class="line"><span class="keyword">if</span> (root_[i1] == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="comment">//Leaf* leaf = reinterpret_cast&lt;Leaf*&gt;((*allocator_)(sizeof(Leaf)));</span></span><br><span class="line"><span class="comment">//if (leaf == NULL) return false;</span></span><br><span class="line"><span class="type">static</span> ObjectPool&lt;Leaf&gt;leafPool;</span><br><span class="line">Leaf* leaf = (Leaf*)leafPool.<span class="built_in">New</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(leaf, <span class="number">0</span>, <span class="built_in">sizeof</span>(*leaf));</span><br><span class="line">root_[i1] = leaf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Advance key past whatever is covered by this leaf node</span></span><br><span class="line">key = ((key &gt;&gt; LEAF_BITS) + <span class="number">1</span>) &lt;&lt; LEAF_BITS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreallocateMoreMemory</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 将第二层全部的空间都开好</span></span><br><span class="line"><span class="built_in">Ensure</span>(<span class="number">0</span>, <span class="number">1</span> &lt;&lt; BITS);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>在32位平台下，第一层数组占，2^5* 4=2^7字节，第二层最多有2^5^2^14^4=2^21=2M，消耗也不大，可以直接全开出来</p></blockquote><h2 id="三层基数树">三层基数树</h2><blockquote><p>64位平台下，公共有2^64/2^13=2^51个页，一层基数树肯定不行，二层页不大行，用三层基数树，三层基数树就是将存储页号的比特位分三次映射</p></blockquote><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202302171607278.png" alt="image.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Three-level radix tree</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> BITS&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TCMalloc_PageMap3</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> INTERIOR_BITS = (BITS + <span class="number">2</span>) / <span class="number">3</span>;       <span class="comment">//第一、二层对应页号的比特位个数</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> INTERIOR_LENGTH = <span class="number">1</span> &lt;&lt; INTERIOR_BITS; <span class="comment">//第一、二层存储元素的个数</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> LEAF_BITS = BITS - <span class="number">2</span> * INTERIOR_BITS; <span class="comment">//第三层对应页号的比特位个数</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> LEAF_LENGTH = <span class="number">1</span> &lt;&lt; LEAF_BITS;         <span class="comment">//第三层存储元素的个数</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">Node* ptrs[INTERIOR_LENGTH];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Leaf</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">void</span>* values[LEAF_LENGTH];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Node* <span class="title">NewNode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">static</span> ObjectPool&lt;Node&gt; nodePool;</span><br><span class="line">Node* result = nodePool.<span class="built_in">New</span>();</span><br><span class="line"><span class="keyword">if</span> (result != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(result, <span class="number">0</span>, <span class="built_in">sizeof</span>(*result));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">Node* root_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uintptr_t</span> Number;</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">TCMalloc_PageMap3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">root_ = <span class="built_in">NewNode</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">get</span><span class="params">(Number k)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">const</span> Number i1 = k &gt;&gt; (LEAF_BITS + INTERIOR_BITS);         <span class="comment">//第一层对应的下标</span></span><br><span class="line"><span class="type">const</span> Number i2 = (k &gt;&gt; LEAF_BITS) &amp; (INTERIOR_LENGTH - <span class="number">1</span>); <span class="comment">//第二层对应的下标</span></span><br><span class="line"><span class="type">const</span> Number i3 = k &amp; (LEAF_LENGTH - <span class="number">1</span>);                    <span class="comment">//第三层对应的下标</span></span><br><span class="line"><span class="comment">//页号超出范围，或映射该页号的空间未开辟</span></span><br><span class="line"><span class="keyword">if</span> ((k &gt;&gt; BITS) &gt; <span class="number">0</span> || root_-&gt;ptrs[i1] == <span class="literal">NULL</span> || root_-&gt;ptrs[i1]-&gt;ptrs[i2] == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">reinterpret_cast</span>&lt;Leaf*&gt;(root_-&gt;ptrs[i1]-&gt;ptrs[i2])-&gt;values[i3]; <span class="comment">//返回该页号对应span的指针</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(Number k, <span class="type">void</span>* v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(k &gt;&gt; BITS == <span class="number">0</span>);</span><br><span class="line"><span class="type">const</span> Number i1 = k &gt;&gt; (LEAF_BITS + INTERIOR_BITS);         <span class="comment">//第一层对应的下标</span></span><br><span class="line"><span class="type">const</span> Number i2 = (k &gt;&gt; LEAF_BITS) &amp; (INTERIOR_LENGTH - <span class="number">1</span>); <span class="comment">//第二层对应的下标</span></span><br><span class="line"><span class="type">const</span> Number i3 = k &amp; (LEAF_LENGTH - <span class="number">1</span>);                    <span class="comment">//第三层对应的下标</span></span><br><span class="line"><span class="built_in">Ensure</span>(k, <span class="number">1</span>); <span class="comment">//确保映射第k页页号的空间是开辟好了的</span></span><br><span class="line"><span class="built_in">reinterpret_cast</span>&lt;Leaf*&gt;(root_-&gt;ptrs[i1]-&gt;ptrs[i2])-&gt;values[i3] = v; <span class="comment">//建立该页号与对应span的映射</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//确保映射[start,start+n-1]页号的空间是开辟好了的</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Ensure</span><span class="params">(Number start, <span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (Number key = start; key &lt;= start + n - <span class="number">1</span>;)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> Number i1 = key &gt;&gt; (LEAF_BITS + INTERIOR_BITS);         <span class="comment">//第一层对应的下标</span></span><br><span class="line"><span class="type">const</span> Number i2 = (key &gt;&gt; LEAF_BITS) &amp; (INTERIOR_LENGTH - <span class="number">1</span>); <span class="comment">//第二层对应的下标</span></span><br><span class="line"><span class="keyword">if</span> (i1 &gt;= INTERIOR_LENGTH || i2 &gt;= INTERIOR_LENGTH) <span class="comment">//下标值超出范围</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (root_-&gt;ptrs[i1] == <span class="literal">NULL</span>) <span class="comment">//第一层i1下标指向的空间未开辟</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//开辟对应空间</span></span><br><span class="line">Node* n = <span class="built_in">NewNode</span>();</span><br><span class="line"><span class="keyword">if</span> (n == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">root_-&gt;ptrs[i1] = n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (root_-&gt;ptrs[i1]-&gt;ptrs[i2] == <span class="literal">NULL</span>) <span class="comment">//第二层i2下标指向的空间未开辟</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//开辟对应空间</span></span><br><span class="line"><span class="type">static</span> ObjectPool&lt;Leaf&gt; leafPool;</span><br><span class="line">Leaf* leaf = leafPool.<span class="built_in">New</span>();</span><br><span class="line"><span class="keyword">if</span> (leaf == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">memset</span>(leaf, <span class="number">0</span>, <span class="built_in">sizeof</span>(*leaf));</span><br><span class="line">root_-&gt;ptrs[i1]-&gt;ptrs[i2] = <span class="built_in">reinterpret_cast</span>&lt;Node*&gt;(leaf);</span><br><span class="line">&#125;</span><br><span class="line">key = ((key &gt;&gt; LEAF_BITS) + <span class="number">1</span>) &lt;&lt; LEAF_BITS; <span class="comment">//继续后续检查</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreallocateMoreMemory</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>当需要建立某一页号的映射关系时，先确保存储该页映射的数组空间是开好的，调用Ensure函数，如果没开好，就开辟对应的空间</p></blockquote><h2 id="使用基数树优化">使用基数树优化</h2><blockquote><p>我们在32位平台下测试，直接使用一层基数树即可将unordered_map替换成基数树的结构，并用set和get函数，替换方括号和find的作用</p></blockquote><h3 id="更改代码">更改代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TCMalloc_PageMap1&lt;<span class="number">32</span> - PAGE_SHIFT&gt; _idSpanMap;  <span class="comment">//32-13=19，总共2^19个页</span></span><br></pre></td></tr></table></figure><p>建立映射：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_idSpanMap.<span class="built_in">set</span>(span-&gt;_pageId, span);</span><br></pre></td></tr></table></figure><p>读取Span</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Span* ret = (Span*)_idSpanMap.<span class="built_in">get</span>(id);</span><br></pre></td></tr></table></figure><h3 id="优化原理">优化原理</h3><blockquote><p>基数树的检索可能略好一点，但是最重要的是基数树的结构不需要加锁，map和unordered_map，插入数据底层的数据结构可能会变化，比如红黑树的选择，哈希表的扩容，所以在读取映射关系时需要加锁，但是基数树一旦开好空间就不会发生变化。<br>我们不会同时对一个页进行读取映射和建立映射的操作，只有在释放对象的时候才需要读取，建立映射都是在page cache中进行，建立映射的对应的span的usecount为0，而读取对应的span的usecount不为0，所以不会对一个页同时进行读取和建立映射。</p></blockquote><h3 id="性能对比">性能对比</h3><blockquote><p>再次与malloc进行对比</p></blockquote><p>固定大小的对象的申请和释放</p><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202302171629323.png" alt="image.png"></p><p>不固定大小的对象的申请和释放</p><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202302171627490.png" alt="image.png"></p><p>可以看到两种场景，都比malloc快2~3倍左右</p>]]></content:encoded>
      
      
      <category domain="https://atong.run/categories/%E9%A1%B9%E7%9B%AE/">项目</category>
      
      <category domain="https://atong.run/categories/%E9%A1%B9%E7%9B%AE/%E9%AB%98%E5%B9%B6%E5%8F%91%E5%86%85%E5%AD%98%E6%B1%A0/">高并发内存池</category>
      
      
      <category domain="https://atong.run/tags/%E9%A1%B9%E7%9B%AE/">项目</category>
      
      
      <comments>https://atong.run/posts/1573212312/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>8、高并发内存池-细节完善</title>
      <link>https://atong.run/posts/2734729201/</link>
      <guid>https://atong.run/posts/2734729201/</guid>
      <pubDate>Fri, 17 Feb 2023 06:09:42 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;我们的内存池已经完成了申请内存和释放内存的功能但是还有几个地方没有处理完善，主要有以下几个方面：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;大于256KB的内存申请&lt;/li&gt;
&lt;li&gt;内存池的内部要脱离new&lt;/li&gt;
&lt;li&gt;释放对象</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>我们的内存池已经完成了申请内存和释放内存的功能但是还有几个地方没有处理完善，主要有以下几个方面：</p></blockquote><ul><li>大于256KB的内存申请</li><li>内存池的内部要脱离new</li><li>释放对象时的细节</li></ul><h1>大于256KB的内存处理</h1><h2 id="申请">申请</h2><blockquote><p>在ConcurrentAlloc.h文件中，申请内存的时候要分两种情况</p></blockquote><ul><li>小于256kb走thread cache</li><li>大于256kb走page cache</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">ConcurrentAlloc</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (size &gt; MAX_BYTES)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 申请的内存大于MAX_BYTES(256kb)</span></span><br><span class="line"><span class="comment">// 走Page Cache层申请</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 先进行对齐</span></span><br><span class="line"><span class="type">size_t</span> alignSize = SizeClass::<span class="built_in">RoundUp</span>(size);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后算需要几页</span></span><br><span class="line"><span class="type">size_t</span> kpage = alignSize &gt;&gt; PAGE_SHITF;</span><br><span class="line">PageCache::<span class="built_in">GetInstance</span>()-&gt;_pageMtx.<span class="built_in">lock</span>();</span><br><span class="line">Span* span = PageCache::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">NewSpan</span>(alignSize);</span><br><span class="line">PageCache::<span class="built_in">GetInstance</span>()-&gt;_pageMtx.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (<span class="type">void</span>*)(span-&gt;_pageId &lt;&lt; PAGE_SHITF);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pTLSThreadCache == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">pTLSThreadCache = <span class="keyword">new</span> ThreadCache;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pTLSThreadCache-&gt;<span class="built_in">Allocate</span>(size);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>我们SizeClass对齐的逻辑，并没有处理大于256KB的内存，我们需要增加这一部分</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">size_t</span> <span class="title">RoundUp</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (size &lt;= <span class="number">128</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _RoundUp(size, <span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (size &lt;= <span class="number">1024</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _RoundUp(size, <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (size &lt;= <span class="number">8</span> * <span class="number">1024</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _RoundUp(size, <span class="number">128</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (size &lt;= <span class="number">64</span> * <span class="number">1024</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _RoundUp(size, <span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (size &lt;= <span class="number">256</span> * <span class="number">1024</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _RoundUp(size, <span class="number">8</span>*<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 大于256KB 1&lt;&lt;13 也就是8kb</span></span><br><span class="line"><span class="keyword">return</span> _RoundUp(size, <span class="number">1</span> &lt;&lt; PAGE_SHITF);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>但是这个大于256kb的让page cache申请，还是存在一些问题，因为page cache最多提供128页的内存，如果申请的内存大于128页，则还是需要进行处理，这部分，我们在page cache中进行处理。</p></blockquote><pre><code>PageCache::NewSpan函数中，增加申请大于128页的span的逻辑</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 如果k &gt; 128页 走系统调用</span></span><br><span class="line"><span class="keyword">if</span> (k &gt; NPAGES - <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">void</span>* ptr = <span class="built_in">SystemAlloc</span>(k);</span><br><span class="line">Span* span = <span class="keyword">new</span> Span;</span><br><span class="line">span-&gt;_pageId = (PAGE_ID)ptr &gt;&gt; PAGE_SHITF;</span><br><span class="line">span-&gt;_n = k;</span><br><span class="line"></span><br><span class="line">_idSpanMap[span-&gt;_pageId] = span;</span><br><span class="line"><span class="keyword">return</span> span;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="释放">释放</h2><blockquote><p>大于256kb的内存，释放时，同样不能走thread cache层回收，要有单独的回收逻辑，我们还是通过pagecache层回收</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">ConcurrentFree</span><span class="params">(<span class="type">void</span>* ptr, <span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (size &gt; MAX_BYTES)</span><br><span class="line">&#123;</span><br><span class="line">Span* span = PageCache::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">MapObjectToSpan</span>(ptr);</span><br><span class="line"></span><br><span class="line">PageCache::<span class="built_in">GetInstance</span>()-&gt;_pageMtx.<span class="built_in">lock</span>();</span><br><span class="line">PageCache::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">ReleaseSpanToPageCache</span>(span);</span><br><span class="line">PageCache::<span class="built_in">GetInstance</span>()-&gt;_pageMtx.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">assert</span>(pTLSThreadCache);</span><br><span class="line">pTLSThreadCache-&gt;<span class="built_in">Deallocate</span>(ptr, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>同样，在pagecache层中还要分为，这个内存是大于128页还是小于128页，小于128直接走Page cache层的回收逻辑，大于128页的通过系统调用回收</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 释放空闲span回到PageCache，并合并相邻的span</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PageCache::ReleaseSpanToPageCache</span><span class="params">(Span* span)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (span-&gt;_n &gt; NPAGES - <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">void</span>* ptr = (<span class="type">void</span>*)(span-&gt;_pageId &lt;&lt; PAGE_SHITF);</span><br><span class="line"><span class="built_in">SystemFree</span>(ptr);</span><br><span class="line"><span class="keyword">delete</span> span;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 合并相邻的span，向前合并，有问题：前面的span如果被用就不能进行合并</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">PAGE_ID prevId = span-&gt;_pageId - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> ret = _idSpanMap.<span class="built_in">find</span>(prevId);</span><br><span class="line"><span class="comment">//前边的页号没有了就不和并了</span></span><br><span class="line"><span class="keyword">if</span> (ret == _idSpanMap.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前边相邻页在使用，不合并</span></span><br><span class="line">Span* prevSpan = ret-&gt;second;</span><br><span class="line"><span class="keyword">if</span> (prevSpan-&gt;_isUse == <span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//超过128页的span也不合并</span></span><br><span class="line"><span class="keyword">if</span> (prevSpan-&gt;_n + span-&gt;_n &gt; NPAGES - <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进入合并的逻辑</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//span-&gt;_pageId -= prevSpan-&gt;_n;</span></span><br><span class="line">span-&gt;_pageId = prevSpan-&gt;_pageId;</span><br><span class="line">span-&gt;_n += prevSpan-&gt;_n;</span><br><span class="line"></span><br><span class="line">_spanLists[prevSpan-&gt;_n].<span class="built_in">Erase</span>(prevSpan);</span><br><span class="line"><span class="keyword">delete</span> prevSpan;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">PAGE_ID nextID = span-&gt;_pageId + span-&gt;_n;</span><br><span class="line"><span class="keyword">auto</span> ret = _idSpanMap.<span class="built_in">find</span>(nextID);</span><br><span class="line"><span class="keyword">if</span> (ret == _idSpanMap.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Span* nextSpan = ret-&gt;second;</span><br><span class="line"><span class="keyword">if</span> (nextSpan-&gt;_isUse == <span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//超过128页的span也不合并</span></span><br><span class="line"><span class="keyword">if</span> (nextSpan-&gt;_n + span-&gt;_n &gt; NPAGES - <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">span-&gt;_n += nextSpan-&gt;_n;</span><br><span class="line"></span><br><span class="line">_spanLists[nextSpan-&gt;_n].<span class="built_in">Erase</span>(nextSpan);</span><br><span class="line"><span class="keyword">delete</span> nextSpan;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">_spanLists[span-&gt;_n].<span class="built_in">PushFront</span>(span);</span><br><span class="line">span-&gt;_isUse = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">_idSpanMap[span-&gt;_pageId] = span;</span><br><span class="line">_idSpanMap[span-&gt;_pageId + span-&gt;_n - <span class="number">1</span>] = span;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里封装的了Windows系统的VirtualFree函数，进行大于128页的内存释放</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用系统接口释放内存</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">static</span> <span class="type">void</span> <span class="title">SystemFree</span><span class="params">(<span class="type">void</span>* ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line"><span class="built_in">VirtualFree</span>(ptr, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="comment">// sbrk unmmap等</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>使用定长内存池配合脱离new</h1><blockquote><p>我们的内存池期望的是在内部不使用malloc函数申请内存，走自己的一套申请释放体系，但是目前我们的代码中，还是有不少地方（new span的对象）使用了new，为了完全脱离new，我们可以配合之前的定长内存池。</p></blockquote><h2 id="申请-2">申请</h2><p>因为span对象都是在page cache层new出来的，我们可以在page cache层增加一个定长内存池对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ObjectPool&lt;Span&gt; _spanPool;</span><br></pre></td></tr></table></figure><blockquote><p>然后我们在new Span的场景下，替换成定长内存池的申请</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Span* span = <span class="keyword">new</span> Span;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上边替换成下边</span></span><br><span class="line"></span><br><span class="line">Span* span = _spanPool.<span class="built_in">New</span>();</span><br></pre></td></tr></table></figure><blockquote><p>在线程申请创建thread cache时，也是通过new进行申请的，同样进行替换</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (pTLSThreadCache == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*pTLSThreadCache = new ThreadCache;*/</span></span><br><span class="line"><span class="type">static</span> ObjectPool&lt;ThreadCache&gt; tcPool;</span><br><span class="line">pTLSThreadCache = tcPool.<span class="built_in">New</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="释放-2">释放</h2><blockquote><p>对应的delete也要替换成定长内存池的Delete</p></blockquote><h1>释放内存优化为不传对象大小</h1><blockquote><p>我们用free时，只需要传入一个指针即可，但是我们目前的内存池释放内存，不仅要传入指针，还需要传入待释放内存的大小，我们也需要优化为不传入对象的大小</p></blockquote><p>我们可以在span对象中增加成员：ObjSize 用来记录span中每个对象的大小</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> _ObjSize = <span class="number">0</span>; <span class="comment">// 切好的小对象的大小</span></span><br></pre></td></tr></table></figure><p>那我们的释放内存的函数就可以改为下边的写法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">ConcurrentFree</span><span class="params">(<span class="type">void</span>* ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Span* span = PageCache::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">MapObjectToSpan</span>(ptr);</span><br><span class="line"><span class="type">size_t</span> size = span-&gt;_ObjSize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (size &gt; MAX_BYTES)</span><br><span class="line">&#123;</span><br><span class="line">PageCache::<span class="built_in">GetInstance</span>()-&gt;_pageMtx.<span class="built_in">lock</span>();</span><br><span class="line">PageCache::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">ReleaseSpanToPageCache</span>(span);</span><br><span class="line">PageCache::<span class="built_in">GetInstance</span>()-&gt;_pageMtx.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">assert</span>(pTLSThreadCache);</span><br><span class="line">pTLSThreadCache-&gt;<span class="built_in">Deallocate</span>(ptr, size);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>现在的问题就变成了，ObjSize的记录问题了，我们整个内存池中的span对象都是从Page cache层出来的，所以在调用NewSpan的时候，要将切分的对象的大小记录下来，我们申请小于256kb的对象时，都走的thread cache-&gt;central cache-&gt;page cache，另一种情况是大于256kb直接找page cache，这两个地方都需要记录ObjSize</p></blockquote><p>1、在Central层调用NewSpan后，使得span-&gt;ObjSize=size</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们要计算向page cache层要多少页的span</span></span><br><span class="line">Span* span = PageCache::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">NewSpan</span>(SizeClass::<span class="built_in">NumMovePage</span>(size));</span><br><span class="line">span-&gt;_ObjSize = size;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2、CurrentAlloc中，申请大于256KB的对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Span* span = PageCache::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">NewSpan</span>(alignSize);</span><br><span class="line">span-&gt;_ObjSize = alignSize;</span><br></pre></td></tr></table></figure><h1>STL线程安全问题</h1><blockquote><p>我们通过unordered_map，建立了PAGE_ID和Span* 的联系，PageCache层，有读写操作，但是我们在使用PageCache的NewSpan函数时，都会加锁，但是CentralCache层和ConcurrentFree函数中会有读操作，而且并未加锁，这样，可能有线程正在改，就有线程读取，会有线程安全的问题</p></blockquote><p>我们在MapObjectToSpan函数中加锁</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取对象到span的映射</span></span><br><span class="line"><span class="function">Span* <span class="title">PageCache::MapObjectToSpan</span><span class="params">(<span class="type">void</span>* obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">PAGE_ID id = ((PAGE_ID)obj &gt;&gt; PAGE_SHITF);</span><br><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_pageMtx)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (_idSpanMap.<span class="built_in">find</span>(id) != _idSpanMap.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _idSpanMap[id];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">assert</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://atong.run/categories/%E9%A1%B9%E7%9B%AE/">项目</category>
      
      <category domain="https://atong.run/categories/%E9%A1%B9%E7%9B%AE/%E9%AB%98%E5%B9%B6%E5%8F%91%E5%86%85%E5%AD%98%E6%B1%A0/">高并发内存池</category>
      
      
      <category domain="https://atong.run/tags/%E9%A1%B9%E7%9B%AE/">项目</category>
      
      
      <comments>https://atong.run/posts/2734729201/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>7、高并发内存池-释放内存</title>
      <link>https://atong.run/posts/3511365265/</link>
      <guid>https://atong.run/posts/3511365265/</guid>
      <pubDate>Tue, 14 Feb 2023 05:41:56 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;前面几个章节，详细说明了thread cache、central cache、page cache层的结构以及申请内存的逻辑。本节就是讲述回收内存的过程，大致分为下边几步：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;thread cac</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>前面几个章节，详细说明了thread cache、central cache、page cache层的结构以及申请内存的逻辑。本节就是讲述回收内存的过程，大致分为下边几步：</p></blockquote><ul><li>thread cache挂的自由链表过长，将内存释放回central cache</li><li>central cache管理的span的内存块全部回来后，将span释放回page cache</li><li>page cache合并前后相邻的空闲页</li></ul><h1>ThreadCache层回收内存</h1><blockquote><p>当线程释放内存块时，直接将内存块挂到相应的ThreadCache的自由链表，当自由链表的长度达到thread cache层向central cache层申请内存的一个批量的大小我们就进行释放，也就是到MaxSize（慢增长记录）</p></blockquote><pre><code>这里注意，我们增加了FreeList成员_size，并提供了返回它大小的函数Size</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 释放内存</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadCache::Deallocate</span><span class="params">(<span class="type">void</span>* obj, <span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(obj);</span><br><span class="line"><span class="built_in">assert</span>(size &lt;= MAX_BYTES);</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> index = SizeClass::<span class="built_in">Index</span>(size);</span><br><span class="line">_freeLists[index].<span class="built_in">Push</span>(obj);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果自由链表的长度大于申请一个批量的长度就还给central cache </span></span><br><span class="line"><span class="keyword">if</span> (_freeLists[index].<span class="built_in">Size</span>() &gt;= _freeLists[index].<span class="built_in">MaxSize</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">ListTooLong</span>(_freeLists[index], size);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>高并发内存池，ConcurrentDealloc释放内存，内部调用thread cache层的Deallocate函数，Deallocate函数内部调用ListTooLong去处理长链表归还给central cache层</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadCache::ListTooLong</span><span class="params">(FreeList&amp; list, <span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">void</span>* start = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="type">void</span>* end = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先将MaxSize长度的内存，从thread cache层释放出来</span></span><br><span class="line">list.<span class="built_in">PopRange</span>(start, end, list.<span class="built_in">MaxSize</span>());</span><br><span class="line"></span><br><span class="line">CentralCache::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">ReleaseListToSpans</span>(start, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们需要先调用PopRange释放挂在自由链表MaxSize长度（这个之前未实现），然后调用CentralCache层ReleaseListToSpans，来回收这段内存，接下来的工作交给CentralCache层进行处理</p><h1>CentralCache层回收内存</h1><blockquote><p>thread cache层归还回了一段内存，这里就会有一个问题，我们直到Central Cache层的哈希桶结构和映射规则与thread cache层相同，但是central cache层挂的是一个个的span对象，那么这一段内存，应该归还给某个桶的哪个span对象呢？</p></blockquote><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202302131526327.png" alt="image.png"></p><p>在page cache中，申请内存都是按页申请，那么这一页内存到下一页的任何一个地址，右移PAGE_SHIFT位都是这页内存的页号。比如下图的例子，我们就以通过地址来算这块内存应该在那一页，然后去找到对应的span，但是现在我们没办法找到</p><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202302132255489.png" alt="image.png"></p><blockquote><p>为了能通过页号，找到对应span的地址，我们可以建立一个哈希表，映射关系为page_id号和对应span的指针，我们在PageCache类中增加一个哈希表，PageCache层也会用到</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::unordered_map&lt;PAGE_ID, Span*&gt; _idSpanMap;</span><br></pre></td></tr></table></figure><p>这时候就需要记录页号和span* 的对应关系，PageCache的NewSpan函数，返回一个span，我们需要在这个函数里增加相关代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存储nSpan的首尾页跟nSpan建立映射，方便page cache回收内存</span></span><br><span class="line"></span><br><span class="line">_idSpanMap[nSpan-&gt;_pageId] = nSpan;</span><br><span class="line">_idSpanMap[nSpan-&gt;_pageId + nSpan-&gt;_n - <span class="number">1</span>] = nSpan;  <span class="comment">//原理如下图</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回的kSpan，也要建立id和span的映射，方便central cache回收小块内存时，查找对应的span</span></span><br><span class="line"><span class="comment">// 给central层返回的span，会被切分成小块内存，归还的时候地址换成页号就可能是其中的某一页</span></span><br><span class="line"><span class="keyword">for</span> (PAGE_ID i = <span class="number">0</span>; i &lt; kSpan-&gt;_n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">_idSpanMap[kSpan-&gt;_pageId + i] = kSpan;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202302132221620.png" alt="image.png"></p><blockquote><p>记录完映射关系之后，可以继续在封装一个函数，功能就是给我一个地址，我就返回它应该所在的span的地址</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取对象到span的映射</span></span><br><span class="line"><span class="function">Span* <span class="title">PageCache::MapObjectToSpan</span><span class="params">(<span class="type">void</span>* obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">PAGE_ID id = ((PAGE_ID)obj &gt;&gt; PAGE_SHITF);</span><br><span class="line"><span class="keyword">if</span> (_idSpanMap.<span class="built_in">find</span>(id) != _idSpanMap.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _idSpanMap[id];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">assert</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上边前置工作做完之后，可以写ReleaseListToSpans函数了，大致分为以下几点：</p></blockquote><ol><li>通过起始地址，不断向后走，找到对应的span，然后头插进span的自由链表</li><li>让对应的span的_useCount，当减到0说明，这个span的所有内存块都回来了，该span可以被回收</li><li>从spanlist中将对应的span删除掉，然后让pagecache回收</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CentralCache::ReleaseListToSpans</span><span class="params">(<span class="type">void</span>* start, <span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">size_t</span> index = SizeClass::<span class="built_in">Index</span>(size);</span><br><span class="line"></span><br><span class="line">_spanLists[index]._mtx.<span class="built_in">lock</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 问题：换回来的内存挂到哪个span上？</span></span><br><span class="line"><span class="comment">// 通过地址 start&gt;&gt;PAGE_SHIFT，就是span的页号，为了方便，我们可以建立页号和span指针的映射</span></span><br><span class="line"><span class="comment">// 这里可以通过哈希表做- unordered_map&lt;PAGE_ID, Span*&gt; </span></span><br><span class="line"><span class="keyword">while</span> (start)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">void</span>* next = <span class="built_in">NextObj</span>(start);</span><br><span class="line">Span* span = PageCache::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">MapObjectToSpan</span>(start);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 头插进span的管理的链表</span></span><br><span class="line"><span class="built_in">NextObj</span>(start) = span-&gt;_freeList;</span><br><span class="line">span-&gt;_freeList = start;</span><br><span class="line"></span><br><span class="line">span-&gt;_useCount--;</span><br><span class="line"></span><br><span class="line"><span class="comment">// span切分回去的小块内存都回来了</span></span><br><span class="line"><span class="comment">// 将这个span 回收给page cache</span></span><br><span class="line"><span class="keyword">if</span> (span-&gt;_useCount == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">_spanLists[index].<span class="built_in">Erase</span>(span);</span><br><span class="line">span-&gt;_next = <span class="literal">nullptr</span>;</span><br><span class="line">span-&gt;_next = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="comment">// span管理内存，通过页号和页数就可以</span></span><br><span class="line">span-&gt;_freeList = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">_spanLists[index]._mtx.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">PageCache::<span class="built_in">GetInstance</span>()-&gt;_pageMtx.<span class="built_in">lock</span>();</span><br><span class="line">PageCache::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">ReleaseSpanToPageCache</span>(span);</span><br><span class="line"></span><br><span class="line">PageCache::<span class="built_in">GetInstance</span>()-&gt;_pageMtx.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">_spanLists[index]._mtx.<span class="built_in">lock</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">start = next;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//解锁</span></span><br><span class="line">_spanLists[index]._mtx.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>PageCache层回收内存</h1><blockquote><p>page cache就回收span，并且合并相邻的span，可以向前合并也可以向后合并，但是合并有个问题：只能合并没有用的span，如果有的span正在被用就不能合并，大致步骤如下：</p></blockquote><p>首先判断span是否被使用？我们在Span类中增加成员，判断该span对象有没有被使用，默认是没有被使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> _isUse = <span class="literal">false</span>; <span class="comment">//是否被使用</span></span><br></pre></td></tr></table></figure><p>在Central Cache层中我们向PageCache申请新的span，这时需要将isUse改成true，标识这个span被用了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们要计算向page cache层要多少页的span</span></span><br><span class="line">Span* span = PageCache::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">NewSpan</span>(SizeClass::<span class="built_in">NumMovePage</span>(size));</span><br><span class="line">span-&gt;_isUse = <span class="literal">true</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后就是向前向后合并span，需要注意：</p><ul><li>当合并到头了就不再合并了</li><li>前后的页有被使用的也不合并</li><li>合并的长度已经超过128也不再进行合并</li></ul><blockquote><p>向前合并逻辑</p></blockquote><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202302140054029.png" alt="image.png"></p><blockquote><p>向后合并逻辑</p></blockquote><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202302140100674.png" alt="image.png"></p><blockquote><p>整体代码</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 释放空闲span回到PageCache，并合并相邻的span</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PageCache::ReleaseSpanToPageCache</span><span class="params">(Span* span)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 合并相邻的span，向前合并，有问题：前面的span如果被用就不能进行合并</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">PAGE_ID prevId = span-&gt;_pageId - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> ret = _idSpanMap.<span class="built_in">find</span>(prevId);</span><br><span class="line"><span class="comment">//前边的页号没有了就不和并了</span></span><br><span class="line"><span class="keyword">if</span> (ret == _idSpanMap.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前边相邻页在使用，不合并</span></span><br><span class="line">Span* prevSpan = ret-&gt;second;</span><br><span class="line"><span class="keyword">if</span> (prevSpan-&gt;_isUse == <span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//超过128页的span也不合并</span></span><br><span class="line"><span class="keyword">if</span> (prevSpan-&gt;_n + span-&gt;_n &gt; NPAGES - <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进入合并的逻辑</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//span-&gt;_pageId -= prevSpan-&gt;_n;</span></span><br><span class="line">span-&gt;_pageId = prevSpan-&gt;_pageId;</span><br><span class="line">span-&gt;_n += prevSpan-&gt;_n;</span><br><span class="line"></span><br><span class="line">_spanLists[prevSpan-&gt;_n].<span class="built_in">Erase</span>(prevSpan);</span><br><span class="line"><span class="keyword">delete</span> prevSpan;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">PAGE_ID nextID = span-&gt;_pageId + span-&gt;_n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> ret = _idSpanMap.<span class="built_in">find</span>(nextID);</span><br><span class="line"><span class="keyword">if</span> (ret == _idSpanMap.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Span* nextSpan = ret-&gt;second;</span><br><span class="line"><span class="keyword">if</span> (nextSpan-&gt;_isUse == <span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//超过128页的span也不合并</span></span><br><span class="line"><span class="keyword">if</span> (nextSpan-&gt;_n + span-&gt;_n &gt; NPAGES - <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">span-&gt;_n += nextSpan-&gt;_n;</span><br><span class="line"></span><br><span class="line">_spanLists[nextSpan-&gt;_n].<span class="built_in">Erase</span>(nextSpan);</span><br><span class="line"><span class="keyword">delete</span> nextSpan;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">_spanLists[span-&gt;_n].<span class="built_in">PushFront</span>(span);</span><br><span class="line">span-&gt;_isUse = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">_idSpanMap[span-&gt;_pageId] = span;</span><br><span class="line">_idSpanMap[span-&gt;_pageId + span-&gt;_n - <span class="number">1</span>] = span;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://atong.run/categories/%E9%A1%B9%E7%9B%AE/">项目</category>
      
      <category domain="https://atong.run/categories/%E9%A1%B9%E7%9B%AE/%E9%AB%98%E5%B9%B6%E5%8F%91%E5%86%85%E5%AD%98%E6%B1%A0/">高并发内存池</category>
      
      
      <category domain="https://atong.run/tags/%E9%A1%B9%E7%9B%AE/">项目</category>
      
      
      <comments>https://atong.run/posts/3511365265/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>obsidian纯粹版插件推荐</title>
      <link>https://atong.run/posts/3017994336/</link>
      <guid>https://atong.run/posts/3017994336/</guid>
      <pubDate>Sun, 12 Feb 2023 14:24:55 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;只是单纯的记笔记而不是想要all in one，建议别看太多教程，否则你折腾这个软件的功夫很有可能大于你记笔记的功夫（无聊玩随意），如果想要单纯的获得纯粹点的markdown记笔记往下看。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;一、主题篇&quot;&gt;一、主题篇&lt;/h2&gt;
&lt;blockq</description>
        
      
      
      
      <content:encoded><![CDATA[<p>只是单纯的记笔记而不是想要all in one，建议别看太多教程，否则你折腾这个软件的功夫很有可能大于你记笔记的功夫（无聊玩随意），如果想要单纯的获得纯粹点的markdown记笔记往下看。</p><hr><h2 id="一、主题篇">一、主题篇</h2><blockquote><p>适当折腾</p></blockquote><p>建议直接默认即可，默认风格和github README、各种博客平台，无太多美化的个人博客风格差不多，分享时不会差太大。</p><h2 id="二、插件篇">二、插件篇</h2><blockquote><p>少折腾，这里推荐5个，能够带来最单纯简单的使用markdown的体验，大家谨记折腾软件的功夫一定不要大于记笔记的功夫</p></blockquote><h3 id="插件1、Recent-Files">插件1、Recent Files</h3><blockquote><p>这个插件很实用，能看最近打开的文章</p></blockquote><p><img src="https://picx.zhimg.com/80/v2-2a43b3c2f87a0b4e2a0218a404be60e7_1440w.png" alt=""></p><h3 id="插件2、File-Explorer-Note-Count">插件2、File Explorer Note Count</h3><blockquote><p>能显示文件夹下边有几个文件</p></blockquote><p><img src="https://picx.zhimg.com/80/v2-c1070e27a0147824c27ff31952d04a79_1440w.png" alt=""></p><p>​</p><h3 id="插件3、Editing-Toolbar">插件3、Editing Toolbar</h3><blockquote><p>非常实用，将常见的markdown功能，集成为一个小工具条，类似word的上边工具栏</p></blockquote><p><img src="https://picx.zhimg.com/80/v2-6e1c7066841550a84593ef45432964f3_1440w.png" alt=""></p><p>​</p><h3 id="插件4、Advanced-Tables">插件4、Advanced Tables</h3><blockquote><p>obsidian的markdown表格比较难打，这个是增强输入表格功能的插件，只要输入一个 | 加内容然后配合回车和tab键，就可以很方便的搞出来表格，当然它也带了工具栏</p></blockquote><p><img src="https://pic1.zhimg.com/80/v2-46d5ca49fae211260e450719d7bf198f_1440w.png" alt=""></p><p>​</p><h3 id="插件5、Image-Auto-Upload-Plugin">插件5、Image Auto Upload Plugin</h3><blockquote><p>使用markdown图床肯定很重要，我们肯定期望复制图片到笔记软件，图片就能自动上传到图床，然后笔记软件里面有链接，很幸运的是obsidian里面有这个插件，和PicGo配合就可以做到啦，非常方便</p></blockquote><p><img src="https://picx.zhimg.com/80/v2-b6b604e116dc13364e87b1164c0ef1b0_1440w.png" alt=""></p><p>​</p><p><a href="https://post.smzdm.com/p/az6mokvo/">Obsidian和picgo图片自动上传图床教程</a></p><h2 id="三、总结">三、总结</h2><p>切记，记笔记才是正道，别入了折腾软件的坑，然后如果嫌弃obsidian下载插件的网络问题，可以关注我的公众号【孙菜菜】回复 【obsidian】可以获得上边的五个插件。</p><p><img src="https://pica.zhimg.com/80/v2-46fe8b8c98beb6661c01f6443788299b_1440w.png" alt=""></p><p>这几个文件直接拷贝到 你的仓库路径下 \ .obsidian \ plugins里面即可。</p>]]></content:encoded>
      
      
      <category domain="https://atong.run/categories/%E5%B7%A5%E5%85%B7/">工具</category>
      
      <category domain="https://atong.run/categories/%E5%B7%A5%E5%85%B7/obsidian/">obsidian</category>
      
      
      <category domain="https://atong.run/tags/%E7%AC%94%E8%AE%B0/">笔记</category>
      
      
      <comments>https://atong.run/posts/3017994336/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>6、高并发内存池-PageCache</title>
      <link>https://atong.run/posts/2890609329/</link>
      <guid>https://atong.run/posts/2890609329/</guid>
      <pubDate>Fri, 10 Feb 2023 15:16:52 GMT</pubDate>
      
        
        
      <description>&lt;h1&gt;框架结构&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;central cache对应的桶里如果没有span对象，需要向page cache层申请一个非空的span，page cache也是哈希桶的结构，同样通过双向链表组织一个个的span对象，但是映射规则和thread c</description>
        
      
      
      
      <content:encoded><![CDATA[<h1>框架结构</h1><blockquote><p>central cache对应的桶里如果没有span对象，需要向page cache层申请一个非空的span，page cache也是哈希桶的结构，同样通过双向链表组织一个个的span对象，但是映射规则和thread cache和central cache层不同，page cache的逻辑抽象结构如下：</p></blockquote><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202302101543881.png" alt="33250a692c214c8286b38ba3c6c96847.png"></p><pre><code>page cache采用直接定址法，几号桶就是挂的几页的span，pageche的span对象是按页为单位，并没有切分成小对象，central cache会申请固定页数的span，然后进行切分</code></pre><h1>具体实现</h1><h2 id="page-cahe-类">page cahe 类</h2><blockquote><p>page cache 这里设计span最多有128页（128 * 8 * 1024 = 1m），也可以有设计成其他大小，我们设计的thread cahche层最大申请256kb的对象，128页能切成4个，然后我们让几号桶对应几页的span，为了方便整个page cache类设计为129个桶，空出来0号桶</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// page cache桶的个数 - 这里设置为129个，0号桶不用</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">size_t</span> NPAGES = <span class="number">129</span>;</span><br></pre></td></tr></table></figure><blockquote><p>page cahce类在整个进程里只有一个，我们同样设计成单例模式，这里需要注意的是，多个线程申请对象，thread cache层没有内存需要向central cache申请，central cache只需要加桶锁就可以，但是page cache最好整个加锁，因为page cache可能涉及到多页的span切分的问题，并且当central cache归还span，page cache也会尝试将该span和其他桶的span进行合并，这样就会访问page cache的多个桶，造成频繁的加锁和解锁。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PageCache</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//整个进程只有一份，同样设计成单例模式</span></span><br><span class="line"><span class="function"><span class="type">static</span> PageCache* <span class="title">GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> &amp;_sInst;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 要一个k页的span</span></span><br><span class="line"><span class="function">Span* <span class="title">NewSpan</span><span class="params">(<span class="type">size_t</span> k)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">std::mutex _pageMtx;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">PageCache</span>() &#123;&#125;;</span><br><span class="line"><span class="built_in">PageCache</span>(<span class="type">const</span> PageCache&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">SpanList _spanLists[NPAGES];</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PageCache _sInst;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>类内提供一个获取k页span的接口</p></blockquote><h2 id="实现逻辑">实现逻辑</h2><blockquote><p>我们先继续完善central层的逻辑，上节说从中心缓存获取一定数量的对象给thread cache，用了一个FatchRangeObj的函数，这个函数的内部，首先要保证CentralCache层有一个非空的span，那么如何保证有一个非空的span呢？大致思路是先从central cache对应的桶里找，如果没有就往下找Page Cache层要。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取一个非空的span</span></span><br><span class="line"><span class="function">Span* <span class="title">CentralCache::GetOneSpan</span><span class="params">(SpanList&amp; list, <span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>我们继续完善这个函数</code></pre><blockquote><p>步骤1、先去size 对应的桶里找非空的span，这里涉及到链表的遍历操作，我们可以完善一下SpanList类，提供相应的接口方便我们操作</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在spanlist类中增加一下函数，方便遍历操作</span></span><br><span class="line"><span class="function">Span* <span class="title">Begin</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _head-&gt;_next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Span* <span class="title">End</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Empty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _head == _head-&gt;_next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>步骤2、若有非空的span直接返回，如果没有，需要向下一层的PageCache申请新的一页Span，这里我们涉及到加锁、解锁过程，以及如果向下一层申请SPan具体是要多个少页呢？</p></blockquote><pre><code>我们可以先解决要多少页的问题，在SizeClass类中增加NumMovePage函数</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算一次向系统获取多少个页</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">size_t</span> <span class="title">NumMovePage</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 先获取申请size对象大小的上限(尽可能多要一些)</span></span><br><span class="line"><span class="type">size_t</span> num = <span class="built_in">NumMoveSize</span>(size);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 算一下num个对象总共多少字节，然后右移13位就是多少页</span></span><br><span class="line"><span class="type">size_t</span> npage = (num * size) &gt;&gt; PAGE_SHITF;</span><br><span class="line"><span class="comment">// 最少申请1页</span></span><br><span class="line"><span class="keyword">if</span> (npage == <span class="number">0</span>)</span><br><span class="line">npage = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> npage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>步骤3、申请完span后，就要将里面的大块内存进行切分，我们需要直到大块内存的起始地址和结束地址，不断的切成size大小进行尾插，这里尾插有个好处，它的物理地址是连续的，当被线程使用时，可以提高线程的CPU缓存利用率</p></blockquote><blockquote><p>GetOneSpan整体代码</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取一个非空的span</span></span><br><span class="line"><span class="function">Span* <span class="title">CentralCache::GetOneSpan</span><span class="params">(SpanList&amp; list, <span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 1、先去size 对应的桶里找非空的span</span></span><br><span class="line">Span* it = list.<span class="built_in">Begin</span>();</span><br><span class="line"><span class="keyword">while</span> (it != list.<span class="built_in">End</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (it-&gt;_freeList != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> it;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">it = it-&gt;_next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里可以先将这个桶的桶锁进行解锁，其他线程可以释放内存对象回来不会阻塞</span></span><br><span class="line">list._mtx.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 到这里说明，size对应的CentralCache层里面没有Span对象，那么需要向下一层申请</span></span><br><span class="line"><span class="comment">// 先进行整个page cache层的加锁</span></span><br><span class="line">PageCache::<span class="built_in">GetInstance</span>()-&gt;_pageMtx.<span class="built_in">lock</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们要计算向page cache层要多少页的span</span></span><br><span class="line">Span* span = PageCache::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">NewSpan</span>(SizeClass::<span class="built_in">NumMovePage</span>(size));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解锁</span></span><br><span class="line">PageCache::<span class="built_in">GetInstance</span>()-&gt;_pageMtx.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 申请回来的span对象进行切分，这会不需要加锁，因为这会其他线程访问不到这个span（还没挂到spanLists）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 要计算span的大块内存的起始地址和大块内存的大小</span></span><br><span class="line"><span class="comment">// 页号左移PAGE_SHIFT就是地址</span></span><br><span class="line"><span class="type">char</span>* start = (<span class="type">char</span>*)(span-&gt;_pageId &lt;&lt; PAGE_SHITF);</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> bytes = span-&gt;_n &lt;&lt; PAGE_SHITF;</span><br><span class="line"><span class="type">char</span>* end = start + bytes;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 先切一块做头</span></span><br><span class="line">span-&gt;_freeList = start;</span><br><span class="line">start += size;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进行尾插</span></span><br><span class="line"><span class="type">void</span>* tail = span-&gt;_freeList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(start &lt;end)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">NextObj</span>(tail) = start;</span><br><span class="line">tail = <span class="built_in">NextObj</span>(tail);</span><br><span class="line">start += size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 切好span，将span挂到桶里，加锁</span></span><br><span class="line">list._mtx.<span class="built_in">lock</span>();</span><br><span class="line">list.<span class="built_in">PushFront</span>(span);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> span;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>完成上边的代码后我们看看底层的PageCache::NewSpan(size_t k) ，我们这个获取一个NewSpan的大致逻辑为：首先检查第k个桶里有没有span，如果没有，向后边的桶找更大的Span，然后分成k和n-k，返回k页的Span，n-k页的Span挂到相应的桶里</p></blockquote><hr><blockquote><p>步骤1、判断k个桶有没有span如果有，返回头上那个，这时候需要在在SpanList类里面提供一个PopFront函数，同时我们也提供一个PushFront的函数，方便之后的操作</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头删返回</span></span><br><span class="line"><span class="function">Span* <span class="title">PopFront</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Span* sp = _head-&gt;_next;</span><br><span class="line"><span class="comment">/*head-&gt;_next = sp-&gt;_next;</span></span><br><span class="line"><span class="comment">sp-&gt;_next = nullptr;</span></span><br><span class="line"><span class="comment">return sp;*/</span></span><br><span class="line"><span class="built_in">Erase</span>(sp);</span><br><span class="line"><span class="keyword">return</span> sp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 头插</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PushFront</span><span class="params">(Span* span)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">Insert</span>(<span class="built_in">Begin</span>(), span);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>步骤2、如果没有，遍历后面的桶，如果有，就切成k和n-k，返回k页的span，n-k页的span插入到对应的桶</p></blockquote><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202302102055998.png" alt="image.png"></p><blockquote><p>步骤3、如果从k+1到NPAGES-1桶都没有span，那么只能通过系统调用向堆申请，这里直接申请128页的span，申请成功后，还是走步骤2的逻辑，可以直接递归处理</p></blockquote><blockquote><p>整体代码</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// page cache 返回一个span</span></span><br><span class="line"><span class="function">Span* <span class="title">PageCache::NewSpan</span><span class="params">(<span class="type">size_t</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 先断言一下</span></span><br><span class="line"><span class="built_in">assert</span>(k &gt; <span class="number">0</span> &amp;&amp; k &lt; NPAGES);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先检查第k个桶里有没有Span</span></span><br><span class="line"><span class="keyword">if</span> (!_spanLists[k].<span class="built_in">Empty</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 头删第一个返回这里去实现PopFront的逻辑</span></span><br><span class="line"><span class="keyword">return</span> _spanLists[k].<span class="built_in">PopFront</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果k号桶为空，检查后面的桶，找到一个非空桶，直到最后一个桶</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = k + <span class="number">1</span>; i &lt; NPAGES; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!_spanLists[i].<span class="built_in">Empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">Span* nSpan = _spanLists[i].<span class="built_in">PopFront</span>();</span><br><span class="line"><span class="comment">// ？</span></span><br><span class="line">Span* kSpan = <span class="keyword">new</span> Span;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分成npan 分一个 k页返回，然后n-k页的span挂到n-k的桶上</span></span><br><span class="line"><span class="comment">// 这里注意，只需要改页号和页数就可以了，span挂的内存的地址按页号取</span></span><br><span class="line">kSpan-&gt;_pageId = nSpan-&gt;_pageId;</span><br><span class="line">kSpan-&gt;_n = k;</span><br><span class="line"></span><br><span class="line">nSpan-&gt;_n -= k;</span><br><span class="line">nSpan-&gt;_pageId += k;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">_spanLists[nSpan-&gt;_n].<span class="built_in">PushFront</span>(nSpan);</span><br><span class="line"><span class="keyword">return</span> kSpan;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 到这里说明后面的所有位置都没有大页的span</span></span><br><span class="line"><span class="comment">// 这时候就需要向堆申请一个128页的span</span></span><br><span class="line">Span* bigSpan = <span class="keyword">new</span> Span;</span><br><span class="line"><span class="type">void</span>* ptr = <span class="built_in">SystemAlloc</span>(NPAGES<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bigSpan-&gt;_n = NPAGES - <span class="number">1</span>;</span><br><span class="line">bigSpan-&gt;_pageId = (PAGE_ID)ptr &gt;&gt; PAGE_SHITF;</span><br><span class="line"></span><br><span class="line">_spanLists[bigSpan-&gt;_n].<span class="built_in">PushFront</span>(bigSpan);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">NewSpan</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>这里注意最后几句的逻辑，我们申请了128页的内存，返回了起始的指针ptr，将这个地址转成整形，右移PAGE_SHIFT位，相当于除以2^13，就是管理这块大块内存的span的页号</p></blockquote><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202302102010347.png" alt="image.png"></p>]]></content:encoded>
      
      
      <category domain="https://atong.run/categories/%E9%A1%B9%E7%9B%AE/">项目</category>
      
      <category domain="https://atong.run/categories/%E9%A1%B9%E7%9B%AE/%E9%AB%98%E5%B9%B6%E5%8F%91%E5%86%85%E5%AD%98%E6%B1%A0/">高并发内存池</category>
      
      
      <category domain="https://atong.run/tags/%E9%A1%B9%E7%9B%AE/">项目</category>
      
      
      <comments>https://atong.run/posts/2890609329/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>5、高并发内存池-CentralCache</title>
      <link>https://atong.run/posts/1806624746/</link>
      <guid>https://atong.run/posts/1806624746/</guid>
      <pubDate>Wed, 08 Feb 2023 15:12:01 GMT</pubDate>
      
        
        
      <description>&lt;h1&gt;Central Cache框架设计&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;当申请对象时，thread cache层对应的自由链表为空时，需要向central cache层申请内存。central cache层框架图如下：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;i</description>
        
      
      
      
      <content:encoded><![CDATA[<h1>Central Cache框架设计</h1><blockquote><p>当申请对象时，thread cache层对应的自由链表为空时，需要向central cache层申请内存。central cache层框架图如下：</p></blockquote><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202302081948813.png" alt="9d6481a02fe24f458b37909674fc3d66.png"></p><p>central cache整体也是一个哈希桶结构，类似于thread cache层，但是central cache层所挂的是span的链表</p><ul><li>span是管理大块内存的数据结构，页为单位</li><li>span里面有个自由链表，管理切割出来的小内存块</li><li>映射关系和对齐规则同thread cache</li></ul><h1>Central Cache具体结构</h1><h2 id="span结构">span结构</h2><blockquote><p>span是管理多个连续页大块内存的跨度结构，具体结构代码如下；</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Span</span></span><br><span class="line">&#123;</span><br><span class="line">PAGE_ID _pageId = <span class="number">0</span>; <span class="comment">//大块内存起始页的页号</span></span><br><span class="line"><span class="type">size_t</span> _n = <span class="number">0</span>; <span class="comment">//页的数量</span></span><br><span class="line"></span><br><span class="line">Span* _next = <span class="literal">nullptr</span>; <span class="comment">//双向链表的结构</span></span><br><span class="line">Span* _prev = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> _useCount = <span class="number">0</span>; <span class="comment">//切好的小块内存，被分配给thread cache的计数</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* _freeList =<span class="literal">nullptr</span>; <span class="comment">//切好小块内存的自由链表</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>首先需要注意的是，span是双向链表的结构，双向链表删除元素非常方便，当将某个span对象归还给page cache层时，双向链表删除非常简单</p><blockquote><p>span是管理以页为单位的大块内存，当归还给page cache层时，为了方便相邻页的合并需要一个页号 pageID，我们用了typedef的类型PAGE_ID</p></blockquote><pre><code>假设一页为8k32位下 进程地址空间有4G，能分 2^32/2^13 = 2^19 个页64位下 进程地址空间有16G，能分 2^64/2^13 = 2^51 个页</code></pre><p>所以不同平台下，PAGE_ID 的类型需要动态调整，这里我们用条件编译实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//x64  _WIN32和_WIN64都有定义</span></span><br><span class="line"><span class="comment">//win32 _WIN32有定义，_WIN64没有定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN64</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> PAGE_ID;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> _WIN32</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">size_t</span> PAGE_ID;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// _WIN64</span></span></span><br></pre></td></tr></table></figure><blockquote><p>这里注意先判断 _WIN64</p></blockquote><h2 id="SpanList结构">SpanList结构</h2><blockquote><p>我们知道central cache层每个哈希桶中挂的是span的链表，我们将这个链表结构定义成带头双向的循环链表</p></blockquote><p>我们目前的核心成员有两个</p><ul><li>Span*</li><li>mutex锁（桶锁，多个线程同时申请一个桶的对象时需要加锁）</li></ul><p>提供，插入和删除和删除的接口</p><ul><li><code>void Insert(Span* pos, Span* newSpan)</code></li><li><code>void Eerase(Span *pos)</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SpanList</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">SpanList</span>()</span><br><span class="line">&#123;</span><br><span class="line">_head = <span class="keyword">new</span> Span;</span><br><span class="line">_head-&gt;_next = _head;</span><br><span class="line">_head-&gt;_prev = _head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(Span* pos, Span* newSpan)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 先断言一下有没有问题</span></span><br><span class="line"><span class="built_in">assert</span>(pos);</span><br><span class="line"><span class="built_in">assert</span>(newSpan);</span><br><span class="line"></span><br><span class="line">Span* prev = pos-&gt;_prev;</span><br><span class="line">newSpan-&gt;_next = pos;</span><br><span class="line">pos-&gt;_prev = newSpan;</span><br><span class="line"></span><br><span class="line">prev-&gt;_next = newSpan;</span><br><span class="line">newSpan-&gt;_prev = prev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Eerase</span><span class="params">(Span *pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(pos);</span><br><span class="line"><span class="built_in">assert</span>(pos != _head);</span><br><span class="line"></span><br><span class="line">Span* prev = pos-&gt;_prev;</span><br><span class="line">Span* next = pos-&gt;_next;</span><br><span class="line"></span><br><span class="line">next-&gt;_prev = prev;</span><br><span class="line">prev-&gt;_next = next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Span* _head;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">std::mutex _mtx; <span class="comment">//桶锁</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>注意，erase时，不需要delete，只需要从链表移除即可，会归还给下一层的page cache</p></blockquote><h2 id="Central-Cache结构">Central Cache结构</h2><blockquote><p>首先Central Cache是哈希桶结构，然后我们期望，每个线程都有属于自己的Thread Cache（用TLS实现无锁），但是Central Cache在整个进程中只有一个，所以我们可以设计成单例模式</p></blockquote><pre><code>单例模式采用饿汉模式，构造函数私有，在静态区创建一个对象</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单例模式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CentralCache</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> CentralCache* <span class="title">GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> &amp;_sInst;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接口？？？</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">static</span> CentralCache _sInst;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">CentralCache</span>()&#123;&#125; <span class="comment">//构造函数私有化</span></span><br><span class="line"><span class="built_in">CentralCache</span>(<span class="type">const</span> CentralCache&amp; c) = <span class="keyword">delete</span>; <span class="comment">//禁用拷贝</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">SpanList _spanLists[NFREELIST]; <span class="comment">// SpanList数组（哈希桶）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>Central Cache逻辑实现</h1><blockquote><p>thread cache层，申请对象，对应自由链表为空时，需要向central cache层申请内存，我们在thread cache部分提供了一个接口FetchFromCentralCache，我们先从这里开始，逐步扩展到整体的central cache的逻辑实现</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从中心缓存获取对象</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">ThreadCache::FetchFromCentralCache</span><span class="params">(<span class="type">size_t</span> index, <span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>thread cache向central申请内存时，最好多给一些，避免频繁申请，那么该给多少比较合适呢？这里提出一个慢开始反馈算法，我们核心想法如下：</p></blockquote><ol><li>最开始不会一次向central cache一次批量的要太多，要太多可能会用不完</li><li>如果不断有要size大小内存的的需求，batchNum也会不断的增长直到上限</li><li>size越大，一次向central cache要的batchNum越小</li><li>size越小，一次向central cache要的batchNum越大。</li></ol><blockquote><p>根据上述规则，我们在SizeClass类增加下述函数</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一次thread cache从中心节点获取多少个</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">size_t</span> <span class="title">NumMoveSize</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(size &gt; <span class="number">0</span>);</span><br><span class="line"><span class="type">size_t</span> num = MAX_BYTES / size;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一次批量移动多少个对象的(慢启动)上限值为[2,512]</span></span><br><span class="line"><span class="comment">// 小对象一次批量上限高</span></span><br><span class="line"><span class="comment">// 大对象一次批量上限低</span></span><br><span class="line"><span class="keyword">if</span> (num &lt; <span class="number">2</span>)</span><br><span class="line">num = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (num &gt; <span class="number">512</span>)</span><br><span class="line">num = <span class="number">512</span>;</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>我们就可以在FetchFromCentralCache函数中调用上面函数获取应该给central cache批量层要多少个对象的个数</p></blockquote> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> batchNum = SizeClass::<span class="built_in">NumMoveSize</span>(size);</span><br></pre></td></tr></table></figure><p>但是若size比较小，batchNum刚开始的时候还是比较大，怎么让小对象它开始的时候也没那么大，满足规则2呢？</p><p>我们可以这样处理，在FreeList结构中，增加一个成员 _ maxSize，并初始化为1，这样thread cache层每一个桶的自由链表都有它的maxSize。并可以写下边的逻辑。</p><pre><code>当batchNum和当前所在自由链表的MaxSize相同时，说明上边MaxSize是较小的那个，我们让MaxSize加1，若不断申请size大小的对象，MaxSize就会不断增大，而【2，512】就可以做这个增加的上限</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> batchNum = std::<span class="built_in">min</span>(SizeClass::<span class="built_in">NumMoveSize</span>(size),_freeLists[index].<span class="built_in">MaxSize</span>());</span><br><span class="line"><span class="keyword">if</span> (_freeLists[index].<span class="built_in">MaxSize</span>() == batchNum)</span><br><span class="line">&#123;</span><br><span class="line">_freeLists[index].<span class="built_in">MaxSize</span>() += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>知道要多少个对象后就向central cache层要batchNum个对象，但是这里就会出现一些问题，central cache层可能不够batchNum个对象，我们看下边处理</p></blockquote><pre><code>首先是给CentralCache类提供两个接口。一个是获取非空的Span，另一个就是获取batchNum个对象</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从中心缓存获取一定数量的对象给thread cache</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">CentralCache::FetchRangeObj</span><span class="params">(<span class="type">void</span>*&amp; start, <span class="type">void</span>*&amp; end, <span class="type">size_t</span> batchNum, <span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 先算size大小的对象，对应哪个桶，然后就去哪个桶去申请</span></span><br><span class="line"><span class="type">size_t</span> index = SizeClass::<span class="built_in">Index</span>(size);</span><br><span class="line"><span class="comment">// 申请-加桶锁</span></span><br><span class="line">_spanLists[index]._mtx.<span class="built_in">lock</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 首先保证有一个非空的Span</span></span><br><span class="line">Span* span = <span class="built_in">GetOneSpan</span>(_spanLists[index], size);</span><br><span class="line"><span class="built_in">assert</span>(span);</span><br><span class="line"><span class="built_in">assert</span>(span-&gt;_freeList);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从span中获取batchNum个对象</span></span><br><span class="line"><span class="comment">// 如果不够batchNum，有几个拿几个，返回实际拿到的个数</span></span><br><span class="line"></span><br><span class="line">start = span-&gt;_freeList;</span><br><span class="line">end = start;</span><br><span class="line"><span class="type">int</span> actualNum = <span class="number">1</span>;</span><br><span class="line"><span class="type">size_t</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i&lt;batchNum &amp;&amp; <span class="built_in">NextObj</span>(end) != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">end = <span class="built_in">NextObj</span>(end);</span><br><span class="line">++i;</span><br><span class="line">++actualNum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拿走 actualNum个对象</span></span><br><span class="line">span-&gt;_freeList = <span class="built_in">NextObj</span>(end);</span><br><span class="line"><span class="built_in">NextObj</span>(end) = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解锁</span></span><br><span class="line">_spanLists[index]._mtx.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> actualNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>完善完成上述内容后，我们回到最开始，thread cache向central cache申请内存</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从中心缓存获取对象</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">ThreadCache::FetchFromCentralCache</span><span class="params">(<span class="type">size_t</span> index, <span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 慢开始反馈调节算法</span></span><br><span class="line"><span class="comment">// 先算要多少个size大小的对象</span></span><br><span class="line"><span class="type">size_t</span> batchNum = std::<span class="built_in">min</span>(SizeClass::<span class="built_in">NumMoveSize</span>(size),_freeLists[index].<span class="built_in">MaxSize</span>());</span><br><span class="line"><span class="keyword">if</span> (_freeLists[index].<span class="built_in">MaxSize</span>() == batchNum)</span><br><span class="line">&#123;</span><br><span class="line">_freeLists[index].<span class="built_in">MaxSize</span>() += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 知道要多少个对象后就向central cache层要batchNum个对象</span></span><br><span class="line"><span class="type">void</span>* start;</span><br><span class="line"><span class="type">void</span>* end;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> actualNum = CentralCache::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">FetchRangeObj</span>(start, end, batchNum, size);</span><br><span class="line"><span class="built_in">assert</span>(actualNum &gt;= <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (actualNum == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//只有一个</span></span><br><span class="line"><span class="built_in">assert</span>(start == end);</span><br><span class="line"><span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 将NextObj(start)-end 头插进自由链表，返回start</span></span><br><span class="line">_freeLists[index].<span class="built_in">PushRange</span>(<span class="built_in">NextObj</span>(start), end);</span><br><span class="line"><span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://atong.run/categories/%E9%A1%B9%E7%9B%AE/">项目</category>
      
      <category domain="https://atong.run/categories/%E9%A1%B9%E7%9B%AE/%E9%AB%98%E5%B9%B6%E5%8F%91%E5%86%85%E5%AD%98%E6%B1%A0/">高并发内存池</category>
      
      
      <category domain="https://atong.run/tags/%E9%A1%B9%E7%9B%AE/">项目</category>
      
      
      <comments>https://atong.run/posts/1806624746/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title></title>
      <link>https://atong.run/posts/1/</link>
      <guid>https://atong.run/posts/1/</guid>
      <pubDate>Tue, 07 Feb 2023 13:31:09 GMT</pubDate>
      
      
      
      
      
      
      <comments>https://atong.run/posts/1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Damus下载</title>
      <link>https://atong.run/posts/1935618777/</link>
      <guid>https://atong.run/posts/1935618777/</guid>
      <pubDate>Tue, 07 Feb 2023 13:30:45 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;Damus是一款建立在去中心化网络Nostr（支持加密的端到端私人消息传递等功能）上的应用软件，其中Nostr并不是基于服务器来运行网络，相反，它是利用去中心化中继器来分发消息。中继器（Relay）是托管的服务器，所有人都可以运行中继器。获得其他用</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>Damus是一款建立在去中心化网络Nostr（支持加密的端到端私人消息传递等功能）上的应用软件，其中Nostr并不是基于服务器来运行网络，相反，它是利用去中心化中继器来分发消息。中继器（Relay）是托管的服务器，所有人都可以运行中继器。获得其他用户，比如你好友的更新，需要研究询问多个中继站是否了解其他人的情况；而中继站所做的，就是接受人们的帖子并将其转发给其他人。</p></blockquote><h2 id="下载地址">下载地址</h2><ul><li><p><a href="https://apps.apple.com/ca/app/damus/id1628663131">苹果下载链接Damus</a></p></li><li><p><a href="https://play.google.com/store/apps/details?id=com.vitorpamplona.amethyst&amp;hl=en%E2%80%A6">安卓下载链接Amethyst</a></p></li><li><p><a href="https://snort.social">网页版</a></p></li></ul><blockquote><p>注意不要把你的私钥当做公钥发出来。</p></blockquote><h2 id="换头像方式：">换头像方式：</h2><ul><li>需要图床图片链接</li><li>回到Damus，edit profile，头像的链接粘贴save即可</li></ul><h2 id="使用体验">使用体验</h2><p>已经使用了两天，登录注册体验很不错，不需要提供任何的个人信息，（手机号、邮箱、推特、Facebook…），直接注册给你公钥和私钥，但是使用起来体验十分的差劲，可能是没有监管的原因，各种各样的广告满天飞，没有监管的去中心化社交不大行感觉</p>]]></content:encoded>
      
      
      <category domain="https://atong.run/categories/web3-0/">web3.0</category>
      
      <category domain="https://atong.run/categories/web3-0/%E7%A4%BE%E4%BA%A4/">社交</category>
      
      
      <category domain="https://atong.run/tags/web3-0/">web3.0</category>
      
      
      <comments>https://atong.run/posts/1935618777/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>4、高并发内存池-ThreadCache</title>
      <link>https://atong.run/posts/1785806469/</link>
      <guid>https://atong.run/posts/1785806469/</guid>
      <pubDate>Tue, 07 Feb 2023 12:04:43 GMT</pubDate>
      
        
        
      <description>&lt;h1&gt;框架设计&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;thread cache是哈希桶的结构，每个桶是一个按桶位置映射大小的内存块对象的自由链表，我们知道定长内存池只有一个自由链表，因为它每个内存块对象大小相等，但是我们这个内存池需要支持不同大小的内存块，所以需要多个自由链</description>
        
      
      
      
      <content:encoded><![CDATA[<h1>框架设计</h1><blockquote><p>thread cache是哈希桶的结构，每个桶是一个按桶位置映射大小的内存块对象的自由链表，我们知道定长内存池只有一个自由链表，因为它每个内存块对象大小相等，但是我们这个内存池需要支持不同大小的内存块，所以需要多个自由链表。</p></blockquote><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202302031953455.png" alt="thread_cache.png"></p><p>具体抽象结构大致如上，每个线程都会有一个thread cache对象，这样每个线程在这里获取对象和释放对象的时候是无锁的。</p><h2 id="申请内存">申请内存</h2><ol><li>当内存申请size&lt;=256kb时，先获取线程本地存储的thread cache对象，计算size映射的哈希桶自由链表的下标i</li><li>如果自由链表的freeLists[i] 中有对象，则直接Pop一个内存对象返回</li><li>如果freeLists[i]中没有对象，则批量从central cache中获取一定数量的对象，插入到自由链表，并返回一个对象</li></ol><h2 id="释放内存">释放内存</h2><ol><li>当释放内存小于256kb时将内存释放回thread cache，计算size映射自由链表桶位置i，将对象Push到freeList[i]</li><li>当链表的长度过长，则回收一部分内存对象到central cache</li></ol><h2 id="内存碎片">内存碎片</h2><blockquote><p>外碎片问题前边已经讲过，这里只说一下内碎片的问题，如果我们将每种字节数都用一个自由链表管理，那么256kb就是256* 1024个自由链表，这样自由链表的数量会太多，这些头指针就会占据大量内存。所以可以采取类似上边抽象图。8字节对齐，16字节…</p></blockquote><p>我们所用对象的大小可能并不是准确的8、16…，有可能是1字节，14字节，但是我们仍然给对应的8字节16字节，那么就会有部分内存浪费，也就是内碎片问题</p><h1>具体实现</h1><h2 id="对齐规则">对齐规则</h2><blockquote><p>我们thread cache，底层是哈希桶，我们希望桶的数量不那么多，同时内碎片的浪费综合起来也不那么多。综合考量，使不同范围内的字节数按照不同的对齐数对齐，如下所示：</p></blockquote><table><thead><tr><th style="text-align:center">字节数</th><th style="text-align:center">对齐数</th><th style="text-align:center">哈希桶下标</th></tr></thead><tbody><tr><td style="text-align:center">1 ~ 128</td><td style="text-align:center">8字节对齐</td><td style="text-align:center">0 - 15</td></tr><tr><td style="text-align:center">128+1 ~ 1024</td><td style="text-align:center">16字节对齐</td><td style="text-align:center">16 - 71</td></tr><tr><td style="text-align:center">1024+1 ~ 8*1024</td><td style="text-align:center">128字节对齐</td><td style="text-align:center">72 - 127</td></tr><tr><td style="text-align:center">8*1024+1 ~ 64*1024</td><td style="text-align:center">1024字节对齐</td><td style="text-align:center">128 - 183</td></tr><tr><td style="text-align:center">64*1024+1 ~ 256*1024</td><td style="text-align:center">8*1024字节对齐</td><td style="text-align:center">184 - 207</td></tr></tbody></table><p>举几个例子：</p><ul><li>1~128字节，都按8字节对齐，也就是1字节的话，会给你8字节，浪费7个字节</li><li>129~1024字节，按16字节对齐，申请129会给129+16-1=144字节，会浪费15字节，比重为：15/144</li><li>1025~8*1024字节，按128字节对齐，申请1025会给1025+128-1=1152字节，浪费127字节，比重为：127/1152</li><li>…</li></ul><blockquote><p>1~128字节区间最多浪费7个字节，后面范围浪费字节的比重大概都在10%左右。</p></blockquote><h2 id="功能实现">功能实现</h2><h3 id="ThreadCache类">ThreadCache类</h3><blockquote><p>我们先定义这个threadcache类，功能有申请内存、释放内存和从中心缓存获取对象</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadCache</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 申请内存</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">Allocate</span><span class="params">(<span class="type">size_t</span> size)</span></span>;</span><br><span class="line"><span class="comment">// 释放内存</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Deallocate</span><span class="params">(<span class="type">void</span>* obj, <span class="type">size_t</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从中心缓存获取对象</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">FetchFromCentralCache</span><span class="params">(<span class="type">size_t</span> index, <span class="type">size_t</span> size)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">// 管理各种内存大小的自由链表的哈希桶</span></span><br><span class="line">FreeList _freeLists[NFREELIST];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="自由链表类">自由链表类</h3><blockquote><p>我们的是管理自由链表的哈希桶，自由链表有多个，定义一个类实现，功能和实现我们之前的定长内存池一样，成员就是一个void*的指针，提供push、pop和empty接口。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span>*&amp; <span class="title">NextObj</span><span class="params">(<span class="type">void</span>* obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> *(<span class="type">void</span>**)obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 管理切分好的小对象的自由链表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FreeList</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Push</span><span class="params">(<span class="type">void</span>* obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(obj);</span><br><span class="line"><span class="comment">//头插</span></span><br><span class="line"><span class="built_in">NextObj</span>(obj) = _freeList;</span><br><span class="line">_freeList = obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">Pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(_freeList); </span><br><span class="line"><span class="comment">//头删</span></span><br><span class="line"><span class="type">void</span>* obj = _freeList;</span><br><span class="line">_freeList = <span class="built_in">NextObj</span>(_freeList);</span><br><span class="line"><span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Empty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _freeList == <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">void</span>* _freeList = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="ThreadCache类实现">ThreadCache类实现</h3><blockquote><p>然后就是 ThreadCache类中成员函数的具体实现，也就是如何申请释放内存</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 申请内存</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">ThreadCache::Allocate</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(size &lt;= MAX_BYTES); </span><br><span class="line"><span class="comment">// 先算size个字节映射到哪个桶，但是不同的字节范围，映射的规则不同，用一个类管理</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 释放内存</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadCache::Deallocate</span><span class="params">(<span class="type">void</span>* obj, <span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从中心缓存获取对象</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">ThreadCache::FetchFromCentralCache</span><span class="params">(<span class="type">size_t</span> index, <span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="对齐-计算下标">对齐+计算下标</h3><blockquote><p>但是开始我们就会面临一个问题，我们申请内存，首先是要看哈希桶的自由链表，我们就要知道申请的字节数对应哪个哈希桶的自由链表，这里涉及到对齐和计算哈希桶下标，我们还是用一个类管理</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算对象大小的对齐映射规则</span></span><br><span class="line"><span class="comment">// 1、需要将对应的字节数先向上取整</span></span><br><span class="line"><span class="comment">// 2、取整后的字节数转换到哈希下标</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SizeClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 整体控制在最多10%左右的内碎片浪费</span></span><br><span class="line"><span class="comment">// [1,128]8byte对齐    freelist[0,16)</span></span><br><span class="line"><span class="comment">// [128+1,1024]16byte对齐    freelist[16,72)</span></span><br><span class="line"><span class="comment">// [1024+1,8*1024]128byte对齐    freelist[72,128)</span></span><br><span class="line"><span class="comment">// [8*1024+1,64*1024]1024byte对齐     freelist[128,184)</span></span><br><span class="line"><span class="comment">// [64*1024+1,256*1024]8*1024byte对齐   freelist[184,208)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 要将对应的字节数先向上取整</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">size_t</span> <span class="title">RoundUp</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (size &lt;= <span class="number">128</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _RoundUp(size, <span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (size &lt;= <span class="number">1024</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _RoundUp(size, <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (size &lt;= <span class="number">8</span> * <span class="number">1024</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _RoundUp(size, <span class="number">128</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (size &lt;= <span class="number">64</span> * <span class="number">1024</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _RoundUp(size, <span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (size &lt;= <span class="number">256</span> * <span class="number">1024</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _RoundUp(size, <span class="number">8</span>*<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//说明出现了不想申请的字节数，直接报错</span></span><br><span class="line"><span class="built_in">assert</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 计算映射的哪一个自由链表桶</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">size_t</span> <span class="title">Index</span><span class="params">(<span class="type">size_t</span> bytes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(bytes &lt;= MAX_BYTES);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每个区间有多少个链</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> group_array[<span class="number">4</span>] = &#123; <span class="number">16</span>, <span class="number">56</span>, <span class="number">56</span>, <span class="number">56</span> &#125;;</span><br><span class="line"><span class="keyword">if</span> (bytes &lt;= <span class="number">128</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> _Index(bytes, <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (bytes &lt;= <span class="number">1024</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> _Index(bytes - <span class="number">128</span>, <span class="number">4</span>) + group_array[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (bytes &lt;= <span class="number">8</span> * <span class="number">1024</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> _Index(bytes - <span class="number">1024</span>, <span class="number">7</span>) + group_array[<span class="number">1</span>] + group_array[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (bytes &lt;= <span class="number">64</span> * <span class="number">1024</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> _Index(bytes - <span class="number">8</span> * <span class="number">1024</span>, <span class="number">10</span>) + group_array[<span class="number">2</span>] + group_array[<span class="number">1</span>] + group_array[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (bytes &lt;= <span class="number">256</span> * <span class="number">1024</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> _Index(bytes - <span class="number">64</span> * <span class="number">1024</span>, <span class="number">13</span>) + group_array[<span class="number">3</span>] + group_array[<span class="number">2</span>] + group_array[<span class="number">1</span>] + group_array[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="对齐">对齐</h4><blockquote><p>我们用一个子函数实现这个功能</p></blockquote><p>常规写法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> _RoundUp(<span class="type">size_t</span> bytes, <span class="type">size_t</span> alignNum)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 常规写法</span></span><br><span class="line"><span class="keyword">if</span> (bytes % alignNum == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> bytes;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 9 对齐到16 | 9/8+1=2 2*8=16</span></span><br><span class="line"><span class="comment">// 就是看当前的size占几个对齐数，然后+1 再乘对齐数</span></span><br><span class="line"><span class="built_in">return</span> (bytes / alignNum + <span class="number">1</span>) * alignNum;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>牛比写法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> _RoundUp(<span class="type">size_t</span> bytes, <span class="type">size_t</span> alignNum)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> ((bytes + alignNum - <span class="number">1</span>) &amp; ~(alignNum - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体例子说明：</p><p>字节数为1，应该对齐到8<br>前半部分：1+8-1=8    二进制：0000 1000<br>后半部分：8-1=7        二进制：0000 0111</p><p>8 &amp;~ 7 = 8</p><p>字节数为10，应该对齐到16<br>前半部分：10+8-1=17  二进制：0001 0001<br>后半部分： 8-1=7         二进制：0000 0111</p><p>10 &amp;~7 = 10000 = 16</p><p>8：1000<br>~7：1111 1000<br>别的数和~7相与，后3位会变成0<br>16：10000<br>~15：1111 0000<br>别的数和~15相与，后4位会变成0<br>…</p><blockquote><p>它的原理是让当前的字节数+对齐数-1，这样就大于或等于一个向上对齐的大小，然后与后面一部分相与，去掉多余的部分</p></blockquote><h4 id="计算下标">计算下标</h4><p>1字节，在0号桶<br>10字节，在1号桶<br>…<br>129字节，在16号桶</p><p>···</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">size_t</span> _Index(<span class="type">size_t</span> bytes, <span class="type">size_t</span> align_shift)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> ((bytes + (<span class="number">1</span> &lt;&lt; align_shift) - <span class="number">1</span>) &gt;&gt; align_shift) - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>和上边算对齐数有点像</p></blockquote><p>比如 1字节：</p><ul><li>1+（1&lt;&lt;3) -1 = 8  （部分是当前字节数加了一个对齐数-1，这个数大于等于当前字节所要对齐的那个对齐数）</li><li>8&gt;&gt;3=1 (相当于除以一个对齐数)</li><li>1-1=0</li></ul><p>比如10字节：</p><ul><li>10+(1&lt;&lt;3)-1=17</li><li>17&gt;&gt;3=2</li><li>2-1=1</li></ul><h3 id="ThreadCache类继续">ThreadCache类继续</h3><blockquote><p>完成上边的功能后，我们可以具体写ThreadCache类的实现了</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">ThreadCache::Allocate</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(size &lt;= MAX_BYTES); </span><br><span class="line"><span class="comment">// 先算size个字节映射到哪个桶，但是不同的字节范围，映射的规则不同，用一个类管理</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//找到当前字节数的对齐数，以及对应哈希桶的下标</span></span><br><span class="line"><span class="type">size_t</span> alignSize = SizeClass::<span class="built_in">RoundUp</span>(size);</span><br><span class="line"><span class="type">size_t</span> index = SizeClass::<span class="built_in">Index</span>(size);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果所在自由链表不为空，头删返回头节点</span></span><br><span class="line"><span class="keyword">if</span> (!_freeLists[index].<span class="built_in">Empty</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _freeLists[index].<span class="built_in">Pop</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//为空，则去CentralCache层获取</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">FetchFromCentralCache</span>(index, alignSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放内存</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadCache::Deallocate</span><span class="params">(<span class="type">void</span>* obj, <span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(obj);</span><br><span class="line"><span class="built_in">assert</span>(size &lt;= MAX_BYTES);</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> index = SizeClass::<span class="built_in">Index</span>(size);</span><br><span class="line">_freeLists[index].<span class="built_in">Push</span>(obj);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ThreadCache无锁访问">ThreadCache无锁访问</h3><blockquote><p>每个线程都有自己的thread cache，如何创建这个thread cache呢？如果创建为全局，那么肯定是需要锁来控制</p></blockquote><p>如果实现每个线程无锁的访问thread cache，就需要用到线程局部存储TLS(Thread Local Storage)，使用该方式存储的遍历在它所在的线程全局是可访问的，但是不能被其他线程访问到，可以保证线程的独立性。</p><blockquote><p>我们在 声明下边这个指针、</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TLS thread local storage</span></span><br><span class="line"><span class="type">static</span> _declspec(thread) ThreadCache* pTLSThreadCache = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><blockquote><p>在整个调用中可以用下述方式</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">ConcurrentAlloc</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pTLSThreadCache == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">pTLSThreadCache = <span class="keyword">new</span> ThreadCache;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码，获取进程的id</span></span><br><span class="line">cout &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; pTLSThreadCache &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> pTLSThreadCache-&gt;<span class="built_in">Allocate</span>(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">ConcurrentDealloc</span><span class="params">(<span class="type">void</span>* ptr, <span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(pTLSThreadCache);</span><br><span class="line">pTLSThreadCache-&gt;<span class="built_in">Deallocate</span>(ptr, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://atong.run/categories/%E9%A1%B9%E7%9B%AE/">项目</category>
      
      <category domain="https://atong.run/categories/%E9%A1%B9%E7%9B%AE/%E9%AB%98%E5%B9%B6%E5%8F%91%E5%86%85%E5%AD%98%E6%B1%A0/">高并发内存池</category>
      
      
      <category domain="https://atong.run/tags/%E9%A1%B9%E7%9B%AE/">项目</category>
      
      
      <comments>https://atong.run/posts/1785806469/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>hexo-butterfly主题-giscus评论</title>
      <link>https://atong.run/posts/3307342311/</link>
      <guid>https://atong.run/posts/3307342311/</guid>
      <pubDate>Sun, 05 Feb 2023 07:39:55 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;1、创建新仓库&quot;&gt;1、创建新仓库&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202302051226551.png&quot; alt=&quot;image.</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="1、创建新仓库">1、创建新仓库</h2><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202302051226551.png" alt="image.png"></p><h2 id="2、安装giscus">2、安装giscus</h2><p>点击这个链接安装：<a href="https://github.com/apps/giscus">GitHub Apps - giscus</a></p><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202302051226562.png" alt="image.png"></p><p>选择刚建立的仓库，点击install</p><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202302051228750.png" alt="image.png"></p><h2 id="3、配置仓库discuss部分">3、配置仓库discuss部分</h2><p>首先打开仓库的setting，将Discussions部分打上对号</p><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202302051535566.png" alt="image.png"></p><p>然后建立一个Announcements的分类</p><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202302051537858.png" alt="image.png"></p><h2 id="4、进入giscus配置">4、进入giscus配置</h2><p>链接在这：<a href="https://giscus.app/zh-CN">giscus</a></p><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202302051524708.png" alt="image.png"></p><p>配置完上述部分后，可以在启动giscus下边复制几个东西</p><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202302051530141.png" alt="image.png"></p><p>将上边复制的东西填到butterfly主题配置文件的这里就可以了</p><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202302051531097.png" alt="image.png"></p><h2 id="5、大功告成">5、大功告成</h2><p>博客文章部分就有了下边的评论区</p><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202302051538865.png" alt="image.png"></p>]]></content:encoded>
      
      
      <category domain="https://atong.run/categories/%E5%B7%A5%E5%85%B7/">工具</category>
      
      <category domain="https://atong.run/categories/%E5%B7%A5%E5%85%B7/%E5%8D%9A%E5%AE%A2/">博客</category>
      
      
      
      <comments>https://atong.run/posts/3307342311/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
