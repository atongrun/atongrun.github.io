<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>孙菜菜</title>
    <link>http://example.com/</link>
    
    <atom:link href="http://example.com/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>万千不如意，睡得着就过得去</description>
    <pubDate>Fri, 03 Feb 2023 11:24:33 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>高并发内存池-框架</title>
      <link>http://example.com/posts/1235732513/</link>
      <guid>http://example.com/posts/1235732513/</guid>
      <pubDate>Fri, 03 Feb 2023 11:23:44 GMT</pubDate>
      
        
        
      <description>&lt;h1&gt;问题考虑&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;主要是在多线程高并发的场景下，性能更强，主要考虑下面几个问题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;性能问题&lt;/li&gt;
&lt;li&gt;多线程环境下，锁竞争问题&lt;/li&gt;
&lt;li&gt;内存碎片问题&lt;/li&gt;
&lt;/ol</description>
        
      
      
      
      <content:encoded><![CDATA[<h1>问题考虑</h1><blockquote><p>主要是在多线程高并发的场景下，性能更强，主要考虑下面几个问题</p></blockquote><ol><li>性能问题</li><li>多线程环境下，锁竞争问题</li><li>内存碎片问题</li></ol><h1>组成部分</h1><blockquote><p>concurrent memory pool 主要由三部分构成：thread cache、central cache、page cache，如下图所示</p></blockquote><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202302031859699.png" alt="sdsdasd.drawio.png"></p><ol><li><strong>thread cache</strong> : 线程缓存，是每个线程独有的，用于小于256kb内存的分配，线程从这里申请内存不需要加锁，每个线程独享一个cache，这也是内存池高效的原因</li><li><strong>central cache</strong> : 中心缓存，被所有线程共享，thread cache是按需从central cache 中获取的对象，central cache合适的时机回收thread cache的对象，避免一个线程占用过多的内存，而其他线程内存不足，使得内存分配在多个线程中更均衡的按需调度，cnetral cache是存在竞争的，从这里获取内存对象需要加锁，但是这里用的是<strong>桶锁</strong>，而且只有thread cache没有内存对象时，才会找central  cache，所以这里竞争不会很激烈。</li><li><strong>page cache</strong> : 页缓存，是在central cache缓存上面的一层缓存，存储的内存是以页为单位存储及分配的，central cache没有内存对象时，从page cache分配出一定数量的page，并且切割成定长大小的小块内存，分配给central cache，当一个span的几个跨度页的对象都回收以后，page cache会回收central cache满足条件的span对象，并且合并相邻的页，组成更大的页，缓解内存碎片的问题。</li></ol><h1>总结</h1><blockquote><p>高并发内存池的这三部分都挺复杂，后面也会具体分为三个章节谈论这三个部分的原理以及实现。</p></blockquote>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/%E9%A1%B9%E7%9B%AE/">项目</category>
      
      <category domain="http://example.com/categories/%E9%A1%B9%E7%9B%AE/%E9%AB%98%E5%B9%B6%E5%8F%91%E5%86%85%E5%AD%98%E6%B1%A0/">高并发内存池</category>
      
      
      
      <comments>http://example.com/posts/1235732513/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>高并发内存池-预备</title>
      <link>http://example.com/posts/594127029/</link>
      <guid>http://example.com/posts/594127029/</guid>
      <pubDate>Thu, 02 Feb 2023 08:41:52 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，做项目也是一样，先从简单的部分做起，在正式的项目开始前，可以先来个开胃菜，一是可以熟悉简单的内存池是如何控制的，二是会作为之后内存池的一个基本组件。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1&gt;mallo</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>不积跬步，无以至千里；不积小流，无以成江海，做项目也是一样，先从简单的部分做起，在正式的项目开始前，可以先来个开胃菜，一是可以熟悉简单的内存池是如何控制的，二是会作为之后内存池的一个基本组件。</p></blockquote><h1>malloc和定长内存池对比</h1><blockquote><p>malloc场景如下，malloc是一个通用的内存池，在什么场景下都可以使用，但这也意味着malloc在什么场景下都不会有很高的性能，因为malloc并不是针对某种场景专门设计的。</p></blockquote><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  flowchart TDA[场景A] --&gt; B(malloc)E[场景B] --&gt; B(malloc)C[场景C] --&gt; B(malloc)  </pre></div><blockquote><p>定长内存池就是针对固定大小内存块申请和释放的内存池，由于定长内存池只需要支持固定大小内存块的申请和释放，因此我们可以将其性能做到极致，并且在实现定长内存池时不需要考虑内存碎片等问题，因为我们申请/释放的都是固定大小的内存块。</p></blockquote><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  flowchart BTA[内存池A] --&gt; B1(场景A)E[内存池B] --&gt; B2(场景B)C[内存池C] --&gt; B3(场景C)  </pre></div><h1>定长内存池实现</h1><h2 id="框架设计">框架设计</h2><blockquote><p>我们的思路是先申请大块内存，每次申请就切sizeof(T)大小的内存块，释放后，用链表组织起来，每个内存块前4/8个字节存下一个内存块的地址，再次申请内存时，如果_freeList不为空，就重复利用</p></blockquote><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202302012204835.png" alt="image.png"></p><h3 id="核心成员">核心成员</h3><ul><li>_ memory：指向申请大块内存的空间</li><li>_ freeList：组织归还的内存块的链表</li><li>_ remainBytes：大块内存剩余字节数</li></ul><h3 id="存在问题">存在问题</h3><ul><li>大块内存，剩下的内存不足一个T的大小如何处理？</li><li>T的类型大小若是小于指针的大小如何处理？</li><li>内存块的前段内存存指针，这个大小是4？还是8？能不能考虑平台兼容？</li><li>如何取一块内存的前4/8个字节？</li></ul><blockquote><p>这些问题怎么解决呢？我们在下面的内容详细讲解</p></blockquote><h2 id="成员函数">成员函数</h2><h3 id="New">New</h3><blockquote><p>申请内存，返回对应类型的指针，我们首先看一下流程图</p></blockquote><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202302021614783.png" alt="eeee.png"></p><blockquote><p>如果按照上述流程，先申请了大块内存之后，每次切T类型大小的内存块，但是最后的时候剩余的内存块不够的话，就会出现越界问题，所有，我们有了remainBytes成员，这个标识剩余的容量，当剩下的内存不足一个T的大小，我们就直接申请大块内存，初始的时候remainBytes为0，也是小于T的大小，同样进行申请，这就回答了第一个问题，和remainBytes成员的用处。</p></blockquote><p>然后我们来看一下具体申请的两种操作：</p><blockquote><p>1、在大块内存上切内存块，返回_memory的地址，然后让_memory往后移动sizeof(T)的距离。这也是我们为什么将memory成员设置为char * 的原因，因为+1操作就是往后移动一个字节。</p></blockquote><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202302021358722.png" alt="image.png"></p><blockquote><p>2、如过freeList不为空，就头删取头节点返回即可</p></blockquote><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202302021455261.png" alt="image.png"></p><p>New代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T* <span class="title">New</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">T* obj = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">if</span> (_freeList) <span class="comment">//freeList不为空</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 直接进行头删</span></span><br><span class="line">obj = (T*)_freeList;</span><br><span class="line"><span class="comment">/* freeList指向下一个节点，我们首先得取出来freeList指向得内存块中得前</span></span><br><span class="line"><span class="comment">指针大小的字节，但是32位平台下，指针的大小为4，64位平台指针的大小为8，如果是4的话，我们可以将freeList强转为int* 然后解引用拿到了前4个字节，但是在64位平台下指针的大小占8个字节，这个就不行了。</span></span><br><span class="line"><span class="comment">我们可以将 freeList强转为二级指针，解引用就是一级指针，这样就能拿到4或者8个字节了。这就回答了后边两个问题</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">_freeList = *(<span class="type">void</span>**)_freeList;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//说明需要先申请大块内存</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (_remainBytes &lt; <span class="built_in">sizeof</span>(T))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//说明需要先申请大块内存</span></span><br><span class="line">_remainBytes = <span class="number">128</span> * <span class="number">1024</span>;</span><br><span class="line">_memory = (<span class="type">char</span>*)<span class="built_in">malloc</span>(_remainBytes);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">size_t</span> objSize = <span class="built_in">sizeof</span>(T) &gt; <span class="built_in">sizeof</span>(<span class="type">void</span>*) ? <span class="built_in">sizeof</span>(T) : <span class="built_in">sizeof</span>(<span class="type">void</span>*);</span><br><span class="line">obj = (T*)_memory;</span><br><span class="line">_memory += objSize;</span><br><span class="line">_remainBytes -= objSize;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对T类型初始化-使用定位new</span></span><br><span class="line"><span class="keyword">new</span>(obj)T;</span><br><span class="line"><span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Delete">Delete</h3><blockquote><p>释放内存（归还内存）, 直接对freeList进行头插操作即可，具体细节放到代码注释部分</p></blockquote><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202302021448061.png" alt="image.png"><br>Delete代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Delete</span><span class="params">(T* obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (obj == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//先显示调用析构</span></span><br><span class="line">obj-&gt;~<span class="built_in">T</span>();</span><br><span class="line"><span class="comment">//头插 进freeList链表</span></span><br><span class="line">*(<span class="type">void</span>**)obj = _freeList;</span><br><span class="line">_freeList = (<span class="type">void</span>*)obj;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="性能测试">性能测试</h2><blockquote><p>性能测试代码很简单，就是不断的申请释放节点，申请的指针用vector保存，然后记录固定次数的申请释放时间就可以了</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> _val;</span><br><span class="line">TreeNode* _left;</span><br><span class="line">TreeNode* _right;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TreeNode</span>()</span><br><span class="line">:_val(<span class="number">0</span>)</span><br><span class="line">, _left(<span class="literal">nullptr</span>)</span><br><span class="line">, _right(<span class="literal">nullptr</span>)</span><br><span class="line">&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestObjectPool</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 申请释放的轮次</span></span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> Rounds = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每轮申请释放多少次</span></span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> N = <span class="number">1000000</span>;</span><br><span class="line"></span><br><span class="line">std::vector&lt;TreeNode*&gt; v1;</span><br><span class="line">v1.<span class="built_in">reserve</span>(N);</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> begin1 = <span class="built_in">clock</span>(); <span class="comment">//记录开始时间</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; Rounds; ++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">&#123;</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="keyword">new</span> TreeNode);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> v1[i];</span><br><span class="line">&#125;</span><br><span class="line">v1.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> end1 = <span class="built_in">clock</span>(); <span class="comment">// 结束时间</span></span><br><span class="line"></span><br><span class="line">std::vector&lt;TreeNode*&gt; v2;</span><br><span class="line">v2.<span class="built_in">reserve</span>(N);</span><br><span class="line"></span><br><span class="line">ObjectPool&lt;TreeNode&gt; TNPool;</span><br><span class="line"><span class="type">size_t</span> begin2 = <span class="built_in">clock</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; Rounds; ++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">&#123;</span><br><span class="line">v2.<span class="built_in">push_back</span>(TNPool.<span class="built_in">New</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">&#123;</span><br><span class="line">TNPool.<span class="built_in">Delete</span>(v2[i]);</span><br><span class="line">&#125;</span><br><span class="line">v2.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">size_t</span> end2 = <span class="built_in">clock</span>();</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;new花费时间:&quot;</span> &lt;&lt; end1 - begin1 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;定长内存池花费时间:&quot;</span> &lt;&lt; end2 - begin2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>经过性能测试，当N是1000000，Release模式下，定长内存池速度大概为new的10几倍</p></blockquote><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202302021531020.png" alt="image.png"></p><h2 id="整体代码">整体代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// _WIN32</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ObjectPool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">T* <span class="title">New</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">T* obj = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">if</span> (_freeList)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 直接进行头删</span></span><br><span class="line">obj = (T*)_freeList;</span><br><span class="line">_freeList = *(<span class="type">void</span>**)_freeList;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//说明需要先申请大块内存</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (_remainBytes &lt; <span class="built_in">sizeof</span>(T))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//说明需要先申请大块内存</span></span><br><span class="line">_remainBytes = <span class="number">128</span> * <span class="number">1024</span>;</span><br><span class="line">_memory = (<span class="type">char</span>*)<span class="built_in">malloc</span>(_remainBytes);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">size_t</span> objSize = <span class="built_in">sizeof</span>(T) &gt; <span class="built_in">sizeof</span>(<span class="type">void</span>*) ? <span class="built_in">sizeof</span>(T) : <span class="built_in">sizeof</span>(<span class="type">void</span>*);</span><br><span class="line">obj = (T*)_memory;</span><br><span class="line">_memory += objSize;</span><br><span class="line">_remainBytes -= objSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//对T类型初始化-使用定位new</span></span><br><span class="line"><span class="keyword">new</span>(obj)T;</span><br><span class="line"><span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Delete</span><span class="params">(T* obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (obj == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//先显示调用析构</span></span><br><span class="line">obj-&gt;~<span class="built_in">T</span>();</span><br><span class="line"><span class="comment">//头插 进freeList链表</span></span><br><span class="line">*(<span class="type">void</span>**)obj = _freeList;</span><br><span class="line">_freeList = (<span class="type">void</span>*)obj;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">char</span>* _memory = <span class="literal">nullptr</span>; <span class="comment">// 指向大块内存的指针</span></span><br><span class="line"><span class="type">size_t</span> _remainBytes = <span class="number">0</span>; <span class="comment">// 大块内存在切分过程中剩余字节数</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* _freeList = <span class="literal">nullptr</span>; <span class="comment">// 还回来过程中链接的自由链表的头指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="内存申请（系统接口）补充">内存申请（系统接口）补充</h2><blockquote><p>在Windows下，可以调用VirtualAlloc函数，申请堆内存</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接去堆上按页申请空间</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">static</span> <span class="type">void</span>* <span class="title">SystemAlloc</span><span class="params">(<span class="type">size_t</span> kpage)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line"><span class="type">void</span>* ptr = <span class="built_in">VirtualAlloc</span>(<span class="number">0</span>, kpage&lt;&lt;<span class="number">13</span>, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="comment">// linux下brk mmap等</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ptr == <span class="literal">nullptr</span>)</span><br><span class="line"><span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>VirtualAlloc是Windows API中的一个函数，它在进程的虚拟地址空间内保留或提交内存页。</p></blockquote><p>传递给VirtualAlloc的参数包括：</p><ul><li>0：要分配的区域的起始地址。0表示系统将选择起始地址。</li><li>kpage&lt;&lt;13：要分配的内存区域的大小（以字节为单位）。kpage&lt;&lt;13表示“kpage乘以2的13次方”。</li><li>MEM_COMMIT | MEM_RESERVE：分配的类型，在本例中，分配的是提交内存和保留内存。</li><li>PAGE_READWRITE：分配所需的内存保护，在这种情况下，指定了读写访问。</li></ul><p>该函数返回指向分配内存的第一个字节的指针，该字节存储在ptr变量中</p><blockquote><p>采用系统调用后，New的申请内存可以按下方的写法</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T* <span class="title">New</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">T* obj = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">if</span> (_freeList)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 直接进行头删</span></span><br><span class="line">obj = (T*)_freeList;</span><br><span class="line">_freeList = *(<span class="type">void</span>**)_freeList;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//说明需要先申请大块内存</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (_remainBytes &lt; <span class="built_in">sizeof</span>(T))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//说明需要先申请大块内存</span></span><br><span class="line">_remainBytes = <span class="number">128</span> * <span class="number">1024</span>;</span><br><span class="line"><span class="comment">//_memory = (char*)malloc(_remainBytes);</span></span><br><span class="line">_memory = (<span class="type">char</span>*)<span class="built_in">SystemAlloc</span>(_remainBytes &gt;&gt; <span class="number">13</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">size_t</span> objSize = <span class="built_in">sizeof</span>(T) &gt; <span class="built_in">sizeof</span>(<span class="type">void</span>*) ? <span class="built_in">sizeof</span>(T) : <span class="built_in">sizeof</span>(<span class="type">void</span>*);</span><br><span class="line">obj = (T*)_memory;</span><br><span class="line">_memory += objSize;</span><br><span class="line">_remainBytes -= objSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//对T类型初始化-使用定位new</span></span><br><span class="line"><span class="keyword">new</span>(obj)T;</span><br><span class="line"><span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/%E9%A1%B9%E7%9B%AE/">项目</category>
      
      <category domain="http://example.com/categories/%E9%A1%B9%E7%9B%AE/%E9%AB%98%E5%B9%B6%E5%8F%91%E5%86%85%E5%AD%98%E6%B1%A0/">高并发内存池</category>
      
      
      
      <comments>http://example.com/posts/594127029/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>震惊！！！C语言也能实现泛型编程吗？？</title>
      <link>http://example.com/posts/2871490963/</link>
      <guid>http://example.com/posts/2871490963/</guid>
      <pubDate>Wed, 01 Feb 2023 11:14:58 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;今天看到一个有意思的知识点，赶紧记录一下，总所周知，C语言没有泛型，但是C11新增了一种表达式，叫做泛型选择表达式(_ Generic)，这个是干啥的呢？它的作用是根据表达式的类型选择一个值，让我们来看一看它具体的语法&lt;/p&gt;
&lt;/blockquo</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>今天看到一个有意思的知识点，赶紧记录一下，总所周知，C语言没有泛型，但是C11新增了一种表达式，叫做泛型选择表达式(_ Generic)，这个是干啥的呢？它的作用是根据表达式的类型选择一个值，让我们来看一看它具体的语法</p></blockquote><h1>泛型选择引入</h1><p>先看一段代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="type">double</span> y = <span class="number">2.0</span>;</span><br><span class="line"><span class="type">char</span> z = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">_Generic</span>(x, <span class="type">int</span>:<span class="number">0</span>, <span class="type">double</span> : <span class="number">1</span>, <span class="keyword">default</span>:<span class="number">3</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">_Generic</span>(y, <span class="type">int</span>:<span class="number">0</span>, <span class="type">double</span> : <span class="number">1</span>, <span class="keyword">default</span>:<span class="number">3</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">_Generic</span>(z, <span class="type">int</span>:<span class="number">0</span>, <span class="type">double</span> : <span class="number">1</span>, <span class="keyword">default</span>:<span class="number">3</span>));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_Generic是C11关键字，后面的圆括号中包含有多个用逗号分隔的项，第一个项是表达式，后面的每一个项都由一个类型、一个冒号和一个值组成，如double: 1。第一个项的类型匹配哪一个标签，整个表达式的值就是该标签后面的值</code></p><p>运行结果如下：</p><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202302011644537.png" alt="image.png"></p><blockquote><p>可以看到，根据传入的变量的类型，打印的结果也不同，第一个printf的第一项x是int，那么整个表达式的结果为0，第二个printf的第一项是double，表达式的结果就是1，第三个printf打印结果为3是因为char类型没有匹配，走了默认的default，结果为3</p></blockquote><p><font color="#ff0000">其实，这个东西很像switch语句，只是Generic用表达式类型匹配标签，switch用表达式的值匹配标签</font></p><h1>与宏定义组合</h1><blockquote><p>我们可以看到啊，上边的用法还是比较恶心麻烦的，但是呢，我们可以结合宏定义组合去玩这个东西，这样就会非常的方便</p></blockquote><p>直接看例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MYTYPE(X) _Generic((X),int:<span class="string">&quot;int&quot;</span>, double:<span class="string">&quot;double&quot;</span>, default:<span class="string">&quot;other&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> d = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, MYTYPE(d));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, MYTYPE(<span class="number">1.0</span>*d));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, MYTYPE(<span class="string">&quot;string&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202302011709745.png" alt="image.png"></p><blockquote><p>与宏定义结合是不是感觉好多了，甚至有点C++泛型编程的感觉了，但是其实还差点。</p></blockquote><h1>进阶玩法</h1><blockquote><p>_ Generic标签对应的值，可以是整形，也可以是字符串，当然也可以是函数指针。</p></blockquote><p>我们来看一下下边的这段代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PrintInt</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">PrintDouble</span><span class="params">(<span class="type">double</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lf\n&quot;</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">PrintSting</span><span class="params">(<span class="type">char</span>* x)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PrintOther</span><span class="params">(<span class="type">void</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">print(<span class="string">&quot;类型有点问题\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINT(X) _Generic((X),\</span></span><br><span class="line"><span class="meta">int:PrintInt,\</span></span><br><span class="line"><span class="meta">double:PrintDouble,\</span></span><br><span class="line"><span class="meta">const char*:PrintSting,\</span></span><br><span class="line"><span class="meta">default:PrintOther)(X)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> y = <span class="number">2.0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* str = <span class="string">&quot;hello _Generic&quot;</span>;</span><br><span class="line">PRINT(x);</span><br><span class="line">PRINT(y);</span><br><span class="line">PRINT(str);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：<br><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202302011719753.png" alt="image.png"></p><blockquote><p>这样是不是和C++的泛型编程很像了呢，是不是挺有意思的，当然还是C++的泛型好用一些。</p></blockquote>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/C/">C</category>
      
      
      <category domain="http://example.com/tags/C11/">C11</category>
      
      
      <comments>http://example.com/posts/2871490963/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>高并发内存池-序章</title>
      <link>http://example.com/posts/4062989894/</link>
      <guid>http://example.com/posts/4062989894/</guid>
      <pubDate>Sun, 29 Jan 2023 14:10:09 GMT</pubDate>
      
        
        
      <description>&lt;h1&gt;项目介绍&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;这是一个CPP实现的高并发内存池，原型是谷歌的tcmalloc开源项目（Thread-Caching Malloc），既线程缓存的malloc，实现了高效的多线程内存管理，用于替代系统的内存分配相关函数（malloc、f</description>
        
      
      
      
      <content:encoded><![CDATA[<h1>项目介绍</h1><blockquote><p>这是一个CPP实现的高并发内存池，原型是谷歌的tcmalloc开源项目（Thread-Caching Malloc），既线程缓存的malloc，实现了高效的多线程内存管理，用于替代系统的内存分配相关函数（malloc、free）</p></blockquote><h1>前置需求</h1><ul><li>C/C++</li><li>数据结构（链表、哈希桶）</li><li>操作系统内存管理</li><li>单例模式</li><li>多线程</li><li>互斥锁</li><li>…</li></ul><h1>内存池简介</h1><h2 id="1、池化技术">1、池化技术</h2><blockquote><p>池化技术就是程序先向系统申请过量的资源，然后自己管理，能大大提升程序的运行效率</p></blockquote><p>常见的池化技术场景</p><ul><li>内存池</li><li>线程池</li><li>对象池</li><li>…</li></ul><h2 id="2、内存池">2、内存池</h2><blockquote><p>内存池是指程序预先从操作系统申请一块足够大内存，此后，当程序中需要申请内存的时候，不是直接向操作系统申请，而是直接从内存池中获取；同理，当程序释放内存的时候，并不真正将内存返回给操作系统，而是返回内存池。当程序退出(或者特定时间)时，内存池才将之前申请的内存真正释放。</p></blockquote><h2 id="3、内存池解决的问题">3、内存池解决的问题</h2><h3 id="内存碎片问题">内存碎片问题</h3><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202301292200227.png" alt="内存碎片.png"></p><h3 id="效率问题">效率问题</h3><blockquote><p>向操作系统频繁申请内存消耗较大，内存池能够避免让程序频繁的向系统申请和释放内存</p></blockquote><h2 id="4、malloc">4、malloc</h2><blockquote><p>C/C++中动态申请内存都是通过malloc去申请内存，malloc本质也是一个内存池，原理如下：</p></blockquote><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202301292206748.png" alt="image.png"></p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/%E9%A1%B9%E7%9B%AE/">项目</category>
      
      <category domain="http://example.com/categories/%E9%A1%B9%E7%9B%AE/%E9%AB%98%E5%B9%B6%E5%8F%91%E5%86%85%E5%AD%98%E6%B1%A0/">高并发内存池</category>
      
      
      
      <comments>http://example.com/posts/4062989894/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>课程推荐-理财篇</title>
      <link>http://example.com/posts/953025558/</link>
      <guid>http://example.com/posts/953025558/</guid>
      <pubDate>Sat, 28 Jan 2023 06:30:51 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;Python数据分析实战：构建股票量化交易系统&quot;&gt;Python数据分析实战：构建股票量化交易系统&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;深入理解量化交易的本质、发展、优势、意义和过程；&lt;/li&gt;
&lt;li&gt;掌握Python基础工具的使用方法，如Python、Pandas、Nu</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="Python数据分析实战：构建股票量化交易系统">Python数据分析实战：构建股票量化交易系统</h2><ul><li>深入理解量化交易的本质、发展、优势、意义和过程；</li><li>掌握Python基础工具的使用方法，如Python、Pandas、Numpy、Matplotlib、TA-Lib、Tushare、statsmodels、pyecharts等；</li><li>掌握Python数据分析和挖掘的过程和技能；</li><li>掌握Python实现经典金融技术指标的方法，如K线、均线、成交量、MACD、KDJ等。</li><li>掌握使用Matplotlib、pyecharts可视化方法绘制出股票行情分析界面以捕捉个股动向，为大家呈现不同的显示效果。</li><li>掌握Python实现应用数学中经典算法，如线性回归、蒙特卡洛、随机漫步、凯利公式等；</li><li>掌握如何从数据特征值中实现常用的量化交易策略，如择时、选股、风险控制、度量、仓位管理等。通过学习我们可以制定量化交易策略以及度量策略效果，应用交易策略来辅助股票交易。</li></ul><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202301281429616.jpg" alt="D90C09628F49A26EBEF4BB6308B6BE05.jpg"></p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/%E6%8E%A8%E8%8D%90/">推荐</category>
      
      <category domain="http://example.com/categories/%E6%8E%A8%E8%8D%90/%E8%AF%BE%E7%A8%8B/">课程</category>
      
      
      
      <comments>http://example.com/posts/953025558/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>课程推荐-后端篇</title>
      <link>http://example.com/posts/3294300332/</link>
      <guid>http://example.com/posts/3294300332/</guid>
      <pubDate>Sat, 28 Jan 2023 06:24:48 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;课程1-MySQL-性能调优必知必会&quot;&gt;课程1 - MySQL 性能调优必知必会&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;数据架构方面：主要讲述 MySQL 主从架构之间可能遇到的问题，以及主从架构如何提高稳定性。&lt;/li&gt;
&lt;li&gt;存储引擎方面：主要讲述 MySQL 数据库</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="课程1-MySQL-性能调优必知必会">课程1 - MySQL 性能调优必知必会</h2><ul><li>数据架构方面：主要讲述 MySQL 主从架构之间可能遇到的问题，以及主从架构如何提高稳定性。</li><li>存储引擎方面：主要讲述 MySQL 数据库中的 InnoDB 存储引擎的底层运行原理以及 InnoDB 存储引擎的优化。</li><li>SQL 方面：主要讲述 SQL 的实现原理，例如，order by（排序）的实现原理及优化、join（连表）的实现原理及优化等，更有一条 SQL 从执行的开始到结束都经历过哪些模块，在使用过程中优化的最佳实践等。</li><li>MySQL 数据安全：主要讲述在 MySQL 数据库中如何防止数据丢失，以及数据库中各种日志的作用。</li></ul><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202301281428630.jpg" alt="11E0A633507956E663577A8E64791E6D.jpg"></p><h2 id="课程2-Python-异步网络编程实战">课程2 - Python 异步网络编程实战</h2><ul><li>从事 Python Web 开发的技术人员</li><li>对 Python 感兴趣，想了解 Python 异步实现过程</li><li>在开发过程中，想使用异步方式提升 Python 性能的开发者</li></ul><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202301281428056.jpg" alt="E6D29224C353AC28FC76ABD734A8C32C.jpg"></p><h2 id="课程3-深入理解-TCP-协议：从原理到实战">课程3 - 深入理解 TCP 协议：从原理到实战</h2><ul><li>学习 TCP 协议多次从入门到放弃的同学</li><li>想通过实验方法学习 TCP 协议的同学</li><li>对于前端工程师，学完可以快速辨识开发中遇到的问题是前端还是后端的问题，对页面性能优化有更深的理解</li><li>对于后端工程师，TCP 协议可以说是必须要掌握的技能，学完能从协议和网络层面快速分析后端诸多分布式组件的问题，对提升接口的性能和分布式系统的可靠性会更有把握</li><li>对于测试工程师，对网络协议理解的越深，越能发现隐藏很深的 Bug，对性能测试、压力测试会有更深的理解</li></ul><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202301281428061.jpg" alt="0F0CD1421DF22FE9CFBA9E317E9E2B45.jpg"></p><h2 id="课程4-开发者必备的-Docker-实践指南">课程4 - 开发者必备的 Docker 实践指南</h2><ul><li>虚拟化技术、容器技术和 Docker 的背景</li><li>Docker 运行环境的搭建</li><li>镜像与容器的管理与使用</li><li>自定义镜像和共享镜像</li><li>通过 Compose 编排应用</li><li>多个使用 Docker 搭建运行环境的实践</li></ul><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202301281429087.jpg" alt="35C46EF4C2C8A41F16DC9C43DE6CA8B6.jpg"></p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/%E6%8E%A8%E8%8D%90/">推荐</category>
      
      <category domain="http://example.com/categories/%E6%8E%A8%E8%8D%90/%E8%AF%BE%E7%A8%8B/">课程</category>
      
      
      
      <comments>http://example.com/posts/3294300332/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>课程推荐-工具篇</title>
      <link>http://example.com/posts/1556496795/</link>
      <guid>http://example.com/posts/1556496795/</guid>
      <pubDate>Sat, 28 Jan 2023 05:48:26 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;Git&quot;&gt;Git&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;随着这几年 GitHub 的流行，Git 已经是一个程序员逃不过的技术项，但很多人却纷纷倒在了学习它的路上。而且，出于工作原因而不得不用 Git 的人，有不少在工作中对 Git 也是能不用就不用，生怕哪个</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="Git">Git</h2><blockquote><p>随着这几年 GitHub 的流行，Git 已经是一个程序员逃不过的技术项，但很多人却纷纷倒在了学习它的路上。而且，出于工作原因而不得不用 Git 的人，有不少在工作中对 Git 也是能不用就不用，生怕哪个命令用错就把公司的代码库毁掉了🙈。而那些对 Git 掌握得比较好的少数人，就像团队中的神一样，在同事遇到 Git 相关的问题的时候用各种风骚操作来拯救队友于水火。</p></blockquote><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202301281415936.jpg" alt="E1AEE84870D5BE5C2DA57BDF00F1C3D8.jpg"></p><h2 id="Nvim">Nvim</h2><ul><li>适合有一点 VIM 基础的使用者（至少知道怎么编辑文件和退出 VIM 😁）。</li><li>有程序开发基础，有可以访问 Github 的网络环境，想要提升开发效率与开发体验的程序开发人员。</li><li>想要系统学习 Neovim 配置，却被网上零散过时的 VIM 配置教程困扰的同学们。</li></ul><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202301281416032.jpg" alt="01893C4AF74549C45EEC1A4DC4D77019.jpg"></p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/%E6%8E%A8%E8%8D%90/">推荐</category>
      
      <category domain="http://example.com/categories/%E6%8E%A8%E8%8D%90/%E8%AF%BE%E7%A8%8B/">课程</category>
      
      
      
      <comments>http://example.com/posts/1556496795/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>这里有个彩蛋哦</title>
      <link>http://example.com/posts/3396067387/</link>
      <guid>http://example.com/posts/3396067387/</guid>
      <pubDate>Tue, 24 Jan 2023 09:24:40 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;正在建设中……&lt;/p&gt;
</description>
        
      
      
      
      <content:encoded><![CDATA[<p>正在建设中……</p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/%E5%B7%A5%E5%85%B7/">工具</category>
      
      <category domain="http://example.com/categories/%E5%B7%A5%E5%85%B7/%E5%85%B6%E4%BB%96/">其他</category>
      
      
      
      <comments>http://example.com/posts/3396067387/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>如何最快的打造一个帅气好看可以装逼的github主页呢？</title>
      <link>http://example.com/posts/2286645816/</link>
      <guid>http://example.com/posts/2286645816/</guid>
      <pubDate>Sat, 21 Jan 2023 17:24:58 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;strong&gt;先说结论：抄别人好看的主页&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;PS：自己去搞得话，并不一定好弄，而且不如人家的好看，当然我也在后边放了几个小网站，想自己丰富的可以去看看。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;好看主页推</description>
        
      
      
      
      <content:encoded><![CDATA[<p><strong>先说结论：抄别人好看的主页</strong></p><blockquote><p>PS：自己去搞得话，并不一定好弄，而且不如人家的好看，当然我也在后边放了几个小网站，想自己丰富的可以去看看。</p></blockquote><h2 id="好看主页推荐">好看主页推荐</h2><blockquote><p>这边推荐四个主页，后边会说复制主页的方法，github的主页是需要建立一个与github的ID同名的仓库的，然后里面放README.md的文档，这个文档内容就会被展示到主页。</p></blockquote><p><a href="https://github.com/blinkfox">blinkfox (闪烁之狐 (blinkfox)) (github.com)</a></p><p>推荐指数：⭐⭐⭐⭐</p><p>好看指数：⭐⭐</p><p>复制难易：⭐⭐</p><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202301210027622.png" alt=""></p><p><a href="https://github.com/L1cardo">L1cardo (Licardo) (github.com)</a></p><p>推荐指数：⭐⭐⭐⭐⭐</p><p>好看指数：⭐⭐⭐⭐</p><p>复制难易：⭐⭐⭐⭐</p><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202301210034952.png" alt=""></p><p><a href="https://github.com/appotry">appotry (夜法之书(appotry)) (github.com)</a></p><p>推荐指数：⭐⭐</p><p>好看指数：⭐⭐⭐</p><p>复制难易：⭐⭐⭐⭐</p><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202301210041636.png" alt=""></p><p><a href="https://github.com/atongrun">atongrun (孙菜菜) (github.com)</a></p><p>推荐指数：⭐⭐⭐</p><p>好看指数：⭐⭐</p><p>复制难易：⭐⭐</p><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202301210049534.png" alt=""></p><blockquote><p>前三个是大佬的，最后一个是我的，我是抄的大佬的，这里就没必要放太多了，因为大差不差，大家可以自己打开github主页下载文档，当然方便点也可以关注我的公众号【孙菜菜】，回复【帅气主页】，获取源文件。</p></blockquote><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202301210119032.png" alt=""></p><h2 id="如何复制">如何复制</h2><h3 id="步骤1、建立同名仓库">步骤1、建立同名仓库</h3><p>在github上建立一个同名的仓库，这里就不多说，看主页美化的大家应该都会的，然后对README.md文档操作就OK了</p><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202301211357638.png" alt=""></p><h2 id="步骤2、Copy大法">步骤2、Copy大法</h2><blockquote><p>具体步骤如下，记得一定用markdown编辑器弄最好，容易显示出实时的效果，可以按照自己的喜欢酌情删减哦，或者几个文档混合copy</p></blockquote><ul><li>打开四个文件夹的任何一个（你喜欢的）</li><li>将所有内容放到你本地仓库</li><li>打开README.md文档，将里面的github用户名换成自己的</li><li>将各种链接换成自己的</li><li>git add -&gt; git commit -&gt; git push 大功告成</li></ul><blockquote><p>当然，如果大家嫌麻烦怕改链接名错误啥的话，同样关注【孙菜菜】公众号，回复【帅气主页】，获取源文件。里面我还放了个详细的说明，以我的github主页为例子，放到word里面了，将所有需要修改的地方都加上了高亮和注释。</p></blockquote><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202301211354492.png" alt=""></p><blockquote><p>欢迎关注哦。</p></blockquote><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202301211358151.gif" alt=""></p><h2 id="网站推荐">网站推荐</h2><blockquote><p>如果大家非得说不喜欢直接copy别人的，那么你就可以看看下面几个网站了，这下边是我觉得最常见的github主页的几个部件了，如果你要配的比较好看的话，可能还需要懂一点HTML语言哦</p></blockquote><p><a href="https://www.webfx.com/tools/emoji-cheat-sheet/">各种表情</a></p><blockquote><p>在这里有许多 emoji 的符号代码，你可以直接将它们用到 README 中。</p></blockquote><p>实用指数：⭐⭐⭐</p><p><a href="https://github.com/anuraghazra/github-readme-stats/blob/master/docs/readme_cn.md">统计卡片</a></p><blockquote><p>这个就是github主页最常见的小部件了</p></blockquote><p>实用指数：⭐⭐⭐⭐</p><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202301210105140.png" alt=""></p><p><a href="https://shields.io/">丰富标签</a></p><blockquote><p>无论是项目还是github主页出现频率超高的小标签，非常的实用。</p></blockquote><p>实用指数：⭐⭐⭐⭐⭐</p><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202301210106308.png" alt=""></p><p><a href="https://github.com/ryo-ma/github-profile-trophy/blob/master/README.md">各种奖杯</a></p><blockquote><p>这个也是和卡片差不多的统计相关的小部件，出现频率也挺高</p></blockquote><p>实用指数：⭐⭐⭐</p><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202301211413651.png" alt=""></p><h2 id="总结">总结</h2><p>有一个好看的github主页挺好玩主要的可以装逼，希望大家都能搞一个令自己满意的主页。</p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/%E5%B7%A5%E5%85%B7/">工具</category>
      
      <category domain="http://example.com/categories/%E5%B7%A5%E5%85%B7/github/">github</category>
      
      
      
      <comments>http://example.com/posts/2286645816/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>白嫖零花钱</title>
      <link>http://example.com/posts/2137780596/</link>
      <guid>http://example.com/posts/2137780596/</guid>
      <pubDate>Thu, 19 Jan 2023 05:55:58 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;1、微信扫码&quot;&gt;1、微信扫码&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202301191345034.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="1、微信扫码">1、微信扫码</h2><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202301191345034.jpg" alt=""></p><h2 id="2、搜索关键词">2、搜索关键词</h2><p>进去搜索以下关键词，选择价格最高做即可，基本上3分钟左右就Ok了</p><blockquote><p>下面都是我自己做过的。</p><p>主要是时间短、价格高，当然还有很多，大家可以自己找找。</p><p>迫于懒的原因，没找多少，都是想改善一下自己的生活的时候，才做的</p></blockquote><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">名称</th><th style="text-align:center">价格</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">凹音短视频</td><td style="text-align:center">7+</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">云闪付</td><td style="text-align:center">15+</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">小招推客</td><td style="text-align:center">10+</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">快步</td><td style="text-align:center">5+</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">云缴费</td><td style="text-align:center">5+</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">星云视界</td><td style="text-align:center">4+</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">香蕉乐玩</td><td style="text-align:center">12+</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">游易赚</td><td style="text-align:center">10+</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">豆豆趣玩</td><td style="text-align:center">7+</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">辅助注册</td><td style="text-align:center">8+</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">哔哩哔哩</td><td style="text-align:center">5+</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">btd</td><td style="text-align:center">11+</td></tr><tr><td style="text-align:center">13</td><td style="text-align:center">淘宝特价版</td><td style="text-align:center">7+</td></tr><tr><td style="text-align:center">14</td><td style="text-align:center">京东白条</td><td style="text-align:center">20+</td></tr><tr><td style="text-align:center">15</td><td style="text-align:center">冲顶鸭</td><td style="text-align:center">10+</td></tr><tr><td style="text-align:center">16</td><td style="text-align:center">一淘</td><td style="text-align:center">5+</td></tr><tr><td style="text-align:center">17</td><td style="text-align:center">梨漩</td><td style="text-align:center">7+</td></tr><tr><td style="text-align:center">18</td><td style="text-align:center">京东极速版</td><td style="text-align:center">6+</td></tr><tr><td style="text-align:center">19</td><td style="text-align:center">聚跑</td><td style="text-align:center">6+</td></tr><tr><td style="text-align:center">20</td><td style="text-align:center">萌犬世界</td><td style="text-align:center">12+</td></tr><tr><td style="text-align:center">21</td><td style="text-align:center">AITD</td><td style="text-align:center">10+</td></tr><tr><td style="text-align:center">22</td><td style="text-align:center">小蚂蚁</td><td style="text-align:center">7+</td></tr><tr><td style="text-align:center">23</td><td style="text-align:center">陌嗨短视频</td><td style="text-align:center">8+</td></tr><tr><td style="text-align:center">24</td><td style="text-align:center">未完</td><td style="text-align:center">待更新。。。</td></tr></tbody></table><p><strong>Ps：也可以看网页版的，点击阅读原文即可，网页版的更新快一点。只做简单的，勿被标题迷惑，提交截图超过2个的，直接放弃即可，因为太繁琐了</strong></p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/%E6%8E%A8%E8%8D%90/">推荐</category>
      
      <category domain="http://example.com/categories/%E6%8E%A8%E8%8D%90/%E4%B8%9A%E4%BD%99/">业余</category>
      
      
      
      <comments>http://example.com/posts/2137780596/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
