<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>atong的网站</title>
    <link>http://example.com/</link>
    
    <atom:link href="http://example.com/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>万千不如意，睡得着就过的去</description>
    <pubDate>Thu, 08 Dec 2022 11:31:39 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>二叉搜索树</title>
      <link>http://example.com/2022/12/08/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</link>
      <guid>http://example.com/2022/12/08/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</guid>
      <pubDate>Thu, 08 Dec 2022 11:21:32 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;二叉搜索树概念&quot;&gt;&lt;a href=&quot;#二叉搜索树概念&quot; class=&quot;headerlink&quot; title=&quot;二叉搜索树概念&quot;&gt;&lt;/a&gt;二叉搜索树概念&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;二叉搜索树又称二叉排序树，它或者是一棵空树，或者是具有以下性质的二叉树: </description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="二叉搜索树概念"><a href="#二叉搜索树概念" class="headerlink" title="二叉搜索树概念"></a>二叉搜索树概念</h1><blockquote><p>二叉搜索树又称二叉排序树，它或者是一棵空树，或者是具有以下性质的二叉树:  </p><ul><li>若它的左子树不为空，则左子树上所有节点的值都小于根节点的值  </li><li>若它的右子树不为空，则右子树上所有节点的值都大于根节点的值  </li><li>它的左右子树也分别为二叉搜索树</li></ul></blockquote><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202212081211954.png"></p><h1 id="二叉搜索树实现"><a href="#二叉搜索树实现" class="headerlink" title="二叉搜索树实现"></a>二叉搜索树实现</h1><h2 id="结构框架"><a href="#结构框架" class="headerlink" title="结构框架"></a>结构框架</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">K</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BSTreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">BSTreeNode *left;</span><br><span class="line">BSTreeNode *right;</span><br><span class="line">K _key;</span><br><span class="line"><span class="built_in">BSTreeNode</span>(<span class="type">const</span> K &amp;key) : <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>), _key(key)&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">K</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BSTree</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">typedef</span> BSTreeNode&lt;K&gt; Node;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Node *_root = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">    </span><br></pre></td></tr></table></figure><h2 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h2><p>让编译器提供个默认生成的就可以了，如果不写这个，又写了拷贝构造，编译器就不会自己自动生成了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">BSTree</span>() = <span class="keyword">default</span>;</span><br></pre></td></tr></table></figure><h2 id="拷贝构造"><a href="#拷贝构造" class="headerlink" title="拷贝构造"></a>拷贝构造</h2><p>递归拷贝左，右，根</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//拷贝构造</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">BSTree</span>(<span class="type">const</span> BSTree&lt;K&gt; &amp;t)</span><br><span class="line">&#123;</span><br><span class="line">_root = _copy(t._root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Node *_copy(Node *root)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// TODO 拷贝构造 赋值运算符重载</span></span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node *node = <span class="keyword">new</span> <span class="built_in">Node</span>(root-&gt;_key);</span><br><span class="line"></span><br><span class="line">node-&gt;left = _copy(root-&gt;left);</span><br><span class="line">node-&gt;right = _copy(root-&gt;right);</span><br><span class="line"><span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="赋值运算符重载"><a href="#赋值运算符重载" class="headerlink" title="赋值运算符重载"></a>赋值运算符重载</h2><p>写完拷贝构造之后可以直接用现在写法就OK了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BSTree&lt;K&gt; <span class="keyword">operator</span>=(BSTree&lt;K&gt; t)</span><br><span class="line">&#123;</span><br><span class="line">std::<span class="built_in">swap</span>(_root, t._root);</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="析构"><a href="#析构" class="headerlink" title="析构"></a>析构</h2><p>递归，左、右、根</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> _destory(Node *&amp;root)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">_destory(root-&gt;left);</span><br><span class="line">_destory(root-&gt;right);</span><br><span class="line"><span class="keyword">delete</span> root;</span><br><span class="line">root = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>比它大往右走，比他小往左走，走到空，找它父亲链接起来</p><h3 id="非递归代码"><a href="#非递归代码" class="headerlink" title="非递归代码"></a>非递归代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="type">bool</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> K &amp;key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (_root == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">_root = <span class="keyword">new</span> <span class="built_in">Node</span>(key);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">Node *cur = _root;</span><br><span class="line">Node *parent = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">while</span> (cur)</span><br><span class="line">&#123;</span><br><span class="line">parent = cur;</span><br><span class="line"><span class="keyword">if</span> (cur-&gt;_key &gt; key)</span><br><span class="line">&#123;</span><br><span class="line">cur = cur-&gt;left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (cur-&gt;_key &lt; key)</span><br><span class="line">&#123;</span><br><span class="line">cur = cur-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// key==cur-&gt;key</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里cur走到了空 进行插入</span></span><br><span class="line">Node *new_node = <span class="keyword">new</span> <span class="built_in">Node</span>(key);</span><br><span class="line"><span class="keyword">if</span> (parent-&gt;_key &gt; key)</span><br><span class="line">&#123;</span><br><span class="line">parent-&gt;left = new_node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">parent-&gt;right = new_node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="递归代码"><a href="#递归代码" class="headerlink" title="递归代码"></a>递归代码</h3><p>重点是参数列表的引用<br>如果走到了root为空，说明到了该插入的位置，现在的root就是上一层父亲左孩子或者右孩子那个指针的别名</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> _insert_r(Node *&amp;root, <span class="type">const</span> K &amp;key)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">root = <span class="keyword">new</span> <span class="built_in">Node</span>(key);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (root-&gt;_key &gt; key)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _insert_r(root-&gt;left, key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;_key &lt; key)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _insert_r(root-&gt;right, key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>提供一个inorder的接口，调用_inorder()</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_inorder(_root);</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">void</span> _inorder(Node *root)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">_inorder(root-&gt;left);</span><br><span class="line">cout &lt;&lt; root-&gt;_key &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">_inorder(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><h3 id="情况1、左右孩子都为空"><a href="#情况1、左右孩子都为空" class="headerlink" title="情况1、左右孩子都为空"></a>情况1、左右孩子都为空</h3><p>可以记录父亲的值，直接干掉当前节点，判断当前节点是父亲的左还是右，然后用空替代当前节点</p><p>情况1可以归为情况2的特例</p><h3 id="情况2、左右孩子有一个为空"><a href="#情况2、左右孩子有一个为空" class="headerlink" title="情况2、左右孩子有一个为空"></a>情况2、左右孩子有一个为空</h3><h4 id="左孩子为空"><a href="#左孩子为空" class="headerlink" title="左孩子为空"></a>左孩子为空</h4><blockquote><p>删除的是根</p></blockquote><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202212081334295.png"></p><blockquote><p>删除的不是根，依然两种情况，主要看这个要删除的节点是父亲的左还是右</p></blockquote><p>如果是父亲的左，就把cur的右给父亲的左</p><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202212081352923.png"></p><p>如果是父亲的右，就把cur的右给父亲的右<br><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202212081353553.png"></p><h4 id="右孩子为空"><a href="#右孩子为空" class="headerlink" title="右孩子为空"></a>右孩子为空</h4><blockquote><p>先判断特殊情况，删除的节点为根节点</p></blockquote><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202212081333711.png"></p><p>其他情况与左孩子为空情况大概相同</p><ul><li>如果，cur为父亲的左，那么让父亲的左，指向cur的左</li><li>如果，cur为父亲的右，那么让父亲的右，指向cur的右</li></ul><h3 id="情况3、左右孩子都不为空"><a href="#情况3、左右孩子都不为空" class="headerlink" title="情况3、左右孩子都不为空"></a>情况3、左右孩子都不为空</h3><ul><li>找右树的最小节点，也就是右树的最左</li><li>找左树的最大节点 ，也就是左树的最右</li></ul><p>情况1<br><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202212081509463.png"></p><p>情况2</p><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202212081509737.png"></p><h3 id="非递归代码-1"><a href="#非递归代码-1" class="headerlink" title="非递归代码"></a>非递归代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">erase</span><span class="params">(<span class="type">const</span> K &amp;key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (_root == <span class="literal">nullptr</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//先找到要删除的节点，同时记录父节点的位置</span></span><br><span class="line">Node *cur = _root;</span><br><span class="line">Node *parent = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">while</span> (cur)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//存一下cur</span></span><br><span class="line"><span class="keyword">if</span> (cur-&gt;_key &gt; key)</span><br><span class="line">&#123;</span><br><span class="line">parent = cur;</span><br><span class="line"><span class="comment">// key &lt; 当前节点的key， 往节点的左子树找</span></span><br><span class="line">cur = cur-&gt;left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (cur-&gt;_key &lt; key)</span><br><span class="line">&#123;</span><br><span class="line">parent = cur;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前节点的key小于要删除的key， 往右子树找</span></span><br><span class="line">cur = cur-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//这里说明cur-&gt;_key==key 可以进行删除了</span></span><br><span class="line"><span class="comment">//情况有一个孩子或者一个孩子都没有</span></span><br><span class="line"><span class="keyword">if</span> (cur-&gt;left == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// cur左孩子为空 、右孩子可能为空，可能不为空</span></span><br><span class="line"><span class="keyword">if</span> (cur == _root)  <span class="comment">//情况1</span></span><br><span class="line">&#123;</span><br><span class="line">_root = cur-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (parent-&gt;left == cur)</span><br><span class="line">&#123;</span><br><span class="line">parent-&gt;left = cur-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">parent-&gt;right = cur-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> cur;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (cur-&gt;right == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// cur右孩子为空   左孩子可能为空，也可能不为空</span></span><br><span class="line"><span class="keyword">if</span> (cur == _root)</span><br><span class="line">&#123;</span><br><span class="line">_root = cur-&gt;left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (parent-&gt;left == cur)</span><br><span class="line">&#123;</span><br><span class="line">parent-&gt;left = cur-&gt;left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">parent-&gt;right = cur-&gt;left;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> cur;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//左右孩子都不为空</span></span><br><span class="line"><span class="comment">//先找当前节点右树的最小节点</span></span><br><span class="line">Node *parent = cur;</span><br><span class="line">Node *min = cur-&gt;right;</span><br><span class="line"><span class="keyword">while</span> (min-&gt;left)</span><br><span class="line">&#123;</span><br><span class="line">parent = min;</span><br><span class="line">min = min-&gt;left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找到了右树的最左节点</span></span><br><span class="line"><span class="comment">//如果是根节点、比如删除8，那么min现在是10，parent=8</span></span><br><span class="line">std::<span class="built_in">swap</span>(min-&gt;_key, cur-&gt;_key);</span><br><span class="line"><span class="comment">//如果删除3、</span></span><br><span class="line"><span class="keyword">if</span> (parent-&gt;left == min)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// parent的左等于min，比如删除</span></span><br><span class="line">parent-&gt;left = min-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">parent-&gt;right = min-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> min;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//走到这里说明数中没有要删除的节点</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="递归代码-1"><a href="#递归代码-1" class="headerlink" title="递归代码"></a>递归代码</h3><p>过程：</p><ol><li>如果根为空，返回false</li><li>如果当前值大于key，递归删除左</li><li>如果当前值小于key，递归删除右</li><li>如果相等，则进入删除逻辑</li></ol><blockquote><p>分三种情况</p><ul><li>左孩子为空</li><li>右孩子为空</li><li>左右孩子都不为空</li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> _erase_r(Node *&amp;root, <span class="type">const</span> K &amp;key)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (root-&gt;_key &gt; key)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _erase_r(root-&gt;left, key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;_key &lt; key)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _erase_r(root-&gt;right, key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//就是当前节点</span></span><br><span class="line">Node *del = root;</span><br><span class="line"><span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">root = root-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;right == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">root = root-&gt;left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//左右都不为空</span></span><br><span class="line">Node *min = root-&gt;right;</span><br><span class="line"><span class="keyword">while</span> (min)</span><br><span class="line">&#123;</span><br><span class="line">min = min-&gt;left;</span><br><span class="line">&#125;</span><br><span class="line">std::<span class="built_in">swap</span>(min-&gt;_key, root-&gt;_key);</span><br><span class="line"><span class="comment">//注意</span></span><br><span class="line"><span class="keyword">return</span> _erase_r(root-&gt;right, key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> del;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><h3 id="非递归代码-2"><a href="#非递归代码-2" class="headerlink" title="非递归代码"></a>非递归代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">const</span> K&amp; key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Node* cur = _root;</span><br><span class="line"><span class="keyword">while</span> (cur)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (cur-&gt;_key &lt; key)</span><br><span class="line">&#123;</span><br><span class="line">cur = cur-&gt;_right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (cur-&gt;_key &gt; key)</span><br><span class="line">&#123;</span><br><span class="line">cur = cur-&gt;_left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="递归代码-2"><a href="#递归代码-2" class="headerlink" title="递归代码"></a>递归代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> _find_r(Node *root, <span class="type">const</span> K &amp;key)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (root-&gt;_key &gt; key)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _find_r(root-&gt;left, key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;_key &lt; key)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _find_r(root-&gt;right, key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/cpp/">cpp</category>
      
      
      
      <comments>http://example.com/2022/12/08/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
