<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>孙菜菜</title>
    <link>http://example.com/</link>
    
    <atom:link href="http://example.com/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>万千不如意，睡得着就过得去</description>
    <pubDate>Thu, 19 Jan 2023 06:24:10 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>白嫖零花钱</title>
      <link>http://example.com/2023/01/19/%E5%89%AF%E4%B8%9A/%E9%9B%B6%E8%8A%B1%E9%92%B1/</link>
      <guid>http://example.com/2023/01/19/%E5%89%AF%E4%B8%9A/%E9%9B%B6%E8%8A%B1%E9%92%B1/</guid>
      <pubDate>Thu, 19 Jan 2023 05:55:58 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;1、微信扫码&quot;&gt;&lt;a href=&quot;#1、微信扫码&quot; class=&quot;headerlink&quot; title=&quot;1、微信扫码&quot;&gt;&lt;/a&gt;1、微信扫码&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://tong-1306822294.cos.ap-beijing.myqcl</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="1、微信扫码"><a href="#1、微信扫码" class="headerlink" title="1、微信扫码"></a>1、微信扫码</h2><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202301191345034.jpg"></p><h2 id="2、搜索关键词"><a href="#2、搜索关键词" class="headerlink" title="2、搜索关键词"></a>2、搜索关键词</h2><p>进去搜索以下关键词，选择价格最高做即可，基本上3分钟左右就Ok了</p><blockquote><p>下面都是我自己做过的。</p><p>主要是时间短、价格高，当然还有很多，大家可以自己找找。</p><p>迫于懒的原因，没找多少，都是想改善一下自己的生活的时候，才做的</p></blockquote><table><thead><tr><th align="center">序号</th><th align="center">名称</th><th align="center">价格</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">凹音短视频</td><td align="center">7+</td></tr><tr><td align="center">2</td><td align="center">云闪付</td><td align="center">15+</td></tr><tr><td align="center">3</td><td align="center">小招推客</td><td align="center">10+</td></tr><tr><td align="center">4</td><td align="center">快步</td><td align="center">5+</td></tr><tr><td align="center">5</td><td align="center">云缴费</td><td align="center">5+</td></tr><tr><td align="center">6</td><td align="center">星云视界</td><td align="center">4+</td></tr><tr><td align="center">7</td><td align="center">香蕉乐玩</td><td align="center">12+</td></tr><tr><td align="center">8</td><td align="center">游易赚</td><td align="center">10+</td></tr><tr><td align="center">9</td><td align="center">豆豆趣玩</td><td align="center">7+</td></tr><tr><td align="center">10</td><td align="center">辅助注册</td><td align="center">8+</td></tr><tr><td align="center">11</td><td align="center">哔哩哔哩</td><td align="center">5+</td></tr><tr><td align="center">12</td><td align="center">btd</td><td align="center">11+</td></tr><tr><td align="center">13</td><td align="center">淘宝特价版</td><td align="center">7+</td></tr><tr><td align="center">14</td><td align="center">京东白条</td><td align="center">20+</td></tr><tr><td align="center">15</td><td align="center">冲顶鸭</td><td align="center">10+</td></tr><tr><td align="center">16</td><td align="center">一淘</td><td align="center">5+</td></tr><tr><td align="center">17</td><td align="center">梨漩</td><td align="center">7+</td></tr><tr><td align="center">18</td><td align="center">京东极速版</td><td align="center">6+</td></tr><tr><td align="center">19</td><td align="center">聚跑</td><td align="center">6+</td></tr><tr><td align="center">20</td><td align="center">萌犬世界</td><td align="center">12+</td></tr><tr><td align="center">21</td><td align="center">AITD</td><td align="center">10+</td></tr><tr><td align="center">22</td><td align="center">小蚂蚁</td><td align="center">7+</td></tr><tr><td align="center">23</td><td align="center">陌嗨短视频</td><td align="center">8+</td></tr><tr><td align="center">24</td><td align="center">未完</td><td align="center">待更新。。。</td></tr></tbody></table><p><strong>Ps：也可以看网页版的，点击阅读原文即可，网页版的更新快一点。只做简单的，勿被标题迷惑，提交截图超过2个的，直接放弃即可，因为太繁琐了</strong></p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/%E5%89%AF%E4%B8%9A/">副业</category>
      
      
      
      <comments>http://example.com/2023/01/19/%E5%89%AF%E4%B8%9A/%E9%9B%B6%E8%8A%B1%E9%92%B1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>C++的IO流</title>
      <link>http://example.com/2023/01/15/CPP/C++IO%E6%B5%81/</link>
      <guid>http://example.com/2023/01/15/CPP/C++IO%E6%B5%81/</guid>
      <pubDate>Sun, 15 Jan 2023 14:39:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;C-IO体系&quot;&gt;&lt;a href=&quot;#C-IO体系&quot; class=&quot;headerlink&quot; title=&quot;C++IO体系&quot;&gt;&lt;/a&gt;C++IO体系&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;ostream&amp;#x2F;istream 更好的支持自定义类型对象的流插入和流</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="C-IO体系"><a href="#C-IO体系" class="headerlink" title="C++IO体系"></a>C++IO体系</h2><blockquote><p>ostream&#x2F;istream 更好的支持自定义类型对象的流插入和流提取，自定义类型，可以自己重载，控制流提取和流插入的方式</p></blockquote><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202301151704396.png"></p><h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><h3 id="c输入"><a href="#c输入" class="headerlink" title="c输入"></a>c输入</h3><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202301151712088.png"></p><h3 id="c-输入"><a href="#c-输入" class="headerlink" title="c++输入"></a>c++输入</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cin &gt;&gt; str;</span><br><span class="line"></span><br><span class="line">year = <span class="built_in">stoi</span>(str.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">4</span>));</span><br><span class="line">mon = <span class="built_in">stoi</span>(str.<span class="built_in">substr</span>(<span class="number">4</span>, <span class="number">2</span>));</span><br><span class="line">day = <span class="built_in">stoi</span>(str.<span class="built_in">substr</span>(<span class="number">6</span>, <span class="number">2</span>));</span><br></pre></td></tr></table></figure><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202301151724063.png"></p><p>ctrl+z+换行结束输入</p><blockquote><p>为什么可以用上边循环的写法呢？是因为cin的对象可以隐式类型转换成bool（调用operator bool），在流里面读到错误或者结束标志的时候，会返回false</p></blockquote><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202301151732425.png"></p><p>举例详解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>(<span class="type">int</span> a)  <span class="comment">//这里前边加上explict，下边 A aa1 = 1 代码就编不过去了</span></span><br><span class="line">:_a(a)</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="comment">//如果这个前边加explict那么int i = aa1也不行，但是可以强转</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> _a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 内置类型 转换成自定义类型</span></span><br><span class="line">A aa1 = <span class="number">1</span>; <span class="comment">// 隐式类型转换 用1构造A临时对象，再拷贝构造aa1，优化后直接1构造aa1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义类型 转换成内置类型</span></span><br><span class="line"><span class="type">int</span> i = aa1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="文件IO"><a href="#文件IO" class="headerlink" title="文件IO"></a>文件IO</h2><blockquote><p>C++根据文件内容的数据格式分为二进制文件和文本文件</p></blockquote><p>定义一个文件流对象  </p><ul><li>ifstream ifile(只输入用)  </li><li>ofstream ofile(只输出用)  </li><li>fstream iofile(既输入又输出用)</li></ul><p>看一个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">ifstream <span class="title">ifs</span><span class="params">(<span class="string">&quot;test.cpp&quot;</span>)</span></span>;</span><br><span class="line"><span class="type">char</span> ch = ifs.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (ifs)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; ch;</span><br><span class="line">ch = ifs.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>这段程序可以读取当前文件的内容</code></pre><p>C++特有的优点：</p><p>对内置的类型</p><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202301151927497.png"></p><p>对自定义的类型：</p><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202301151934569.png"></p><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202301151935531.png"></p><pre><code>前题是自定义的类型支持流提取，这样对自定义类型的读写通过流的方式就非常的方便了。</code></pre><blockquote><p>两种读写方式对比</p></blockquote><ol><li>二进制读写：在内存如何存储，就如何写到磁盘文件<br> 优点：快<br> 缺点：写出去内容看不见</li><li>文本读写：对象数据序列化字符串写出来，读回来也是字符串，反序列化转成对象数据<br> 优点：可以看见写出去是什么<br> 缺点：存在一个转换过程，要慢一些</li></ol><h3 id="二进制读写"><a href="#二进制读写" class="headerlink" title="二进制读写"></a>二进制读写</h3><blockquote><p>一个关于二进制读取string类型的坑</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ServerInfo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//char _address[32];</span></span><br><span class="line">string _address; <span class="comment">// 换成string 类型</span></span><br><span class="line"><span class="type">int</span> _port;  <span class="comment">// 100</span></span><br><span class="line"></span><br><span class="line">Date _date;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ConfigManager</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">ConfigManager</span>(<span class="type">const</span> <span class="type">char</span>* filename = <span class="string">&quot;server.config&quot;</span>)</span><br><span class="line">:_filename(filename)</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WriteBin</span><span class="params">(<span class="type">const</span> ServerInfo&amp; info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">ofstream <span class="title">ofs</span><span class="params">(_filename, ios_base::out | ios_base::binary)</span></span>;</span><br><span class="line">ofs.<span class="built_in">write</span>((<span class="type">char</span>*)&amp;info, <span class="built_in">sizeof</span>(info));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ReadBin</span><span class="params">(ServerInfo&amp; info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">ifstream <span class="title">ifs</span><span class="params">(_filename, ios_base::in | ios_base::binary)</span></span>;</span><br><span class="line">ifs.<span class="built_in">read</span>((<span class="type">char</span>*)&amp;info, <span class="built_in">sizeof</span>(info));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string _filename; <span class="comment">// 配置文件</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 二进制写出去</span></span><br><span class="line"><span class="comment">//ServerInfo winfo = &#123; &quot;127.0.0.1&quot;, 888 &#125;;</span></span><br><span class="line"><span class="comment">//ServerInfo winfo = &#123; &quot;https://legacy.cplusplus.com/reference/istream/istream/read/&quot;, 888 &#125;;</span></span><br><span class="line"><span class="comment">//ConfigManager cm;</span></span><br><span class="line"><span class="comment">//cm.WriteBin(winfo);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二进制的读</span></span><br><span class="line">ServerInfo rinfo;</span><br><span class="line">ConfigManager cm;</span><br><span class="line">cm.<span class="built_in">ReadBin</span>(rinfo);</span><br><span class="line">cout &lt;&lt; rinfo._address &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; rinfo._port &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>情况1、写入字符较短时</p></blockquote><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202301152109265.png"></p><pre><code>结果虽然读取成功，但是程序出现了问题，退出码不是0</code></pre><blockquote><p>情况2、写入字符串较长时</p></blockquote><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202301152111415.png"></p><pre><code>可以看到address直接读取报错</code></pre><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202301152116889.png"></p><p>原因是当address比较长的时候，string对象，字符串会存在堆里面，ptr指针指向这个字符串，但是写到文件里面的时候，写的不是堆的内存，而是ptr这个地址。</p><p>二进制读写，不大适合有在堆上申请数据类型的</p><h3 id="文本读写"><a href="#文本读写" class="headerlink" title="文本读写"></a>文本读写</h3><p>下边是文本读写的方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*void WriteText(const ServerInfo&amp; info)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">ofstream ofs(_filename, ios_base::out);</span></span><br><span class="line"><span class="comment">ofs.write(info._address.c_str(), info._address.size());</span></span><br><span class="line"><span class="comment">ofs.put(&#x27;\n&#x27;);</span></span><br><span class="line"><span class="comment">const string str = to_string(info._port);</span></span><br><span class="line"><span class="comment">ofs.write(str.c_str(), str.size());</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">void ReadText(ServerInfo&amp; info)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">ifstream ifs(_filename, ios_base::in | ios_base::binary);</span></span><br><span class="line"><span class="comment">char buff[128];</span></span><br><span class="line"><span class="comment">ifs.getline(buff, 128);</span></span><br><span class="line"><span class="comment">info._address = buff;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">ifs.getline(buff, 128);</span></span><br><span class="line"><span class="comment">info._port = stoi(buff);</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WriteText</span><span class="params">(<span class="type">const</span> ServerInfo&amp; info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">ofstream <span class="title">ofs</span><span class="params">(_filename, ios_base::out)</span></span>;</span><br><span class="line">ofs &lt;&lt; info._address &lt;&lt; endl;</span><br><span class="line">ofs &lt;&lt; info._port &lt;&lt; endl;</span><br><span class="line">ofs &lt;&lt; info._date &lt;&lt; endl; <span class="comment">//这里是日期类的对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ReadText</span><span class="params">(ServerInfo&amp; info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">ifstream <span class="title">ifs</span><span class="params">(_filename, ios_base::in | ios_base::binary)</span></span>;</span><br><span class="line">ifs &gt;&gt; info._address &gt;&gt; info._port &gt;&gt; info._date;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="stringstream"><a href="#stringstream" class="headerlink" title="stringstream"></a>stringstream</h2><p>一个例子：</p><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202301152147060.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ChatInfo</span></span><br><span class="line">&#123;</span><br><span class="line">string _name; <span class="comment">// 名字</span></span><br><span class="line"><span class="type">int</span> _id;      <span class="comment">// id</span></span><br><span class="line">Date _date;   <span class="comment">// 时间</span></span><br><span class="line">string _msg;  <span class="comment">// 聊天信息</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 序列化</span></span><br><span class="line">ChatInfo winfo = &#123; <span class="string">&quot;张三&quot;</span>, <span class="number">135246</span>, &#123; <span class="number">2022</span>, <span class="number">4</span>, <span class="number">10</span> &#125;, <span class="string">&quot;晚上一起看电影吧&quot;</span> &#125;;</span><br><span class="line"><span class="comment">//ostringstream oss;</span></span><br><span class="line">stringstream oss;</span><br><span class="line">oss &lt;&lt; winfo._name &lt;&lt; endl;</span><br><span class="line">oss &lt;&lt; winfo._id &lt;&lt; endl;</span><br><span class="line">oss &lt;&lt; winfo._date &lt;&lt; endl;</span><br><span class="line">oss &lt;&lt; winfo._msg &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">string str = oss.<span class="built_in">str</span>();</span><br><span class="line">cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 网络传输str，另一端接收到了字符串串信息数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 反序列化</span></span><br><span class="line">ChatInfo rInfo;</span><br><span class="line"><span class="comment">//istringstream iss(str);</span></span><br><span class="line"><span class="function">stringstream <span class="title">iss</span><span class="params">(str)</span></span>;</span><br><span class="line">iss &gt;&gt; rInfo._name;</span><br><span class="line">iss &gt;&gt; rInfo._id;</span><br><span class="line">iss &gt;&gt; rInfo._date;</span><br><span class="line">iss &gt;&gt; rInfo._msg;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;----------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; rInfo._date &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; rInfo._name &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; rInfo._id &lt;&lt; <span class="string">&quot;]:&gt;&quot;</span> &lt;&lt; rInfo._msg &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;----------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>分割字符串：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">stringstream <span class="title">ss</span><span class="params">(<span class="string">&quot;sad ad fsd&quot;</span>)</span></span>;</span><br><span class="line">string s;</span><br><span class="line"><span class="keyword">while</span> (ss &gt;&gt; s)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/CPP/">CPP</category>
      
      
      
      <comments>http://example.com/2023/01/15/CPP/C++IO%E6%B5%81/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>C++类型转换</title>
      <link>http://example.com/2023/01/15/CPP/c++%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</link>
      <guid>http://example.com/2023/01/15/CPP/c++%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</guid>
      <pubDate>Sun, 15 Jan 2023 08:41:49 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;C语言中的类型转换&quot;&gt;&lt;a href=&quot;#C语言中的类型转换&quot; class=&quot;headerlink&quot; title=&quot;C语言中的类型转换&quot;&gt;&lt;/a&gt;C语言中的类型转换&lt;/h1&gt;&lt;h2 id=&quot;隐式类型转换&quot;&gt;&lt;a href=&quot;#隐式类型转换&quot; class=&quot;head</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="C语言中的类型转换"><a href="#C语言中的类型转换" class="headerlink" title="C语言中的类型转换"></a>C语言中的类型转换</h1><h2 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h2><blockquote><p>隐式类型转换（意义相近的类型）</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 隐式类型转换(意义相近的类型)</span></span><br><span class="line"><span class="type">double</span> d = i;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d, %.2f\n&quot;</span>, i, d);</span><br></pre></td></tr></table></figure><h2 id="显示类型转换"><a href="#显示类型转换" class="headerlink" title="显示类型转换"></a>显示类型转换</h2><blockquote><p>显示的强制类型转换(意义不相近的类型，值转换后有意义)</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span>* p = &amp;a;</span><br><span class="line"></span><br><span class="line"><span class="comment">//int address = p; //这样没法隐式类型转换会报错</span></span><br><span class="line"><span class="type">int</span> address = (<span class="type">int</span>)p; <span class="comment">//强制类型转换没问题</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%x, %d\n&quot;</span>, p, address);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="C-强制类型转换"><a href="#C-强制类型转换" class="headerlink" title="C++强制类型转换"></a>C++强制类型转换</h1><blockquote><p>c++也支持c的类型转换，但是c++为了加强类型转换的可视性，引入了四种命名的强制类型转换操作符</p></blockquote><h2 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h2><blockquote><p>这个就像c中的隐式类型转换，只不过显示的写了出来，static_cast用于非多态类型的转换（静态转换），编译器隐式执行的任何类型转换都可用static_cast，但它不能用于两个不相关的类型进行转换</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">double</span> d = <span class="number">12.34</span>;</span><br><span class="line"><span class="type">int</span> a = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(d);</span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h2><blockquote><p>类似于c的显示强制类型的转换，一般用于将一种类型转换为另一种不同的类型</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>* p = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">int</span>*&gt;(a);  <span class="comment">// 把int 强转为 int*</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h2><blockquote><p>能够删除变量的const属性</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="comment">//int* p = const_cast&lt;int*&gt;(&amp;a);</span></span><br><span class="line"><span class="type">int</span>* p = (<span class="type">int</span>*)&amp;a; <span class="comment">// c的那一套也可以</span></span><br><span class="line">*p = <span class="number">3</span>;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是上边的代码会出现一个问题，就是运行结果显示，a还是2，不过当我们打开监视窗口可以看到a其实已经被改成3了，这是什么原因呢？</p><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202301131530309.png"></p><pre><code>a被const修饰，编译器以为不会被修改，所以加载到寄存器，虽然内存中已经被改了但是寄存器里面的还是2，cout的时候直接去寄存器读，所以打印出来是2</code></pre><p>我们可以在定义a变量的时候加上 volatile关键字，这样编译器处理的时候就会去内存中读取数据，这样，运行结果就变成3 3了。</p><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202301131535214.png"></p><p>注：</p><ol><li>兼容c隐式类型转换和强制类型转换</li><li>期望不要再用了，最好用规范的cpp显示强制类型转换</li><li>static_cast（隐式类型转换）、reinterpret_cast、const_cast（强制类型转换）</li></ol><h2 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h2><blockquote><p> 用于将一个父类对象的指针或者引用转换为子类的指针或者引用（动态转换）</p></blockquote><p><strong>向上转型</strong>：子类对象指针&#x2F;引用-&gt;父类指针&#x2F;引用  （不需要转换，赋值兼容规则）<br><strong>向下转型</strong>：父类对象指针&#x2F;引用-&gt;子类指针&#x2F;引用  （用dynamic_cast转型是安全的）</p><ol><li>dynamic_cast只能用于父类含有虚函数的类</li><li>dynamic_cast会先检查是否能转换成功，能成功则转换，不能则返回0</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> _a = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> _b = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A*指针pa有可能指向父类，有可能指向子类</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(A* pa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 如果pa是指向子类，那么可以转换，转换表达式返回正确的地址</span></span><br><span class="line"><span class="comment">// 如果pa是指向父类，那么不能转换，转换表达式返回nullptr</span></span><br><span class="line">B* pb = <span class="built_in">dynamic_cast</span>&lt;B*&gt;(pa); <span class="comment">// 安全的</span></span><br><span class="line"><span class="comment">//B* pb = (B*)pa;             // 不安全</span></span><br><span class="line"><span class="keyword">if</span> (pb)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;转换成功&quot;</span> &lt;&lt; endl;</span><br><span class="line">pb-&gt;_a++;</span><br><span class="line">pb-&gt;_b++;</span><br><span class="line">cout &lt;&lt; pb-&gt;_a &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; pb-&gt;_b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;转换失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">pa-&gt;_a++;</span><br><span class="line">cout &lt;&lt; pa-&gt;_a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">A aa;</span><br><span class="line"><span class="comment">// 父类对象无论如何都是不允许转换成子类对象的</span></span><br><span class="line"><span class="comment">/*B bb = dynamic_cast&lt;B&gt;(aa);</span></span><br><span class="line"><span class="comment">B bb = (B)aa;*/</span></span><br><span class="line">B bb;</span><br><span class="line"></span><br><span class="line"><span class="built_in">fun</span>(&amp;aa);</span><br><span class="line"><span class="built_in">fun</span>(&amp;bb);</span><br><span class="line"><span class="comment">//fun(nullptr); 转换失败并且报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>细节部分：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> _a1 = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> _a2 = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A1, <span class="keyword">public</span> A2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> _b = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">B bb; <span class="comment">//定义子类对象</span></span><br><span class="line">A1* ptr1 = &amp;bb;</span><br><span class="line">A2* ptr2 = &amp;bb;</span><br><span class="line">cout &lt;&lt; ptr1 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; ptr2 &lt;&lt; endl &lt;&lt; endl;  <span class="comment">//这两个地址是不同的</span></span><br><span class="line"></span><br><span class="line">B* pb1 = (B*)ptr1;</span><br><span class="line">B* pb2 = (B*)ptr2;</span><br><span class="line">cout &lt;&lt; pb1 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; pb2 &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">B* pb3 = <span class="built_in">dynamic_cast</span>&lt;B*&gt;(ptr1);</span><br><span class="line">B* pb4 = <span class="built_in">dynamic_cast</span>&lt;B*&gt;(ptr2);</span><br><span class="line">cout &lt;&lt; pb3 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; pb4 &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202301151637140.png"></p><pre><code>可以看到，强转成子类指针，和dynamic_cast都可以将指针位置偏移到头上</code></pre><p>总结：</p><ul><li>如果有个子类的对象，将地址传给一个函数，函数形参是父类的指针，那么函数内部可以将这个指针重新安全的转成子类的指针。</li><li>普通的父类指针强转成子类可能有风险，如果父类的指针本来指向的对象就是父类的对象，那么将这个指针转换成子类，会有越界的风险。</li></ul><h1 id="RTTI"><a href="#RTTI" class="headerlink" title="RTTI"></a>RTTI</h1><blockquote><p>Run-time Type identification ：运行时类型识别</p></blockquote><p>c++通过以下方式支持RTTI</p><ol><li>typeid运算符   (获取对象类型的字符串)</li><li>dynamic_cast运算符 （识别父类的指针是指向父类对象还是子类对象）</li><li>decltype   （推导一个对象类型，这个类型可以用来定义另一个对象）</li></ol>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/CPP/">CPP</category>
      
      
      
      <comments>http://example.com/2023/01/15/CPP/c++%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>继承</title>
      <link>http://example.com/2023/01/14/CPP/%E7%BB%A7%E6%89%BF/</link>
      <guid>http://example.com/2023/01/14/CPP/%E7%BB%A7%E6%89%BF/</guid>
      <pubDate>Sat, 14 Jan 2023 12:38:23 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;继承的概念及定义&quot;&gt;&lt;a href=&quot;#继承的概念及定义&quot; class=&quot;headerlink&quot; title=&quot;继承的概念及定义&quot;&gt;&lt;/a&gt;继承的概念及定义&lt;/h2&gt;&lt;h3 id=&quot;继承概念&quot;&gt;&lt;a href=&quot;#继承概念&quot; class=&quot;headerlink&quot; </description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="继承的概念及定义"><a href="#继承的概念及定义" class="headerlink" title="继承的概念及定义"></a>继承的概念及定义</h2><h3 id="继承概念"><a href="#继承概念" class="headerlink" title="继承概念"></a>继承概念</h3><p>继承(inheritance)机制是面向对象程序设计使代码可以复用的最重要的手段，它允许程序员在保 持原有类特性的基础上进行扩展，增加功能，这样产生新的类，称派生类。继承呈现了面向对象 程序设计的层次结构，体现了由简单到复杂的认知过程。以前我们接触的复用都是函数复用，继承是类设计层次的复用</p><h3 id="继承定义"><a href="#继承定义" class="headerlink" title="继承定义"></a>继承定义</h3><h4 id="定义格式"><a href="#定义格式" class="headerlink" title="定义格式"></a>定义格式</h4><p><img src="https://cdn.nlark.com/yuque/0/2022/png/29247941/1665842803037-eb12fae7-3e8c-4243-a915-09d684e626bd.png#averageHue=%23fbfbfb&clientId=ucddb3e9e-e17a-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=369&id=ude023e28&margin=%5Bobject%20Object%5D&name=image.png&originHeight=554&originWidth=920&originalType=binary&ratio=1&rotation=0&showTitle=false&size=25512&status=done&style=none&taskId=ue258894c-c700-4c08-af2f-16f2fe31140&title=&width=613.3333333333334" alt="image.png"><br>继承后，父类的成员，包括成员函数和成员变量，都会变成子类的一部分。</p><h4 id="默认继承方式"><a href="#默认继承方式" class="headerlink" title="默认继承方式"></a>默认继承方式</h4><p>在使用继承时，可以不指定继承方式，使用关键字class时默认的继承方式是private，使用struct时，默认的继承方式是public</p><h4 id="继承关系和访问限定符"><a href="#继承关系和访问限定符" class="headerlink" title="继承关系和访问限定符"></a>继承关系和访问限定符</h4><p>访问限定符：</p><ul><li>public</li><li>protected</li><li>private</li></ul><p>继承关系</p><ul><li>public</li><li>protected</li><li>private</li></ul><p>私有成员的意义：不想被子类继承的成员，可以设计成私有<br>基类中想给子类复用，但是又不想暴露直接访问的成员，就应该定义成保护</p><h4 id="继承基类成员访问方式的变化"><a href="#继承基类成员访问方式的变化" class="headerlink" title="继承基类成员访问方式的变化"></a>继承基类成员访问方式的变化</h4><table><thead><tr><th>类成员&#x2F;继承方式</th><th>public继承</th><th>protected继承</th><th>private继承</th></tr></thead><tbody><tr><td>基类的public成员</td><td>派生类的public成员</td><td>派生类的protected成员</td><td>派生类的private成员</td></tr><tr><td>基类的protected成员</td><td>派生类的protected成员</td><td>派生类的protected成员</td><td>派生类的private成员</td></tr><tr><td>基类的private成员</td><td>在派生类不可见</td><td>在派生类不可见</td><td>在派生类不可见</td></tr></tbody></table><p>:::info<br>取成员限定符和继承方式的较小<br>:::</p><blockquote><p>protected&#x2F;private  类外边不能访问 类里面可以访问<br>不可见                         隐身，类里面外面都无法访问</p></blockquote><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>基类private成员在派生类中无论以什么方式继承都是不可见的。这里的不可见是指基类的私<br>有成员还是被继承到了派生类对象中，但是语法上限制派生类对象不管在类里面还是类外面<br>都不能去访问它。</li><li>基类private成员在派生类中是不能被访问，如果基类成员不想在类外直接被访问，但需要在<br>派生类中能访问，就定义为protected。可以看出保护成员限定符是因继承才出现的。</li><li>实际上面的表格我们进行一下总结会发现，基类的私有成员在子类都是不可见。基类的其他<br>成员在子类的访问方式 &#x3D;&#x3D; Min(成员在基类的访问限定符，继承方式)，public &gt; protected&gt;private。</li><li>使用关键字class时默认的继承方式是private，使用struct时默认的继承方式是public，不过<br>最好显示的写出继承方式。</li><li>在实际运用中一般使用都是public继承，几乎很少使用protetced&#x2F;private继承，也不提倡<br>使用protetced&#x2F;private继承，因为protetced&#x2F;private继承下来的成员都只能在派生类的类里<br>面使用，实际中扩展维护性不强</li></ul><h2 id="基和派生类对象赋值转换"><a href="#基和派生类对象赋值转换" class="headerlink" title="基和派生类对象赋值转换"></a>基和派生类对象赋值转换</h2><ul><li>派生类对象 可以赋值给 基类的对象 &#x2F; 基类的指针 &#x2F; 基类的引用。这里有个形象的说法叫切片<br>或者切割。寓意把派生类中父类那部分切来赋值过去。</li><li>基类对象不能赋值给派生类对象。</li><li>基类的指针或者引用可以通过强制类型转换赋值给派生类的指针或者引用。但是必须是基类<br>的指针是指向派生类对象时才是安全的。这里基类如果是多态类型，可以使用RTTI(RunTime Type Information)的dynamic_cast 来进行识别后进行安全转换。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/29247941/1665911527698-30aebb38-ac6a-4bc6-9963-62f385ae1e2d.png#averageHue=%23fdf7eb&clientId=uda2bf642-89db-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=524&id=uedf0ce47&margin=%5Bobject%20Object%5D&name=image.png&originHeight=786&originWidth=554&originalType=binary&ratio=1&rotation=0&showTitle=false&size=43417&status=done&style=none&taskId=u10f1346e-edeb-46c9-ad83-93a2d7d8c24&title=&width=369.3333333333333" alt="image.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">string _name; <span class="comment">// 姓名</span></span><br><span class="line">string _sex;  <span class="comment">// 性别</span></span><br><span class="line"><span class="type">int</span>_age; <span class="comment">// 年龄</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> : <span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> _No; <span class="comment">// 学号</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Student sobj;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.子类对象可以赋值给父类对象/指针/引用</span></span><br><span class="line"><span class="comment">// 这里虽然是不同类型，但是不是隐式类型转换</span></span><br><span class="line"><span class="comment">// 这里算是一个特殊支持，语法天然支持的</span></span><br><span class="line">Person pobj = sobj;</span><br><span class="line">Person* pp = &amp;sobj;</span><br><span class="line">Person&amp; rp = sobj;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span>&amp; d = i;</span><br><span class="line"></span><br><span class="line"><span class="comment">//sobj = (Student)pobj;   //强转成派生类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：基类的对象不能赋值给派生类对象，基类的指针可以通过强制类型转换赋值给派生类的指针，但是此时基类的指针必须是指向派生类的对象才是安全的。</p><h2 id="继承中的作用域"><a href="#继承中的作用域" class="headerlink" title="继承中的作用域"></a>继承中的作用域</h2><ul><li>在继承体系中，基类和派生类都有独立的作用域</li><li>子类和父类中有同名成员，子类成员将屏蔽父类对同名成员的直接访问，这种情况叫隐藏，也叫重定义。（在子类成员函数中，可以使用 基类::基类成员 显示访问）</li><li>注意在实际中在继承体系里最好不要定义同名的成员</li><li>需要注意的是如果是成员函数的隐藏，只需要函数名相同就构成隐藏</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string _name; <span class="comment">// 姓名</span></span><br><span class="line"><span class="type">int</span> _num;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;parent&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> : <span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> _num;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;child&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Student s;</span><br><span class="line">s._num = <span class="number">1</span>;</span><br><span class="line">cout &lt;&lt; s._num &lt;&lt; endl;</span><br><span class="line">s.Person::_num = <span class="number">2</span>;</span><br><span class="line">cout &lt;&lt; s.Person::_num &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">s.<span class="built_in">fun</span>();</span><br><span class="line">s.Person::<span class="built_in">fun</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="派生类的默认成员函数"><a href="#派生类的默认成员函数" class="headerlink" title="派生类的默认成员函数"></a>派生类的默认成员函数</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/29247941/1665924224019-25167b1f-d0d9-41fb-8a1e-3036a3938fc3.png#averageHue=%23d6e81f&clientId=u9a15f95a-cdec-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=170&id=ue92dcd90&margin=%5Bobject%20Object%5D&name=image.png&originHeight=255&originWidth=913&originalType=binary&ratio=1&rotation=0&showTitle=false&size=69980&status=done&style=none&taskId=u3248b978-23c3-41d1-b69d-a99b288c1ca&title=&width=608.6666666666666" alt="image.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//Person(const char* name = &quot;peter&quot;)</span></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">const</span> <span class="type">char</span>* name)</span><br><span class="line">: _name(name)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p)</span><br><span class="line">: _name(p._name)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person(const Person&amp; p)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Person&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person operator=(const Person&amp; p)&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> != &amp;p)</span><br><span class="line">_name = p._name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Person</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;~Person()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">string _name; <span class="comment">// 姓名</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> : <span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Student</span>(<span class="type">const</span> <span class="type">char</span>* name, <span class="type">int</span> num)</span><br><span class="line">:<span class="built_in">Person</span>(name)   <span class="comment">//父类没有默认构造，初始化列表规定这么写，就像匿名对象那样</span></span><br><span class="line">, _num(num)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Student()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Student</span>(<span class="type">const</span> Student&amp; s)</span><br><span class="line">:<span class="built_in">Person</span>(s) <span class="comment">//切片  </span></span><br><span class="line">, _num(s._num)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Student(const Student&amp; s)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Student&amp; s)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> != &amp;s)</span><br><span class="line">&#123;</span><br><span class="line">Person::<span class="keyword">operator</span>=(s);</span><br><span class="line"></span><br><span class="line">_num = s._num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Student&amp; operator=(const Student&amp; s)&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类的析构的函数跟父类析构函数构成隐藏。</span></span><br><span class="line"><span class="comment">// 由于后面多态的需要，析构函数名字会统一处理成destructor()</span></span><br><span class="line">~<span class="built_in">Student</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 不需要显示调用父类析构函数</span></span><br><span class="line"><span class="comment">// 每个子类析构函数后面，会自动调用父类析构函数，这样才能保证先析构子类，再析构父类</span></span><br><span class="line"><span class="comment">//Person::~Person();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...处理子类自己的</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;~Student()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Student* operator&amp;()</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//return this;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> _num;</span><br><span class="line"></span><br><span class="line"><span class="comment">// int* _ptr;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Student <span class="title">s1</span><span class="params">(<span class="string">&quot;张三&quot;</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Student s2(s1);</span></span><br><span class="line">Student s2 = s1;</span><br><span class="line"></span><br><span class="line"><span class="function">Student <span class="title">s3</span><span class="params">(<span class="string">&quot;李四&quot;</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">s1 = s3;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &amp;s1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2022/png/29247941/1665923523186-23fc5042-b349-4418-abc2-3f816c892f7f.png#averageHue=%23272625&clientId=u9a15f95a-cdec-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=277&id=ua98444aa&margin=%5Bobject%20Object%5D&name=image.png&originHeight=415&originWidth=633&originalType=binary&ratio=1&rotation=0&showTitle=false&size=31156&status=done&style=none&taskId=ucc19a40c-5c37-435c-b800-e4ef171ef8d&title=&width=422" alt="image.png"></p><blockquote><p>构造时，先调用父类的构造，再调用子类的，析构时先析构子，再析构父类</p></blockquote><h3 id="子类默认生成的构造函数"><a href="#子类默认生成的构造函数" class="headerlink" title="子类默认生成的构造函数"></a>子类默认生成的构造函数</h3><ul><li>自己的成员，跟类和对象一样，内置类型不处理，自定义类型调用他的默认构造</li><li>继承父类成员必须调用父类构造函数初始化</li></ul><h3 id="编译器默认生成的析构函数"><a href="#编译器默认生成的析构函数" class="headerlink" title="编译器默认生成的析构函数"></a>编译器默认生成的析构函数</h3><ul><li>自己的成员， 内置类型不处理，自定义类型调用它的析构</li><li>继承的成员，调用父类析构函数处理</li></ul><hr><h3 id="编译生成的默认拷贝构造"><a href="#编译生成的默认拷贝构造" class="headerlink" title="编译生成的默认拷贝构造"></a>编译生成的默认拷贝构造</h3><ul><li>自己成员，跟类和对象一样（内置类型，值拷贝，自定义类型调用它的拷贝构造）</li><li>继承的父类成员，必须调用父类拷贝构造初始化</li></ul><h3 id="编译器默认生成的operator-x3D"><a href="#编译器默认生成的operator-x3D" class="headerlink" title="编译器默认生成的operator&#x3D;"></a>编译器默认生成的operator&#x3D;</h3><p>同上</p><hr><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul><li>派生类的构造函数调用时，会自动调用基类的构造函数初始化基类的一部分成员，如果基类中没有默认构造函数则必须在派生类构造函数的初始化列表中显示调用基类的构造函数</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/29247941/1665924438484-50f4e250-c115-464a-ab08-7aa2536ecf3e.png#averageHue=%23fdfaf9&clientId=u9a15f95a-cdec-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=161&id=sgyNG&margin=%5Bobject%20Object%5D&name=image.png&originHeight=241&originWidth=650&originalType=binary&ratio=1&rotation=0&showTitle=false&size=25919&status=done&style=none&taskId=uac21a5c0-4078-4e18-90a7-bc711541814&title=&width=433.3333333333333" alt="image.png"></p><ul><li>派生类的拷贝构造函数必须调用基类的构造函数完成基类成员的拷贝构造</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/29247941/1665924541930-3bcafcf9-c9a3-4fb7-9d91-74cea67322fd.png#averageHue=%23fdfbfa&clientId=u9a15f95a-cdec-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=185&id=ud658102a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=277&originWidth=850&originalType=binary&ratio=1&rotation=0&showTitle=false&size=31291&status=done&style=none&taskId=u2622b831-0296-418f-81e4-0668e6475a3&title=&width=566.6666666666666" alt="image.png"></p><ul><li>派生类的赋值运算符重载函数必须调用基类的赋值运算符重载函数完成基类成员的赋值</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/29247941/1665924642477-58801ec0-cd39-4c14-800d-68029738993d.png#averageHue=%23fefcfc&clientId=u9a15f95a-cdec-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=349&id=ubd1d7b31&margin=%5Bobject%20Object%5D&name=image.png&originHeight=524&originWidth=1076&originalType=binary&ratio=1&rotation=0&showTitle=false&size=52453&status=done&style=none&taskId=u1e8b2984-42cd-4bfe-ab36-30167408283&title=&width=717.3333333333334" alt="image.png"></p><ul><li>派生类的析构函数会会在被调用完成后自动调用基类的析构函数清理基类成员</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/29247941/1665924714654-705f1273-b934-4799-a0fc-b63b87e4d831.png#averageHue=%23fefdfd&clientId=u9a15f95a-cdec-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=243&id=u278f7ef6&margin=%5Bobject%20Object%5D&name=image.png&originHeight=364&originWidth=1434&originalType=binary&ratio=1&rotation=0&showTitle=false&size=76014&status=done&style=none&taskId=ua2ce9e09-5343-4181-86f3-e761020ab72&title=&width=956" alt="image.png"></p><ul><li>派生对象初始化时，会先调用基类的构造函数，再调用派生类的构造函数</li></ul><blockquote><p>另外几点注意</p></blockquote><ol><li>派生类和基类的赋值运算符重载函数因为函数名相同构造隐藏，因此在派生类当中，调用基类的赋值运算符重载函数时，需要使用作用域限定符指定调用</li><li>由于多态的某些原因，任何类的析构函数名都被统一处理为destructor()，因此，派生类和基类的析构函数就会因为函数名相同构成隐藏，如若我们需要在某处显示调用基类的析构函数，那么就要使用作用域限定符指定调用</li><li>在派生类的拷贝构造函数和operator&#x3D;当中调用基类的拷贝构造函数，传参方式都是切片行为，都是将派生类对象直接赋值给基类的引用</li><li>基类的构造、拷贝构造、赋值我们都可以在派生类中自行调用，但是基类析构是当派生类析构函数调用后由编译器自动调用的，如果我们显示调用基类析构函数，会导致基类被析构多次</li><li>创建派生类对象时是先创建基类成员再创建派生类成员，编译器为了保证先定义的后析构，所以自动调用基类的析构函数</li></ol><h2 id="继承与友元"><a href="#继承与友元" class="headerlink" title="继承与友元"></a>继承与友元</h2><p>友元关系不能继承，基类的友元函数，不能访问派生类的私有和保护</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">Display</span><span class="params">(<span class="type">const</span> Person&amp; p, <span class="type">const</span> Student&amp; s)</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">string _name; <span class="comment">// 姓名</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> : <span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">Display</span><span class="params">(<span class="type">const</span> Person&amp; p, <span class="type">const</span> Student&amp; s)</span></span>; <span class="comment">//这里不加会报错</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> _stuNum; <span class="comment">// 学号</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Display</span><span class="params">(<span class="type">const</span> Person&amp; p, <span class="type">const</span> Student&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; p._name &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; s._stuNum &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person p;</span><br><span class="line">Student s;</span><br><span class="line"><span class="built_in">Display</span>(p, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="继承与静态成员"><a href="#继承与静态成员" class="headerlink" title="继承与静态成员"></a>继承与静态成员</h2><p>若基类中定义了一个static静态成员变量，那么在整个继承体系中只有一个该静态成员，无论派生出多少个子类，都只有一个static成员实例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>() &#123; ++_count; &#125;</span><br><span class="line"><span class="comment">//protected:</span></span><br><span class="line">string _name; <span class="comment">// 姓名</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> _count; <span class="comment">// 统计人的个数。</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Person::_count = <span class="number">0</span>;   <span class="comment">//静态成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> : <span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> _stuNum; <span class="comment">// 学号</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person p;</span><br><span class="line">Student s;</span><br><span class="line"></span><br><span class="line">p._name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">cout &lt;&lt; s._name &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; Student::_count &lt;&lt; endl;</span><br><span class="line">++Person::_count;</span><br><span class="line">cout &lt;&lt; Student::_count &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &amp;Person::_count &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &amp;Student::_count &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码说明：</p><ul><li>子类 count++  父类 也会++</li><li>两个count 地址相同</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/29247941/1665926120982-afd1f668-5895-4c23-b042-5891253899d1.png#averageHue=%23434140&clientId=u9a15f95a-cdec-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=117&id=u275c88b4&margin=%5Bobject%20Object%5D&name=image.png&originHeight=176&originWidth=350&originalType=binary&ratio=1&rotation=0&showTitle=false&size=7607&status=done&style=none&taskId=u0b735a34-b8a5-4c78-9dc3-bae9a28d15b&title=&width=233.33333333333334" alt="image.png"></p><h2 id="复杂的菱形继承及菱形虚拟继承"><a href="#复杂的菱形继承及菱形虚拟继承" class="headerlink" title="复杂的菱形继承及菱形虚拟继承"></a>复杂的菱形继承及菱形虚拟继承</h2><h3 id="如何定义一个不能被继承的类"><a href="#如何定义一个不能被继承的类" class="headerlink" title="如何定义一个不能被继承的类"></a>如何定义一个不能被继承的类</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">final</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">A</span>()</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> _a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// C++98</span></span><br><span class="line"><span class="comment">// 1、父类构造函数私有-- 子类是不可见</span></span><br><span class="line"><span class="comment">// 2、子类对象实例化，无法调用构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// C++11</span></span><br><span class="line"><span class="comment">// final</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//B bb;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2022/png/29247941/1665926275604-95484c9a-7dfe-4e5a-ac44-6069a199abba.png#averageHue=%236babdf&clientId=u9a15f95a-cdec-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=49&id=ue4cf0d64&margin=%5Bobject%20Object%5D&name=image.png&originHeight=74&originWidth=1462&originalType=binary&ratio=1&rotation=0&showTitle=false&size=14903&status=done&style=none&taskId=ubf9c4de1-9e31-4ece-aefc-d9ce21309b6&title=&width=974.6666666666666" alt="image.png"></p><h3 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h3><blockquote><p>单继承：一个子类只有一个直接父类</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2022/png/29247941/1665926407861-410505cc-54ef-4f2c-b258-fa75dcae5bbf.png#averageHue=%23f6f6f6&clientId=u9a15f95a-cdec-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=440&id=u3930072f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=660&originWidth=1050&originalType=binary&ratio=1&rotation=0&showTitle=false&size=4930&status=done&style=none&taskId=u22cdf83d-7d24-445d-b7a4-60c1bb39e82&title=&width=700" alt="image.png"></p><blockquote><p>多继承：一个子类有两个或两个以上直接父类</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2022/png/29247941/1665926491715-d1faab7e-ac2e-462b-9b8a-bcb641e79382.png#averageHue=%23f7f7f7&clientId=u9a15f95a-cdec-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=341&id=u186177c4&margin=%5Bobject%20Object%5D&name=image.png&originHeight=511&originWidth=974&originalType=binary&ratio=1&rotation=0&showTitle=false&size=4295&status=done&style=none&taskId=uddca721d-77c1-467c-9cec-0ca4dc91358&title=&width=649.3333333333334" alt="image.png"></p><blockquote><p>菱形继承：多继承的一种特殊情况</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2022/png/29247941/1665926639901-30398b6a-75ad-4a1c-a4e4-6acbe0258f5e.png#averageHue=%23f8f8f8&clientId=u9a15f95a-cdec-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=527&id=uc7e73fba&margin=%5Bobject%20Object%5D&name=image.png&originHeight=791&originWidth=955&originalType=binary&ratio=1&rotation=0&showTitle=false&size=6898&status=done&style=none&taskId=ue910af18-9434-4c87-b8e7-42cbf793754&title=&width=636.6666666666666" alt="image.png"><br>菱形继承的方式存在数据冗余和二义性的问题</p><h3 id="一个题"><a href="#一个题" class="headerlink" title="一个题"></a>一个题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span> &#123; <span class="keyword">public</span>:  <span class="type">int</span> _b1; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span> &#123; <span class="keyword">public</span>:  <span class="type">int</span> _b2; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive</span> : <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2 &#123; <span class="keyword">public</span>: <span class="type">int</span> _d; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Derive d;</span><br><span class="line">Base1* p1 = &amp;d;</span><br><span class="line">Base2* p2 = &amp;d;</span><br><span class="line">Derive* p3 = &amp;d;</span><br><span class="line"></span><br><span class="line">d._b1 = <span class="number">1</span>;</span><br><span class="line">d._b2 = <span class="number">2</span>;</span><br><span class="line">d._d = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; p1 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; p2 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; p3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>P1 P2 P3的关系： “先使用了低地址”<br>p1&#x3D;&#x3D;p3&lt;p2</p><p><strong>解释：</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/29247941/1665927761574-109c0daa-a64d-4ec2-bbe9-45e38bb19a86.png#averageHue=%23f6f6f6&clientId=u9a15f95a-cdec-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=213&id=u4533b4cf&margin=%5Bobject%20Object%5D&name=image.png&originHeight=319&originWidth=1360&originalType=binary&ratio=1&rotation=0&showTitle=false&size=13067&status=done&style=none&taskId=u4141fed7-a89e-4356-a6ed-b01929f0ef3&title=&width=906.6666666666666" alt="image.png"><br><strong>该类对象模型：</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/29247941/1665927183117-40ca8bae-cd49-4b91-996f-06263871b07a.png#averageHue=%23fefefe&clientId=u9a15f95a-cdec-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=500&id=u3aa93300&margin=%5Bobject%20Object%5D&name=image.png&originHeight=750&originWidth=822&originalType=binary&ratio=1&rotation=0&showTitle=false&size=15161&status=done&style=none&taskId=u545af6a6-487d-4e0d-8c91-d2cb5c94944&title=&width=548" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/29247941/1665927302508-4e02ebc3-cecc-410a-9e73-a5addf5a7c05.png#averageHue=%23f0c782&clientId=u9a15f95a-cdec-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=147&id=u927f6c7f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=220&originWidth=492&originalType=binary&ratio=1&rotation=0&showTitle=false&size=13295&status=done&style=none&taskId=ua3c395ac-74f6-4cbc-91c0-47180a97f08&title=&width=328" alt="image.png"></p><p>&amp;d 看到内存信息，01地址最低，也就是_b1的地址最低，base1是先继承的，所以地址最低，我们传统的想法是栈是向下增长，先使用高地址再使用低地址，但是在这个对象里成员就像倒着存一样</p><h3 id="菱形继承的问题"><a href="#菱形继承的问题" class="headerlink" title="菱形继承的问题"></a>菱形继承的问题</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string _name; <span class="comment">// 姓名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// int _age;</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> : <span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> _num; <span class="comment">//学号</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span> : <span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> _id; <span class="comment">// 职工编号</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Assistant</span> : <span class="keyword">public</span> Student, <span class="keyword">public</span> Teacher</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">string _majorCourse; <span class="comment">// 主修课程</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Assistant at;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 菱形继承的二义性问题</span></span><br><span class="line"><span class="comment">// 数据冗余</span></span><br><span class="line"><span class="comment">//at._name = &quot;张三&quot;;</span></span><br><span class="line">at.Student::_name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">at.Teacher::_name = <span class="string">&quot;李四&quot;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二义性可以通过指定类域解决，但是数据冗余的问题还是无法解决，Assistant这个类中有两份的_name.<br><img src="https://cdn.nlark.com/yuque/0/2022/png/29247941/1665928284321-c1616231-08cd-4c01-9c15-460c7727b0ce.png#averageHue=%23f9f8f6&clientId=u9a15f95a-cdec-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=193&id=u4fe948a1&margin=%5Bobject%20Object%5D&name=image.png&originHeight=290&originWidth=869&originalType=binary&ratio=1&rotation=0&showTitle=false&size=26788&status=done&style=none&taskId=u42b53a14-4f5b-4850-8c9c-3001e700fd0&title=&width=579.3333333333334" alt="image.png"></p><blockquote><p>这时候需要用菱形虚拟继承，用法就是在继承方式前边加一个virtual，在菱形继承的腰部加virtual</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string _name; <span class="comment">// 姓名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// int _age;</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> _num; <span class="comment">//学号</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> _id; <span class="comment">// 职工编号</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Assistant</span> : <span class="keyword">public</span> Student, <span class="keyword">public</span> Teacher</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">string _majorCourse; <span class="comment">// 主修课程</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Assistant at;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 菱形虚拟继承解决了二义性和数据冗余</span></span><br><span class="line">at._name = <span class="string">&quot;小张&quot;</span>;</span><br><span class="line">at.Student::_name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">at.Teacher::_name = <span class="string">&quot;李四&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2022/png/29247941/1665928541044-58906662-6534-4929-a125-f71ed144504f.png#averageHue=%23fcfaf9&clientId=u9a15f95a-cdec-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=451&id=u505afb34&margin=%5Bobject%20Object%5D&name=image.png&originHeight=677&originWidth=2084&originalType=binary&ratio=1&rotation=0&showTitle=false&size=166970&status=done&style=none&taskId=u0a404cfc-23d6-4b61-a3ee-974587803bc&title=&width=1389.3333333333333" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/29247941/1665928728293-6786235e-8f54-4ebf-b745-42eee72ca4f8.png#averageHue=%23fcfaf8&clientId=u9a15f95a-cdec-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=369&id=u06883c63&margin=%5Bobject%20Object%5D&name=image.png&originHeight=553&originWidth=2083&originalType=binary&ratio=1&rotation=0&showTitle=false&size=142280&status=done&style=none&taskId=u9d3c0d5f-83fd-45c0-aff8-ab9ca53cf71&title=&width=1388.6666666666667" alt="image.png"></p><p>这里解决了数据冗余的问题，因为_name都是一个</p><h3 id="虚拟继承的对象模型"><a href="#虚拟继承的对象模型" class="headerlink" title="虚拟继承的对象模型"></a>虚拟继承的对象模型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> _a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//class B : public A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> _b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//class C : public A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> _c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> C</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> _d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">D d;</span><br><span class="line">d.B::_a = <span class="number">1</span>;</span><br><span class="line">d.C::_a = <span class="number">2</span>;</span><br><span class="line">d._a = <span class="number">0</span>;</span><br><span class="line">d._b = <span class="number">3</span>;</span><br><span class="line">d._c = <span class="number">4</span>;</span><br><span class="line">d._d = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">B b = d;</span><br><span class="line">B* pb = &amp;d;</span><br><span class="line"></span><br><span class="line">C c = d;</span><br><span class="line">C* pc = &amp;d;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>有虚拟继承</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/29247941/1665929216002-77d2109f-1280-486a-96e7-f30915b7517d.png#averageHue=%23e1be87&clientId=u9a15f95a-cdec-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=737&id=ua5ea4805&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1105&originWidth=2077&originalType=binary&ratio=1&rotation=0&showTitle=false&size=258149&status=done&style=none&taskId=ud8ef7aeb-9160-48cc-be1e-0e2c6c56464&title=&width=1384.6666666666667" alt="image.png"><br>我们来看内存的具体信息<br><img src="https://cdn.nlark.com/yuque/0/2022/png/29247941/1665930343351-8fa3f176-7e43-4803-87a5-f421bc79d7e9.png#averageHue=%23fcfaf7&clientId=u9a15f95a-cdec-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=467&id=uae4d76fa&margin=%5Bobject%20Object%5D&name=image.png&originHeight=700&originWidth=1957&originalType=binary&ratio=1&rotation=0&showTitle=false&size=97769&status=done&style=none&taskId=u0761c169-fa35-4371-b9f6-72127f42028&title=&width=1304.6666666666667" alt="image.png"></p><p>虚拟继承后类对象模型变成了如下<br><img src="https://cdn.nlark.com/yuque/0/2022/png/29247941/1665930553735-f608a98b-8117-440e-aa4b-242da677bd08.png#averageHue=%23fefdfd&clientId=u9a15f95a-cdec-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=507&id=u8e90a8c2&margin=%5Bobject%20Object%5D&name=image.png&originHeight=761&originWidth=903&originalType=binary&ratio=1&rotation=0&showTitle=false&size=10332&status=done&style=none&taskId=ub30041f5-98e6-4109-9076-6fc6db9a7db&title=&width=602" alt="image.png"><br>对象里面有了两个指针，叫做虚基表指针，他们分别指向一个虚基表，虚基表中包含两个数据，第一个是为多态的虚表预留的存偏移量的位置，第二个数据就是当前类对象位置距离公共虚基类的偏移量</p><p><strong>如果没有虚拟继承</strong><br><img src="https://cdn.nlark.com/yuque/0/2022/png/29247941/1665930786365-d351fcb7-1648-4c4b-b52c-7baf6d006387.png#averageHue=%23fcfcfb&clientId=u9a15f95a-cdec-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=274&id=u82e87a07&margin=%5Bobject%20Object%5D&name=image.png&originHeight=411&originWidth=1246&originalType=binary&ratio=1&rotation=0&showTitle=false&size=35325&status=done&style=none&taskId=ue79b9a48-1be0-434b-a73c-d38be29be6b&title=&width=830.6666666666666" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/29247941/1665930848594-a73182f0-67fa-44d2-bbd0-67e7249ae9c0.png#averageHue=%23fefdfd&clientId=u9a15f95a-cdec-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=485&id=ud37b8164&margin=%5Bobject%20Object%5D&name=image.png&originHeight=727&originWidth=723&originalType=binary&ratio=1&rotation=0&showTitle=false&size=9686&status=done&style=none&taskId=u67aee36b-3cdf-4e57-8ff9-f334d68402e&title=&width=482" alt="image.png"><br>这里有个问题，好像使用虚拟继承和不用虚拟继承空间是消耗了相同的，但是，如果A的_a是个大对象，就会省空间。<br>注：如果，将D类对象，赋值给B类对象，在这个切片过程中，就需要通过虚基表中的第二个数据找到公共虚基类A的成员，得到切片后，该B类对象在内存中仍然保持这种分布。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/29247941/1665931305427-e4136cd3-ae7a-44c6-bc95-c2608d9ad85f.png#averageHue=%23fdfdfd&clientId=u9a15f95a-cdec-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=218&id=u6318824f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=327&originWidth=439&originalType=binary&ratio=1&rotation=0&showTitle=false&size=17436&status=done&style=none&taskId=u29ac3bc0-c7a4-46c6-b52d-d4374cf633b&title=&width=292.6666666666667" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/29247941/1665931293362-77525e34-b172-4107-8d56-fcc8b432e9cb.png#averageHue=%23f3e8d8&clientId=u9a15f95a-cdec-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=128&id=u93c161c3&margin=%5Bobject%20Object%5D&name=image.png&originHeight=192&originWidth=372&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11212&status=done&style=none&taskId=u55bee722-0a8f-4764-9058-9478555dc00&title=&width=248" alt="image.png"></p><h2 id="继承的总结和反思"><a href="#继承的总结和反思" class="headerlink" title="继承的总结和反思"></a>继承的总结和反思</h2><p>所以一般不建议设计出多继承，一定不要设计出菱形继承。否则在复杂度及性能上都有问题。多继承可以认为是C++的缺陷之一，很多后来的OO语言都没有多继承，如Java。</p><h3 id="继承和组合"><a href="#继承和组合" class="headerlink" title="继承和组合"></a>继承和组合</h3><ul><li>public继承是一种is-a的关系。也就是说每个派生类对象都是一个基类对象。</li><li>组合是一种has-a的关系。假设B组合了A，每个B对象中都有一个A对象。</li></ul><p>继承允许你根据基类的实现来定义派生类的实现。这种通过生成派生类的复用通常被称<br>为白箱复用(white-box reuse)。术语“白箱”是相对可视性而言：在继承方式中，基类的<br>内部细节对子类可见 。继承一定程度破坏了基类的封装，基类的改变，对派生类有很<br>大的影响。派生类和基类间的依赖关系很强，耦合度高。</p><p>对象组合是类继承之外的另一种复用选择。新的更复杂的功能可以通过组装或组合对象<br>来获得。对象组合要求被组合的对象具有良好定义的接口。这种复用风格被称为黑箱复<br>用(black-box reuse)，因为对象的内部细节是不可见的。对象只以“黑箱”的形式出现。<br>组合类之间没有很强的依赖关系，耦合度低。优先使用对象组合有助于你保持每个类被<br>封装。</p><p>实际尽量多去用组合。组合的耦合度低，代码维护性好。不过继承也有用武之地的，有<br>些关系就适合继承那就用继承，另外要实现多态，也必须要继承。类之间的关系可以用<br>继承，可以用组合，就用组合</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/29247941/1665932203320-44346fb6-7516-4f7c-98c6-c400b8a66dff.png#averageHue=%23fcfcfc&clientId=uf24a1cd6-4779-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=368&id=ub1ac8a38&margin=%5Bobject%20Object%5D&name=image.png&originHeight=552&originWidth=1114&originalType=binary&ratio=1&rotation=0&showTitle=false&size=47650&status=done&style=none&taskId=ua8df4665-72a3-45e4-a680-44f1d967f22&title=&width=742.6666666666666" alt="image.png"></p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/CPP/">CPP</category>
      
      
      
      <comments>http://example.com/2023/01/14/CPP/%E7%BB%A7%E6%89%BF/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>markdown语法</title>
      <link>http://example.com/2023/01/14/%E5%B7%A5%E5%85%B7/markdown/markdown%E8%AF%AD%E6%B3%95/</link>
      <guid>http://example.com/2023/01/14/%E5%B7%A5%E5%85%B7/markdown/markdown%E8%AF%AD%E6%B3%95/</guid>
      <pubDate>Sat, 14 Jan 2023 06:15:28 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;字体&quot;&gt;&lt;a href=&quot;#字体&quot; class=&quot;headerlink&quot; title=&quot;字体&quot;&gt;&lt;/a&gt;字体&lt;/h1&gt;&lt;h2 id=&quot;斜体&quot;&gt;&lt;a href=&quot;#斜体&quot; class=&quot;headerlink&quot; title=&quot;斜体&quot;&gt;&lt;/a&gt;斜体&lt;/h2&gt;&lt;block</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h1><h2 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h2><blockquote><p>两个下划线，或者两个星号</p></blockquote><p><em>斜体</em><br><em>斜体</em></p><h2 id="粗体"><a href="#粗体" class="headerlink" title="粗体"></a>粗体</h2><blockquote><p>两个下划线或者两个星号</p></blockquote><p><strong>粗体</strong><br><strong>粗体</strong></p><h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><blockquote><p>三个星号，或者三个下划线，粗斜体</p></blockquote><p><em><strong>粗斜体</strong></em></p><h2 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h2><blockquote><p>前后两个~~</p></blockquote><p><del>删除线</del></p><h2 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h2><blockquote><p><u> </u></p></blockquote><p><u> 下划线</u></p><h1 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h1><blockquote><p>一个&gt;两个&gt;&gt;三个&gt;&gt;&gt;</p></blockquote><blockquote><p>1</p><blockquote><p>2</p><blockquote><p>3</p></blockquote></blockquote></blockquote><h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><blockquote><p>加 : 可以实现左对齐，右对齐，居中，不加默认左对齐 </p></blockquote><table><thead><tr><th align="left">表头</th><th align="left">表头</th><th align="left">表头</th></tr></thead><tbody><tr><td align="left">单元格</td><td align="left">单元格</td><td align="left">单元格</td></tr><tr><td align="left">单元格</td><td align="left">单元格</td><td align="left">单元格</td></tr></tbody></table><h1 id="mermaid"><a href="#mermaid" class="headerlink" title="mermaid"></a>mermaid</h1><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">A[Hard] --&gt;|Text| B(Round)</span><br><span class="line">B --&gt; C&#123;Decision&#125;</span><br><span class="line">C --&gt;|One| D[Result 1]</span><br><span class="line">C --&gt;|Two| E[Result 2]</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">TD</th><th align="center">TB</th><th align="center">BT</th><th align="center">RL</th><th align="center">LR</th></tr></thead><tbody><tr><td align="center">上到下</td><td align="center">上到下</td><td align="center">下到上</td><td align="center">右到左</td><td align="center">左到右</td></tr></tbody></table><h2 id="饼图"><a href="#饼图" class="headerlink" title="饼图"></a>饼图</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pie</span><br><span class="line">    title 为什么总是宅在家里？</span><br><span class="line">    &quot;喜欢宅&quot; : 45</span><br><span class="line">    &quot;天气太热&quot; : 70</span><br><span class="line">    &quot;穷&quot; : 500</span><br><span class="line">&quot;关你屁事&quot; : 95</span><br></pre></td></tr></table></figure><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">classDiagram</span><br><span class="line">    Animal &lt;|-- Duck</span><br><span class="line">    Animal &lt;|-- Fish</span><br><span class="line">    Animal &lt;|-- Zebra</span><br><span class="line">    Animal : +int age</span><br><span class="line">    Animal : +String gender</span><br><span class="line">    Animal: +isMammal()</span><br><span class="line">    Animal: +mate()</span><br><span class="line">    class Duck&#123;</span><br><span class="line">      +String beakColor</span><br><span class="line">      +swim()</span><br><span class="line">      +quack()</span><br><span class="line">    &#125;</span><br><span class="line">    class Fish&#123;</span><br><span class="line">      -int sizeInFeet</span><br><span class="line">      -canEat()</span><br><span class="line">    &#125;</span><br><span class="line">    class Zebra&#123;</span><br><span class="line">      +bool is_wild</span><br><span class="line">      +run()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>测试ing</p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/%E5%B7%A5%E5%85%B7/">工具</category>
      
      <category domain="http://example.com/categories/%E5%B7%A5%E5%85%B7/markdown/">markdown</category>
      
      
      
      <comments>http://example.com/2023/01/14/%E5%B7%A5%E5%85%B7/markdown/markdown%E8%AF%AD%E6%B3%95/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>特殊类设计</title>
      <link>http://example.com/2023/01/12/CPP/%E7%89%B9%E6%AE%8A%E7%B1%BB%E8%AE%BE%E8%AE%A1/</link>
      <guid>http://example.com/2023/01/12/CPP/%E7%89%B9%E6%AE%8A%E7%B1%BB%E8%AE%BE%E8%AE%A1/</guid>
      <pubDate>Thu, 12 Jan 2023 15:24:17 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;设计不能被拷贝的类&quot;&gt;&lt;a href=&quot;#设计不能被拷贝的类&quot; class=&quot;headerlink&quot; title=&quot;设计不能被拷贝的类&quot;&gt;&lt;/a&gt;设计不能被拷贝的类&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;c++11是下边的用法，c++98就是将拷贝构造变成私有，</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="设计不能被拷贝的类"><a href="#设计不能被拷贝的类" class="headerlink" title="设计不能被拷贝的类"></a>设计不能被拷贝的类</h1><blockquote><p>c++11是下边的用法，c++98就是将拷贝构造变成私有，并且只声明并不实现</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>(<span class="type">int</span> val):_val(val)&#123;&#125;</span><br><span class="line"><span class="built_in">A</span>(<span class="type">const</span> A&amp; a) = <span class="keyword">delete</span>;</span><br><span class="line">A&amp; <span class="keyword">operator</span>=(<span class="type">const</span> A&amp; a) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> _val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="设计只能在堆上创建的类"><a href="#设计只能在堆上创建的类" class="headerlink" title="设计只能在堆上创建的类"></a>设计只能在堆上创建的类</h1><blockquote><p>方案1、将析构函数私有化</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HeapOnly</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">destroy</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">~<span class="built_in">HeapOnly</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HeapOnly* hp = <span class="keyword">new</span> HeapOnly;</span><br><span class="line">hp-&gt;<span class="built_in">destroy</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>方案2、构造函数私有</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HeapOnly</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> HeapOnly* <span class="title">CreatObj</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> HeapOnly;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 防止拷贝</span></span><br><span class="line"><span class="built_in">HeapOnly</span>(<span class="type">const</span> HeapOnly&amp; hp) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">HeapOnly</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HeapOnly* hp = HeapOnly::<span class="built_in">CreatObj</span>();</span><br><span class="line"><span class="keyword">delete</span> hp;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>注意：也要把拷贝构造给删除掉</code></pre><h1 id="设计只能在栈上创建的类"><a href="#设计只能在栈上创建的类" class="headerlink" title="设计只能在栈上创建的类"></a>设计只能在栈上创建的类</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StackOnly</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> StackOnly <span class="title">CreatObj</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">StackOnly</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">StackOnly</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">StackOnly sk = StackOnly::<span class="built_in">CreatObj</span>();</span><br><span class="line"><span class="comment">// 避免不了下边的情况</span></span><br><span class="line"><span class="function"><span class="type">static</span> StackOnly <span class="title">copy</span><span class="params">(sk)</span></span>;</span><br><span class="line">StackOnly* copy2 = <span class="keyword">new</span> <span class="built_in">StackOnly</span>(sk);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决new </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StackOnly</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> StackOnly <span class="title">CreatObj</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">StackOnly</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> n)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">StackOnly</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但是静态区的拷贝构造还是不能被禁止。</p><h1 id="设计不能被继承的类"><a href="#设计不能被继承的类" class="headerlink" title="设计不能被继承的类"></a>设计不能被继承的类</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++98中构造函数私有化，派生类中调不到基类的构造函数。则无法继承  </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NonInherit</span>  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line"><span class="function"><span class="type">static</span> NonInherit <span class="title">GetInstance</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line"><span class="keyword">return</span> <span class="built_in">NonInherit</span>();  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line"><span class="built_in">NonInherit</span>()&#123;&#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>在C++11中有了final关键字，修饰类就说明该类不能被继承。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">final</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// ....  </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="设计只能创建一个对象的类（单例）"><a href="#设计只能创建一个对象的类（单例）" class="headerlink" title="设计只能创建一个对象的类（单例）"></a>设计只能创建一个对象的类（单例）</h1><h2 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h2><blockquote><p>构造函数私有，在静态区创建一个对象，</p></blockquote><ul><li>简单，没有线程安全问题</li><li>一个程序中，多个单例，并且有先后创建初始化的顺序要求时，饿汉无法控制，比如多个文件，就无法控制顺序</li><li>饿汉的单例类，初始化时任务多，会影响程序的启动速度。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> A* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;调用fun()\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">A</span>()&#123;&#125;</span><br><span class="line"><span class="type">static</span> A* _a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A* A::_a = <span class="keyword">new</span> A;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">A* p = A::<span class="built_in">getInstance</span>();</span><br><span class="line">p-&gt;<span class="built_in">fun</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h2><blockquote><p>第一次使用对象再创建实例对象</p></blockquote><ul><li>可以控制创建的顺序</li><li>不影响启动速度</li><li>相对复杂，有线程安全问题</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> A* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(_a == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">_a = <span class="keyword">new</span> A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> _a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;调用fun()\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现一个内嵌垃圾回收类    </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CGarbo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">~<span class="built_in">CGarbo</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (_a)</span><br><span class="line"><span class="keyword">delete</span> _a;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">A</span>()&#123;&#125;</span><br><span class="line"><span class="type">static</span> A* _a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A* A::_a = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="comment">// 回收对象，main函数结束后，他会调用析构函数，就会释放单例对象</span></span><br><span class="line"><span class="type">static</span> A::CGarbo gc;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">A* p = A::<span class="built_in">getInstance</span>();</span><br><span class="line">p-&gt;<span class="built_in">fun</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单例对象释放"><a href="#单例对象释放" class="headerlink" title="单例对象释放"></a>单例对象释放</h2><ul><li>一般情况下，单例对象不需要释放，因为一般整个程序运行期间都可能用它</li><li>单例对象在进程正常结束后，也会资源释放</li><li>有些特殊场景需要释放，比如单例对象析构时，要进行一些持久化操作（往文件数据库写）操作</li><li>释放时，可以做个内部类，如上边代码</li></ul>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/CPP/">CPP</category>
      
      
      
      <comments>http://example.com/2023/01/12/CPP/%E7%89%B9%E6%AE%8A%E7%B1%BB%E8%AE%BE%E8%AE%A1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>智能指针</title>
      <link>http://example.com/2023/01/11/CPP/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</link>
      <guid>http://example.com/2023/01/11/CPP/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</guid>
      <pubDate>Wed, 11 Jan 2023 13:32:45 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;RAII&quot;&gt;&lt;a href=&quot;#RAII&quot; class=&quot;headerlink&quot; title=&quot;RAII&quot;&gt;&lt;/a&gt;RAII&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;在了解智能指针之前，我们需要先要了解RAII，那么什么是RAII呢？RAII是一种利用对象生命周期</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="RAII"><a href="#RAII" class="headerlink" title="RAII"></a>RAII</h1><blockquote><p>在了解智能指针之前，我们需要先要了解RAII，那么什么是RAII呢？RAII是一种利用对象生命周期来控制程序资源（如内存、文件句柄、网络链接、互斥量等）的简单技术</p></blockquote><p>具体来说，是在对象构造时获取资源，对资源的控制管理在整个对象的生命周期内都保持有效，并在对象析构时释放资源，也就是将资源的管理托管给一个对象，这有着一些好处：</p><ul><li>不用显示释放资源</li><li>对象所需的资源在其整个生命周期内始终保持有效</li></ul><h2 id="RAII-引入"><a href="#RAII-引入" class="headerlink" title="RAII-引入"></a>RAII-引入</h2><blockquote><p>下边是一段异常相关的代码，main函数调用fun，fun函数先new了块空间，然后调用div函数，但是div函数如果出现除0错误，会抛出异常，直接被main函数捕获，那么fun中的delete就被跳过了。这样导致了内存泄漏问题。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">div</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a, b;</span><br><span class="line">cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line"><span class="keyword">if</span> (b == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="string">&quot;除0错误&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span>* p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1</span>);</span><br><span class="line">cout &lt;&lt; <span class="built_in">div</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fun</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (<span class="type">const</span> <span class="type">char</span>* str)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对上边代码，是有一些方法进行处理的，但是这里可以用RAII的技术解决这个问题，具体看下方代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmartPtr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">SmartPtr</span>(T* ptr)</span><br><span class="line">:_ptr(ptr)</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">SmartPtr</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(_ptr)</span><br><span class="line"><span class="keyword">delete</span> _ptr;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;SmartPtr：申请的资源已经释放&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T* _ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">div</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a, b;</span><br><span class="line">cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line"><span class="keyword">if</span> (b == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="string">&quot;除0错误&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">SmartPtr&lt;<span class="type">int</span>&gt;sp = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1</span>);</span><br><span class="line">cout &lt;&lt; <span class="built_in">div</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对上边场景我们可以设计一个SmartPtr类，这个类构造函数接收一个资源的管理权，析构函数释放这份资源，那么当创建的对象的生命周期结束后，就自动调用析构函数并释放资源。</p><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202301102206518.png"></p><h1 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h1><blockquote><p>上边的SmartPtr类，就是RAII，但是只有管理资源释放的功能，并没有指针解引用和-&gt;的操作，不能对管理的资源进行控制，那么我们如何让SmartPtr支持像指针一样的行为呢？这里我们将引入智能指针的概念，并且简要的模拟四种库的智能指针，理解原理</p></blockquote><p>智能指针的原理如下：  </p><ol><li>RAII特性  </li><li>重载operator * 和opertaor-&gt;，具有像指针一样的行为。</li></ol><blockquote><p>我们之前实现的SmartPtr其实还存在着其他的问题：就是不能进行拷贝，如果进行拷贝，会出现资源重复释放的问题。</p></blockquote><p>比如下面的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> _a = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> _b = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">SmartPtr&lt;A&gt;<span class="built_in">ap1</span>(<span class="keyword">new</span> A);</span><br><span class="line"></span><br><span class="line">SmartPtr&lt;A&gt;<span class="built_in">ap2</span>(ap1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果也不出意外的报错了。</p><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202301102243974.png"></p><h2 id="auto-ptr"><a href="#auto-ptr" class="headerlink" title="auto_ptr"></a>auto_ptr</h2><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202301102219593.png"></p><blockquote><p>针对上边拷贝的问题，auto_ptr提供了它的方案，auto_ptr的实现原理：<strong>管理权转移的思想</strong>，但是这种做法并不太好，你一旦拷贝构造，被拷贝的对象就无法使用了，容易出错。</p></blockquote><p>看一下库的auto_ptr，如果对进行拷贝构造，其实是进行资源的转移</p><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202301102236948.png"></p><p>我们对auto_ptr进行模拟实现，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">auto_ptr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">auto_ptr</span>(T* ptr)</span><br><span class="line">:_ptr(ptr)</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝构造要进行管理权的转移</span></span><br><span class="line"><span class="built_in">auto_ptr</span>(auto_ptr&lt;T&gt;&amp; ap)</span><br><span class="line">&#123;</span><br><span class="line">_ptr = ap._ptr;</span><br><span class="line">ap._ptr = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">auto_ptr&lt;T&gt;&amp; <span class="keyword">operator</span>=(auto_ptr&lt;T&gt;&amp; ap)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> != &amp;ap)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (_ptr) <span class="comment">// 判断_ptr是否为空</span></span><br><span class="line"><span class="keyword">delete</span> _ptr;</span><br><span class="line"></span><br><span class="line">_ptr = ap._ptr;</span><br><span class="line">ap._ptr = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">auto_ptr</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (_ptr)</span><br><span class="line"><span class="keyword">delete</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">T&amp; <span class="keyword">operator</span>*()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> *_ptr;</span><br><span class="line">&#125;</span><br><span class="line">T* <span class="keyword">operator</span>-&gt;()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T* _ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h2><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202301102347615.png"></p><blockquote><p>unique_ptr的实现原理：简单粗暴的防拷贝</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">unique_ptr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">unique_ptr</span>(T* ptr)</span><br><span class="line">:_ptr(ptr)</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="built_in">unique_ptr</span>(<span class="type">const</span> unique_ptr&lt;T&gt;&amp; up) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">unique_ptr&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="type">const</span> unique_ptr&lt;T&gt;&amp; up) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">unique_ptr</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (_ptr)</span><br><span class="line"><span class="keyword">delete</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">T&amp; <span class="keyword">operator</span>*()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> *_ptr;</span><br><span class="line">&#125;</span><br><span class="line">T* <span class="keyword">operator</span>-&gt;()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T* _ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h2><pre><code>下边代码有一些开始写成了share_ptr，少了个d，后补上了，导致有一些截图和代码少一个d</code></pre><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202301110001271.png"></p><blockquote><p>auto_ptr和unique_ptr都针对智能指针的拷贝问题上有各自的处理方式，但是都比较呆，很多时候我们是有拷贝指针的需求的，那么这时候share_ptr就登场了。</p></blockquote><p>shared_ptr的原理：是通过引用计数的方式来实现多个shared_ptr对象之间共享资源。  </p><ol><li>shared_ptr在其内部，给每个资源都维护了着一份计数，用来记录该份资源被几个对象共享</li><li>在对象被销毁时(也就是析构函数调用)，就说明自己不使用该资源了，对象的引用计数减一</li><li>如果引用计数是0，就说明自己是最后一个使用该资源的对象，必须释放该资源 </li><li>如果不是0，就说明除了自己还有其他对象在使用该份资源，不能释放该资源，否则其他对象就成野指针了。</li></ol><p>如何根据shared_ptr的原理，进行引用计数功能的实现呢？</p><p><strong>方案1、静态成员变量 count计数</strong></p><p>这里是否可行呢？我们试着实现一下，并测试效果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">shared_ptr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">shared_ptr</span>(T* ptr = <span class="literal">nullptr</span>)</span><br><span class="line">:_ptr(ptr)</span><br><span class="line">&#123;</span><br><span class="line">_count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">shared_ptr</span>(shared_ptr&lt;T&gt;&amp; sp)</span><br><span class="line">:_ptr(sp._ptr)</span><br><span class="line">&#123;</span><br><span class="line">_count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">T&amp; <span class="keyword">operator</span>*()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> *_ptr;</span><br><span class="line">&#125;</span><br><span class="line">T* <span class="keyword">operator</span>-&gt;()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">~<span class="built_in">shared_ptr</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (--_count == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> _ptr;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T* _ptr;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> _count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">int</span> shared_ptr&lt;T&gt;::_count = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>运行测试：</p><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202301111412860.png"></p><p>使用静态成员变量确实可以解决拷贝构造导致的重复释放资源的问题，但是，这也会引发新的问题。因为静态成员变量不属于某一个对象，它属于整个类。如果我们再创建一个对象就会引发资源泄漏的问题。</p><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202301111417078.png"></p><pre><code>这里创建了个sp3，按理说有了两份资源，但是只析构了一次，原因如下。</code></pre><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202301111424168.png"></p><p>我们其实期望的是对一份资源的管理，这一份资源要有独立的引用计数，但是用静态成员变量做不到这一点，无论多少份的资源，它们会共享一份引用计数，这样就会导致资源泄漏问题。</p><p>所以，静态成员变量这种方案是不行的，那么应该怎么做呢？我们引入第二种的方案。</p><p><strong>方案2、在堆上申请一块空间做计数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">shared_ptr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">shared_ptr</span>(T* ptr = <span class="literal">nullptr</span>)</span><br><span class="line">:_ptr(ptr)</span><br><span class="line">,_pcount(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1</span>))</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">shared_ptr</span>(shared_ptr&lt;T&gt;&amp; sp)</span><br><span class="line">:_ptr(sp._ptr)</span><br><span class="line">,_pcount(sp._pcount)</span><br><span class="line">&#123;</span><br><span class="line">(*_pcount)++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">shared_ptr&lt;T&gt;&amp; <span class="keyword">operator</span>=(shared_ptr&lt;T&gt;&amp; sp)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// share_ptr&lt;A&gt;sp1(new A)</span></span><br><span class="line"><span class="comment">// share_ptr&lt;A&gt;sp2(sp1)</span></span><br><span class="line"><span class="comment">// sp1 = sp2</span></span><br><span class="line"><span class="comment">// 为了防止上边场景，用_ptr判断更好</span></span><br><span class="line"><span class="keyword">if</span> (_ptr == sp._ptr) </span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --被赋值对象的计数，如果是最后一个对象要释放资源</span></span><br><span class="line"><span class="keyword">if</span> (--(*_pcount) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> _ptr;</span><br><span class="line"><span class="keyword">delete</span> _pcount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 共管新资源，++计数</span></span><br><span class="line">_ptr = sp._ptr;</span><br><span class="line">_pcount = sp._pcount;</span><br><span class="line"></span><br><span class="line">(*_pcount)++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">T&amp; <span class="keyword">operator</span>*()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> *_ptr;</span><br><span class="line">&#125;</span><br><span class="line">T* <span class="keyword">operator</span>-&gt;()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">~<span class="built_in">shared_ptr</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (--(*_pcount) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> _ptr;</span><br><span class="line"><span class="keyword">delete</span> _pcount;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T* _ptr;</span><br><span class="line"><span class="type">int</span>* _pcount;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>运行结果如下：可以看到解决了上边的问题。</p><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202301111508572.png"></p><h2 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h2><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202301111514694.png"></p><blockquote><p>我们的shared_ptr看起来已经很厉害了，那这个weak_ptr又有什么作用呢？这里就要看shared_ptr潜在的一个问题了。</p></blockquote><h3 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h3><blockquote><p>问题的引入：我们有个节点类，用shared_ptr会发生什么样的问题，我们来看一下下面</p></blockquote><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202301111622216.png"></p><pre><code>上边说share_ptr的对象不能给Node*，我们可以更改一个Node类，将前后指针改成智能指针。</code></pre><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202301111624432.png"></p><pre><code>经过更改后发现没有任何的问题，shared_ptr好像完美的胜任了节点的指针这个角色</code></pre><p>我们继续看一个场景：</p><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202301111626436.png"></p><pre><code>当我们加上sp2-&gt;_pre=sp1时，就出现问题了，运行结果是两个节点都没有释放，这是为啥呢，非常奇怪的问题。</code></pre><blockquote><p>这里我们就要引出，循环引用的概念了。</p></blockquote><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202301111651493.png"></p><p>这时候就出现了循环引用的问题，导致了两边的资源都没有没释放，这时候就引入了weak_ptr来解决这个问题。</p><blockquote><p>解决方案：在引用计数的场景下，把节点中的_prev和_next改成weak_ptr就可以了</p></blockquote><p>sp1-&gt; _ next &#x3D; sp2；sp2-&gt;_ pre &#x3D; sp1；时weak_ptr的_next和_ prev不会增加sp1和sp2的引用计数。</p><p>我们再看一下运行结果，发现问题已经被解决。</p><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202301111706127.png"></p><h3 id="weak-ptr模拟"><a href="#weak-ptr模拟" class="headerlink" title="weak_ptr模拟"></a>weak_ptr模拟</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">weak_ptr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">weak_ptr</span>()</span><br><span class="line">:_ptr(<span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">weak_ptr</span>(<span class="type">const</span> shared_ptr&lt;T&gt;&amp; sp)</span><br><span class="line">:_ptr(sp.<span class="built_in">get</span>())</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">weak_ptr</span>(<span class="type">const</span> weak_ptr&lt;T&gt;&amp; wp)</span><br><span class="line">:_ptr(wp._ptr)</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line">weak_ptr&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="type">const</span> shared_ptr&lt;T&gt;&amp; sp)</span><br><span class="line">&#123;</span><br><span class="line">_ptr = sp.<span class="built_in">get</span>();</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">T&amp; <span class="keyword">operator</span>*()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> *_ptr;</span><br><span class="line">&#125;</span><br><span class="line">T* <span class="keyword">operator</span>-&gt;()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T* _ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>切换成st的命名空间，结果如下：</p><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202301112019787.png"></p><p>也实现了库中weak_ptr的效果，解决了循环引用的问题。</p><h1 id="定制删除器"><a href="#定制删除器" class="headerlink" title="定制删除器"></a>定制删除器</h1><blockquote><p>定制删除器是针对智能指针管理的类型定制专用的删除器，如果没有制删除器可能会出现一些错误。</p></blockquote><p>比如下边代码，用了库里面的shared_ptr</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt;<span class="built_in">s1</span>(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>]);</span><br><span class="line">std::shared_ptr&lt;Node&gt;<span class="built_in">sp2</span>(<span class="keyword">new</span> Node[<span class="number">5</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202301112050260.png"></p><pre><code>可以看到程序直接崩溃了，其实第一个还没有崩，第二个Node[5]那里才崩溃掉</code></pre><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202301112104024.png"></p><p>由于释放的位置不对导致程序崩溃掉。</p><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202301112105450.png"></p><p>可以通过定制删除器解决这个问题，也就是传个函数对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DeleteArray</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T* ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;delete[]&quot;</span> &lt;&lt; ptr &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span>[] ptr;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Free</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T* ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;free&quot;</span> &lt;&lt; ptr &lt;&lt; endl;</span><br><span class="line"><span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_del</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 仿函数对象</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;Node&gt; <span class="title">n1</span><span class="params">(<span class="keyword">new</span> Node[<span class="number">5</span>], DeleteArray&lt;Node&gt;())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">std::shared_ptr&lt;Node&gt; <span class="title">n2</span><span class="params">(<span class="keyword">new</span> Node)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">n3</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>], DeleteArray&lt;<span class="type">int</span>&gt;())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">n4</span><span class="params">((<span class="type">int</span>*)malloc(<span class="keyword">sizeof</span>(<span class="number">12</span>)), Free&lt;<span class="type">int</span>&gt;())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lambda</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;Node&gt; <span class="title">m1</span><span class="params">(<span class="keyword">new</span> Node[<span class="number">5</span>], [](Node* ptr)&#123;<span class="keyword">delete</span>[] ptr; &#125;)</span></span>;</span><br><span class="line"><span class="function">std::shared_ptr&lt;Node&gt; <span class="title">m2</span><span class="params">(<span class="keyword">new</span> Node)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">m3</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>], [](<span class="type">int</span>* ptr)&#123;<span class="keyword">delete</span>[] ptr; &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">m4</span><span class="params">((<span class="type">int</span>*)malloc(<span class="keyword">sizeof</span>(<span class="number">12</span>)), [](<span class="type">int</span>* ptr)&#123;free(ptr); &#125;)</span></span>;</span><br><span class="line"><span class="function">std::shared_ptr&lt;FILE&gt; <span class="title">m5</span><span class="params">(fopen(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;w&quot;</span>), [](FILE* ptr)&#123;fclose(ptr); &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">主要unique是在模板参数这里</span><br><span class="line"><span class="comment">//std::unique_ptr&lt;Node, DeleteArray&lt;Node&gt;&gt; up(new Node[5]);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="模拟完善shared-ptr"><a href="#模拟完善shared-ptr" class="headerlink" title="模拟完善shared_ptr"></a>模拟完善shared_ptr</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">D</span> = Delete&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> shared_ptr</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">shared_ptr</span>(T* ptr = <span class="literal">nullptr</span>)</span><br><span class="line">: _ptr(ptr)</span><br><span class="line">, _pCount(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1</span>))</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="built_in">Release</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (--(*_pCount) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">D</span>()(_ptr);</span><br><span class="line"><span class="keyword">delete</span> _pCount;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">shared_ptr</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">Release</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">shared_ptr</span>(<span class="type">const</span> shared_ptr&lt;T&gt;&amp; sp)</span><br><span class="line">: _ptr(sp._ptr)</span><br><span class="line">, _pCount(sp._pCount)</span><br><span class="line">&#123;</span><br><span class="line">(*_pCount)++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">shared_ptr&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="type">const</span> shared_ptr&lt;T&gt;&amp; sp)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//if (this == &amp;sp)</span></span><br><span class="line"><span class="keyword">if</span> (_ptr == sp._ptr)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Release</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 共管新资源，++计数</span></span><br><span class="line">_ptr = sp._ptr;</span><br><span class="line">_pCount = sp._pCount;</span><br><span class="line"></span><br><span class="line">(*_pCount)++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">T&amp; <span class="keyword">operator</span>*()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> *_ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">T* <span class="keyword">operator</span>-&gt;()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">use_count</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> *_pCount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">T* <span class="title">get</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T* _ptr;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用计数</span></span><br><span class="line"><span class="type">int</span>* _pCount;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里的模拟定制删除器的功能，是简单版的通过模板参数控制</p><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202301112131999.png"></p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/CPP/">CPP</category>
      
      
      
      <comments>http://example.com/2023/01/11/CPP/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>C++异常</title>
      <link>http://example.com/2023/01/09/CPP/%E5%BC%82%E5%B8%B8/</link>
      <guid>http://example.com/2023/01/09/CPP/%E5%BC%82%E5%B8%B8/</guid>
      <pubDate>Mon, 09 Jan 2023 13:10:47 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;在我们写代码的过程中，出现错误是非常常见的事情，如何对一些异常进行合理方式的处理是非常重要的问题，c语言有c语言的方法，当然，cpp作为oop的语言当然也有它的一套体系。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;C语言处理错误的方式&quot;&gt;</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>在我们写代码的过程中，出现错误是非常常见的事情，如何对一些异常进行合理方式的处理是非常重要的问题，c语言有c语言的方法，当然，cpp作为oop的语言当然也有它的一套体系。</p></blockquote><h1 id="C语言处理错误的方式"><a href="#C语言处理错误的方式" class="headerlink" title="C语言处理错误的方式"></a>C语言处理错误的方式</h1><h2 id="c错误处理方式"><a href="#c错误处理方式" class="headerlink" title="c错误处理方式"></a>c错误处理方式</h2><ol><li><p><strong>终止程序</strong>：比如assert，缺点：有些问题会直接退出会让用户非常难受，比如出现网络错误，我们通常希望的是告警，而不是进程退出。</p></li><li><p><strong>返回错误码</strong>：返回错误码的方式并不直观，比如返回一个5，并不能直接知道出了什么错误，必须要查对应的的错误。</p><p> 大部分情况c还是采用返回错误码的方式处理错误，部分情况使用终止进程处理特别严重的错误。</p></li></ol><h1 id="C-异常概念"><a href="#C-异常概念" class="headerlink" title="C++异常概念"></a>C++异常概念</h1><blockquote><p>异常是什么？其实是一种处理错误的方式，当一个函数遇到无法处理的错误时，就可以抛出异常，让函数可以直接或者间接的调用者去处理这个错误。</p></blockquote><p>大概形式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="comment">// 保护的标识代码  </span></span><br><span class="line">&#125;<span class="built_in">catch</span>( ExceptionName e1 )  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="comment">// catch 块  </span></span><br><span class="line">&#125;<span class="built_in">catch</span>( ExceptionName e2 )  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="comment">// catch 块  </span></span><br><span class="line">&#125;<span class="built_in">catch</span>( ExceptionName eN )  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="comment">// catch 块  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="异常的使用"><a href="#异常的使用" class="headerlink" title="异常的使用"></a>异常的使用</h1><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><blockquote><p>使用异常前，先认识一下异常的关键字</p></blockquote><ul><li><strong>throw</strong>：抛出异常关键字，可以抛出任意的东西（字符串、整数…）</li><li><strong>try</strong>：括号内的代码就是可能会出现异常的地方。</li><li><strong>catch</strong>：能捕捉抛出的异常，当然要类型对应。</li></ul><h2 id="异常规则"><a href="#异常规则" class="headerlink" title="异常规则"></a>异常规则</h2><h3 id="异常的抛出和捕获"><a href="#异常的抛出和捕获" class="headerlink" title="异常的抛出和捕获"></a>异常的抛出和捕获</h3><ul><li>抛出对象的类型严格匹配catch类型</li><li>抛出对象匹配最近的catch</li><li>抛出的是对象的拷贝</li><li>catch(…) 可以捕捉任意类型的异常，用来兜底</li><li>可以抛派生类对象，用父类进行捕获</li></ul><h4 id="类型匹配例子："><a href="#类型匹配例子：" class="headerlink" title="类型匹配例子："></a>类型匹配例子：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a, b;</span><br><span class="line">cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试扔出三种类型，匹配对应的catch</span></span><br><span class="line"><span class="keyword">if</span> (b == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//throw 0;</span></span><br><span class="line"><span class="comment">//throw string(&quot;除0错误&quot;);</span></span><br><span class="line"><span class="keyword">throw</span> <span class="string">&#x27;e&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a/b=&quot;</span> &lt;&lt; a / b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fun</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (<span class="type">int</span> errid)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;errid：&quot;</span> &lt;&lt; errid &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (<span class="type">char</span> errch)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;errch：&quot;</span> &lt;&lt; errch &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (<span class="type">const</span> string&amp; errstr)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;errstr：&quot;</span> &lt;&lt; errstr &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下，匹配对应的catch</p><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202301082345139.png"></p><h4 id="子类异常基类捕获"><a href="#子类异常基类捕获" class="headerlink" title="子类异常基类捕获"></a>子类异常基类捕获</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Exception</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Exception</span>(<span class="type">const</span> string&amp; errmsg, <span class="type">int</span> id)</span><br><span class="line">:_errmsg(errmsg)</span><br><span class="line">, _id(id)</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> string <span class="title">what</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _errmsg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getid</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">string _errmsg;   <span class="comment">// 错误信息</span></span><br><span class="line"><span class="type">int</span> _id;          <span class="comment">// 错误码</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ErrorA</span> : <span class="keyword">public</span> Exception</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">ErrorA</span>(<span class="type">const</span> string&amp; errmsg, <span class="type">int</span> id, <span class="type">const</span> string&amp; errorA)</span><br><span class="line">:<span class="built_in">Exception</span>(errmsg,id)</span><br><span class="line">,_errA(errorA)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 重写虚函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> string <span class="title">what</span><span class="params">()</span><span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string str = _errmsg + <span class="string">&quot; &quot;</span> + _errA;</span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string _errA;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">rand</span>() % <span class="number">5</span> == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">ErrorA</span>(<span class="string">&quot;错误：&quot;</span>, <span class="number">100</span>, <span class="string">&quot;A&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">Sleep</span>(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fun</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (<span class="type">const</span> Exception&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (...)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;未知错误&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202301090028259.png"></p><h3 id="在函数调用链中异常展开匹配规则"><a href="#在函数调用链中异常展开匹配规则" class="headerlink" title="在函数调用链中异常展开匹配规则"></a>在函数调用链中异常展开匹配规则</h3><ul><li>现在当前栈帧中看</li><li>没有去上一层栈帧</li><li>如果到了main栈帧还未匹配，终止程序</li><li>catch处理后，会继续执行之后的语句</li></ul><h4 id="函数调用例子"><a href="#函数调用例子" class="headerlink" title="函数调用例子"></a>函数调用例子</h4><blockquote><p>代码大致如上方代码，但是fun函数里面调用了div函数，并在fun函数里面进行异常捕获，同样的在main函数中，也对fun进行异常的捕获</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">div</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a, b;</span><br><span class="line">cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line"><span class="keyword">if</span> (b == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//throw 0;</span></span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">string</span>(<span class="string">&quot;除0错误&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a/b=&quot;</span> &lt;&lt; a / b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">div</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (<span class="type">int</span> errid)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;fun中catch：&quot;</span> &lt;&lt; errid &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line"></span><br><span class="line">![](https:<span class="comment">//tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202301082359524.png)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 异常栈帧展开</span><br><span class="line"></span><br><span class="line">![](https:<span class="comment">//tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202301090003458.png)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 异常安全</span><br><span class="line"></span><br><span class="line">+ 最好不要在构造函数中抛出异常，可能导致构造对象不完整</span><br><span class="line">+ 最好不要在析构函数中抛出异常，可能会导致资源泄露</span><br><span class="line">+ C++中异常经常会导致资源泄漏的问题，比如在<span class="keyword">new</span>和<span class="keyword">delete</span>中抛出了异常，导致内存泄漏，在lock和unlock之间抛出了异常导致死锁</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">比如下面的场景：</span><br><span class="line">&gt; 如果发生异常，就不会执行<span class="keyword">delete</span>，这样导致了资源泄漏，当然可以在Func中的<span class="keyword">catch</span>中再增加<span class="keyword">delete</span>，但是还有隐藏的问题，比如，array1成功，array2失败，arr2抛异常，会抛到main函数栈帧中。会导致array1得不到释放。</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line"><span class="type">void</span> <span class="built_in">Func</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 这里可以看到如果发生除0错误抛出异常，另外下面的array没有得到释放。</span></span><br><span class="line"><span class="comment">// 所以这里捕获异常后并不处理异常，异常还是交给外面处理，这里捕获了再</span></span><br><span class="line"><span class="comment">// 重新抛出去。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐患，第一个成功，第二个失败</span></span><br><span class="line">    <span class="comment">// 可以解决，但是很麻烦，这样的问题一般是用智能指针解决</span></span><br><span class="line"><span class="type">int</span>* array1 = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span>* array2 = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> len, time;</span><br><span class="line">cin &gt;&gt; len &gt;&gt; time;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="built_in">Division</span>(len, time) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (...)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 若第一个new成功，第二个失败，这里还要delete arr2</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;delete []&quot;</span> &lt;&lt; array1 &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span>[] array1;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;delete []&quot;</span> &lt;&lt; array1 &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span>[] array2; </span><br><span class="line"></span><br><span class="line"><span class="keyword">throw</span>; <span class="comment">// 捕获什么抛出什么</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;delete []&quot;</span> &lt;&lt; array1 &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span>[] array1;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;delete []&quot;</span> &lt;&lt; array2 &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span>[] array2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">Func</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (<span class="type">const</span> <span class="type">char</span>* errmsg)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; errmsg &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="异常规范"><a href="#异常规范" class="headerlink" title="异常规范"></a>异常规范</h2><ol><li>异常规格说明的目的是为了让函数使用者知道该函数可能抛出的异常有哪些。 可以在函数的后面接throw(类型)，列出这个函数可能抛掷的所有异常类型。  </li><li>函数的后面接throw()，表示函数不抛异常。  </li><li>若无异常接口声明，则此函数可以抛掷任何类型的异常</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里表示这个函数会抛出A/B/C/D中的某种类型的异常  </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span> <span class="title">throw</span><span class="params">(A，B，C，D)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里表示这个函数只会抛出bad_alloc的异常  </span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span> <span class="params">(std::<span class="type">size_t</span> size)</span> <span class="title">throw</span> <span class="params">(std::bad_alloc)</span></span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里表示这个函数不会抛出异常  </span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">delete</span> <span class="params">(std::<span class="type">size_t</span> size, <span class="type">void</span>* ptr)</span> <span class="title">throw</span><span class="params">()</span></span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// C++11 中新增的noexcept，表示不会抛异常  </span></span><br><span class="line"><span class="built_in">thread</span>() <span class="keyword">noexcept</span>;  </span><br><span class="line"><span class="built_in">thread</span> (thread&amp;&amp; x) <span class="keyword">noexcept</span>;</span><br></pre></td></tr></table></figure><h1 id="异常的优缺点"><a href="#异常的优缺点" class="headerlink" title="异常的优缺点"></a>异常的优缺点</h1><h2 id="C-异常优点"><a href="#C-异常优点" class="headerlink" title="C++异常优点"></a>C++异常优点</h2><ol><li>异常对象定义好之后，相比错误码的方式更能清晰准确的展示出错误的各种信息，甚至可以包含调用堆栈的信息，可以更容易定位程序bug</li><li>可以直接跳出到catch捕捉的地方，而不用像错误码一样层层返回。</li><li>很多第三方库包含异常</li><li>部分函数使用异常更好处理，比如构造函数没有返回值，不方便使用错误码方式处理，方括号的重载，pos越界错误，只能通过异常或者终止程序。</li></ol><h2 id="C-异常缺点"><a href="#C-异常缺点" class="headerlink" title="C++异常缺点"></a>C++异常缺点</h2><ol><li>执行流可能会乱跳，运行时抛出，会比较的混乱</li><li>有性能开销</li><li>容易导致内存泄漏、死锁安全问题</li><li>C++标准体系定义不好，导致大家自定义各自的异常体系，十分混乱</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>异常尽量规范使用，不要随便抛异常，遵守如下：</p><ul><li>所有异常类型都继承于一个基类</li><li>函数是否抛异常，抛什么异常，都使用 fun() throw(); 的方式规范化。</li></ul><p>异常总体来说，利大于弊。</p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/CPP/">CPP</category>
      
      
      
      <comments>http://example.com/2023/01/09/CPP/%E5%BC%82%E5%B8%B8/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>C++11（下篇）</title>
      <link>http://example.com/2023/01/03/CPP/C++11%EF%BC%88%E4%B8%8B%E7%AF%87%EF%BC%89/</link>
      <guid>http://example.com/2023/01/03/CPP/C++11%EF%BC%88%E4%B8%8B%E7%AF%87%EF%BC%89/</guid>
      <pubDate>Tue, 03 Jan 2023 15:21:36 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;类的新功能&quot;&gt;&lt;a href=&quot;#类的新功能&quot; class=&quot;headerlink&quot; title=&quot;类的新功能&quot;&gt;&lt;/a&gt;类的新功能&lt;/h1&gt;&lt;h2 id=&quot;默认成员函数&quot;&gt;&lt;a href=&quot;#默认成员函数&quot; class=&quot;headerlink&quot; title=&quot;默</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="类的新功能"><a href="#类的新功能" class="headerlink" title="类的新功能"></a>类的新功能</h1><h2 id="默认成员函数"><a href="#默认成员函数" class="headerlink" title="默认成员函数"></a>默认成员函数</h2><p>在以前的C++类中，有6个默认成员函数：</p><ol><li>构造函数  </li><li>析构函数  </li><li>拷贝构造函数  </li><li>拷贝赋值重载  </li><li>取地址重载  </li><li>const 取地址重载</li></ol><p>比较重要的是前4个，后两个的用处并不大，默认的成员函数就是我们不写编译器会生成一个默认的。</p><blockquote><p>在C++11中，新增了两个默认成员函数</p></blockquote><ol><li>移动构造函数</li><li>移动赋值运算符重载</li></ol><p>针对这两个新的默认成员函数，有了新的注意事项：</p><p>1、如果<strong>没有自己实现移动构造</strong>，<strong>且没有实现析构函数、拷贝构造、拷贝赋值重载中的任何一个</strong>，那么编译器会自动生成一个<strong>默认移动构造</strong>。</p><p>让我们来看个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(<span class="type">const</span> <span class="type">char</span>* name = <span class="string">&quot;&quot;</span>, <span class="type">int</span> age = <span class="number">0</span>)</span><br><span class="line">:_name(name)</span><br><span class="line">, _age(age)</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">st::string _name;</span><br><span class="line"><span class="type">int</span> _age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">s1</span><span class="params">(<span class="string">&quot;张三&quot;</span>, <span class="number">7</span>)</span></span>;</span><br><span class="line">Person s2 = std::<span class="built_in">move</span>(s1); <span class="comment">// 移动构造 （没有移动构造，再调用拷贝构造）</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的这个Person类，只自己实现了一个构造函数，析构、拷贝构造、拷贝赋值重载都未手动实现，Person的_name成员用的自己模拟实现的string类。</p><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202301021417868.png"></p><p>可以看到，调用了string的移动构造，那么如果我们在Person类中加个析构结果是什么样呢？</p><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202301021418203.png"></p><p>这里就调用了拷贝构造，原因是有了析构，就不再生成默认的移动构造函数。</p><p>2、默认生成的移动构造</p><ul><li>对于<strong>内置类型会逐字节拷贝</strong></li><li>对于<strong>自定义类型</strong>，则需要看这个成员是否实现了移动构造，如果<strong>实现了就调用移动构造，没有实现就调用拷贝构造</strong>。（如下图所示）</li></ul><blockquote><p>当删除了string类的移动构造后</p></blockquote><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202301021436581.png"></p><p>3、默认生成的移动赋值和默认生成的移动构造完全类似。</p><p>4、如果提供了移动构造或者移动赋值，编译器不会自动提供拷贝构造和拷贝赋值。</p><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202301021427141.png"></p><h2 id="default和delete"><a href="#default和delete" class="headerlink" title="default和delete"></a>default和delete</h2><h3 id="default"><a href="#default" class="headerlink" title="default"></a>default</h3><blockquote><p>强制生成默认函数</p></blockquote><p>我们知道对于类来说有时候会需要生成默认成员函数，比如我们实现了有参的构造，无参构造就不会默认生成，或者实现了拷贝构造，默认生成的移动构造就不会生成。</p><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202301021450459.png"></p><p>上图场景是我们实现了拷贝构造，那么默认的移动构造就不会生成，我们强制生成之后实现了我们想要的效果。</p><h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><blockquote><p>禁止生成默认函数的关键字</p></blockquote><p>比如要求delete关键字实现，一个类，只能在堆上创建对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HeapOnly</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">HeapOnly</span>()</span><br><span class="line">&#123;</span><br><span class="line">_str = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">10</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">HeapOnly</span>() = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Destroy</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">delete</span>[] _str;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">char</span>* _str;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>只需要：**~HeapOnly() &#x3D; delete**;</p><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202301021502973.png"></p><p>这样在栈和静态区都不能创建对象。如果要创建对象只能在堆上创建。</p><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202301021520043.png"></p><pre><code>注意，destroy() 函数，第一是释放 char* 的那个空间，第二个是要释放ptr指向的那段空间。释放ptr指向的空间要用 operator delete()，因为 delete会调用析构</code></pre><h1 id="可变参数模板"><a href="#可变参数模板" class="headerlink" title="可变参数模板"></a>可变参数模板</h1><blockquote><p>C++11的新特性可变参数模板能够创建可以接受可变参数的函数模板和类模板</p></blockquote><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202301021533875.png"></p><pre><code>我们把带省略号的参数称为“参数包”，它里面包含了0到N（N&gt;=0）个模版参数，比如args里面有三个参数包，这里需要注意，参数包里面的内容不能直接取出来。也不能用方括号直接访问</code></pre><p>可以用<strong>sizeof…(args)</strong> 计算参数包有几个参数。</p><h2 id="递归函数方式展开参数包"><a href="#递归函数方式展开参数包" class="headerlink" title="递归函数方式展开参数包"></a>递归函数方式展开参数包</h2><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202301021547497.png"></p><h2 id="逗号表达式展开参数包"><a href="#逗号表达式展开参数包" class="headerlink" title="逗号表达式展开参数包"></a>逗号表达式展开参数包</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintArg</span><span class="params">(<span class="type">const</span> T&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> ...Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShowList</span><span class="params">(Args... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> arr[] = &#123; (<span class="built_in">PrintArg</span>(args), <span class="number">0</span>)... &#125;;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">ShowList</span>(<span class="number">1</span>, <span class="string">&#x27;A&#x27;</span>, <span class="number">3.14</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>C++11的另外一个特性——初始化列表，通过初始化列表来初始化一个变长数组, &#123;(printarg(args), 0)...&#125;将会展开成((printarg(arg1),0),  (printarg(arg2),0), (printarg(arg3),0), etc... )，最终会创建一个元素值都为0的数组int arr[sizeof...(args)],也就是说在构造int数组的过程中就将参数包展开了，这个数组的目的纯粹是为了在数组构造的过程展开参数包</code></pre><p>也可以这样：</p><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/20230102160429.png"></p><h2 id="STL容器中的empalce相关接口函数"><a href="#STL容器中的empalce相关接口函数" class="headerlink" title="STL容器中的empalce相关接口函数"></a>STL容器中的empalce相关接口函数</h2><h2 id="push-back"><a href="#push-back" class="headerlink" title="push_back"></a>push_back</h2><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202301021616978.png"></p><p>下边这种场景，是一个构造加拷贝构造，或者构造加移动构造</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;pair&lt;bit::string, <span class="type">int</span>&gt;&gt; v;</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;sort&quot;</span>, <span class="number">1</span>));</span><br></pre></td></tr></table></figure><h2 id="emplace-back"><a href="#emplace-back" class="headerlink" title="emplace_back"></a>emplace_back</h2><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202301021617720.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v.<span class="built_in">emplace_back</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;sort&quot;</span>, <span class="number">1</span>));</span><br><span class="line">v.<span class="built_in">emplace_back</span>(<span class="string">&quot;sort&quot;</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202301021613445.png"></p><p>可以看到vector，测试两种方式没有区别，但是list测试，emplace_back更高效，因为只有一次构造，参数传递的参数包直接构造到List的节点上。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于内置类型来说，两种并无区别，对自定义类型来说，一些容器，比如list可以直接将参数包构造到容器的对象上面。更高效一些。</p><h1 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h1><blockquote><p>像函数使用的对象&#x2F;类型</p></blockquote><ol><li>函数指针</li><li>仿函数&#x2F;函数对象</li><li>lambda</li></ol><h2 id="lambda语法"><a href="#lambda语法" class="headerlink" title="lambda语法"></a>lambda语法</h2><blockquote><p>格式： [捕捉列表] (参数列表) mutable -&gt; 返回值类型 {函数体}</p></blockquote><p>来个例子：</p><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202301021646421.png"></p><p>看一下f的类型：</p><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202301021651018.png"></p><p>具体说明：</p><ul><li><strong>捕捉列表</strong>：译器根据 [] 来判断接下来的代码是否为lambda函数，捕捉列表能够捕捉上下文中的变量供lambda函数使用。</li><li><strong>参数列表</strong>：和普通函数列表一致，如果不需要参数传递可以省略()。</li><li><strong>mutable</strong> ：默认情况下，lambda函数总是一个const函数，mutable可以取消常量性，使用该修饰符时，不能省略()</li><li><strong>返回值类型</strong>：与常规函数一样，可以省略</li><li><strong>函数体</strong>：除了使用参数外，还可以使用捕捉的变量。</li></ul><p>注意：</p><p>在lambda函数定义中，<strong>参数列表和返回值类型都是可选部分，而捕捉列表和函数体可以为空</strong>，C++11中，最简单的lambda函数为：[] () ；该函数不能做任何事情，只是符合语法。</p><blockquote><p>看一个mutable的使用</p></blockquote><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202301021717343.png"></p><p>这里值捕获x和y，但是这个lambda默认是const的函数。修改了x和y所以会报错。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> swap3 = [x, y]()<span class="keyword">mutable</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> tmp = x;</span><br><span class="line">x = y;</span><br><span class="line">y = tmp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>加上mutable就可以，不过也没有起到交换的作用，因为是值捕捉。</p><h2 id="捕捉列表"><a href="#捕捉列表" class="headerlink" title="捕捉列表"></a>捕捉列表</h2><ul><li>[var]：表示值传递方式捕捉变量var  </li><li>[&#x3D;]：表示值传递方式捕获所有父作用域中的变量(包括this)  </li><li>[&amp;var]：表示引用传递捕捉变量var  </li><li>[&amp;]：表示引用传递捕捉所有父作用域中的变量(包括this)  </li><li>[this]：表示值传递方式捕捉当前的this指针</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> swap3 = [&amp;x, &amp;y]</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> tmp = x;</span><br><span class="line">x = y;</span><br><span class="line">y = tmp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一些常见用法看下边例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、生命周期（存储区域）</span></span><br><span class="line"><span class="comment">//2、作用域（编译器编译，用的地方能否找到）</span></span><br><span class="line"><span class="type">int</span> f = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a, b, c;</span><br><span class="line">a = b = c = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全部传值捕捉</span></span><br><span class="line"><span class="keyword">auto</span> f1 = [=]() &#123;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; b &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f1</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 混合捕捉</span></span><br><span class="line"><span class="keyword">auto</span> f2 = [=, &amp;a]() &#123;</span><br><span class="line">a++;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; b &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f2</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> f4 = [&amp;]()</span><br><span class="line">&#123;</span><br><span class="line">f++; <span class="comment">//没问题，可以捕捉全局变量</span></span><br><span class="line">x++; <span class="comment">//错误，x是静态变量，但是它的作用域是fun</span></span><br><span class="line">cout &lt;&lt; f &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f4</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="lambda底层细节"><a href="#lambda底层细节" class="headerlink" title="lambda底层细节"></a>lambda底层细节</h2><p>看一段代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rate</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Rate</span>(<span class="type">double</span> rate) : _rate(rate)</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">double</span> money, <span class="type">int</span> year)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> money * _rate * year;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">double</span> _rate;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">double</span> rate = <span class="number">0.49</span>;</span><br><span class="line"><span class="function">Rate <span class="title">r1</span><span class="params">(rate)</span></span>;</span><br><span class="line"><span class="built_in">r1</span>(<span class="number">10000</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> r2 = [=](<span class="type">double</span> monty, <span class="type">int</span> year)-&gt;<span class="type">double</span>&#123;<span class="keyword">return</span> monty*rate*year; &#125;;</span><br><span class="line"><span class="built_in">r2</span>(<span class="number">10000</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码r1是个函数对象，r2是lambda，转到反汇编看看，这两个的区别。</p><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202301032135781.png"></p><p>由上图可以看出，r1和r2都是调用了重载的方括号，实际在底层编译器对于lambda表达式的处理方式，完全就是按照函数对象的方式处理的，即：<strong>如果定义了一个lambda表达式，编译器会自动生成一个类，在该类中重载了operator()</strong></p><p>编译器生成了个类似下边的东西。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lambda_uuid</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">lambda_xxxx</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="包装器"><a href="#包装器" class="headerlink" title="包装器"></a>包装器</h1><h2 id="function包装器引入"><a href="#function包装器引入" class="headerlink" title="function包装器引入"></a>function包装器引入</h2><blockquote><p>function包装器 也叫作适配器。C++中的function本质是一个类模板，也是一个包装器。为什么需要function呢？可以看一个场景</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret = <span class="built_in">func</span>(x);</span><br></pre></td></tr></table></figure><p>func可能是函数名、函数指针、函数对象(仿函数对象)、也有可能<br>是lamber表达式对象，这些都有可能。</p><p>看个demo</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> F, <span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">useF</span><span class="params">(F f, T x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;count:&quot;</span> &lt;&lt; ++count &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;count:&quot;</span> &lt;&lt; &amp;count &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">f</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">f</span><span class="params">(<span class="type">double</span> i)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> i / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Functor</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">double</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> d / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 函数指针</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">useF</span>(f, <span class="number">11.11</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数对象</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">useF</span>(<span class="built_in">Functor</span>(), <span class="number">11.11</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lamber表达式对象</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">useF</span>([](<span class="type">double</span> d)-&gt;<span class="type">double</span>&#123; <span class="keyword">return</span> d / <span class="number">4</span>; &#125;, <span class="number">11.11</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>useF是个函数模板，依次将函数指针，函数对象，lambda传入，运行看一下</code></pre><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202301032203951.png"></p><p>可以看到静态变量count三次的地址都不一样，说明这个函数模板实例化出来三份代码。</p><p>我们上包装器：</p><h2 id="function包装器用法"><a href="#function包装器用法" class="headerlink" title="function包装器用法"></a>function包装器用法</h2><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202301032213439.png"></p><blockquote><p>function在在头文件 &lt; functional &gt;</p></blockquote><p>模板参数说明：  </p><ul><li>Ret: 被调用函数的返回类型  </li><li>Args…：被调用函数的形参</li></ul><p>我们改造上面的程序，用包装器包装起来。注意模板参数那里的写法，<strong>先是返回值类型然后小括号里面的参数列表的类型</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 函数指针</span></span><br><span class="line">function&lt;<span class="type">double</span>(<span class="type">double</span>)&gt; f1 = f;</span><br><span class="line">cout &lt;&lt; <span class="built_in">useF</span>(f1, <span class="number">11.11</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数对象</span></span><br><span class="line">function&lt;<span class="type">double</span>(<span class="type">double</span>)&gt; f2 = <span class="built_in">Functor</span>();</span><br><span class="line">cout &lt;&lt; <span class="built_in">useF</span>(f2, <span class="number">11.11</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lamber表达式对象</span></span><br><span class="line">function&lt;<span class="type">double</span>(<span class="type">double</span>)&gt; f3 = [](<span class="type">double</span> d)-&gt;<span class="type">double</span> &#123; <span class="keyword">return</span> d / <span class="number">4</span>; &#125;;</span><br><span class="line">cout &lt;&lt; <span class="built_in">useF</span>(f3, <span class="number">11.11</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看下运行结果</p><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202301032216604.png"></p><p>可以看到count的三个地址相同，说明只实例化出了一份代码。一定程度的解决模板效率低下，实例化多份的问题。</p><blockquote><p>用法注意：对于类的静态成员函数和普通成员函数用法的区别。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Plus</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">plusi</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">plusd</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; f1 = Plus::plusi;</span><br><span class="line"><span class="built_in">f1</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">function&lt;<span class="type">double</span>(Plus, <span class="type">double</span>, <span class="type">double</span>)&gt; f2 = &amp;Plus::plusd;</span><br><span class="line"><span class="built_in">f2</span>(<span class="built_in">Plus</span>(), <span class="number">1.1</span>, <span class="number">2.2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>静态成员函数只需要加域限定符即可，但是类的成员函数，不仅仅需要域限定符，调用成员函数，前面还需要加取地址的符号，参数列表要增加类名。</code></pre><p>普通的类成员函数包装又有了新的问题，同样以上方代码为例，两个功能类似的函数，包装器确不一样，这个可以解决吗？这时候就引入了我们的bind</p><h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202301032247071.png"></p><blockquote><p>std::bind是一个函数模板，它就像一个函数包装器(适配器)，接受一个可调用对象，生成一个新的可调用对象来“适应”原对象的参数列表。一般而言，我们用它可以把一个原本接收N个参数的函数fn，通过绑定一些参数，返回一个接收M个（M可以大于N，但这么做没什么意义）参数的新函数。同时，使用std::bind函数还可以实现参数顺序调整等操作</p></blockquote><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202301032248465.png"></p><pre><code> _1 _2.... 定义在placeholders命名空间中，代表绑定函数对象的形参， _1，_2...分别代表第一个形参、第二个形参...</code></pre><p>看个具体用法：</p><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202301032256943.png"></p><p>绑定后，形参的顺序得以改变（用处不是很大）</p><p>更实用的用法：调整个数，绑定死固定参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Div</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Plus</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Mul</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">double</span> rate)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a * b * rate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> placeholders;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; funcPlus = Plus;</span><br><span class="line"><span class="comment">//function&lt;int(Sub, int, int)&gt; funcSub = &amp;Sub::sub;</span></span><br><span class="line"><span class="comment">// 注意</span></span><br><span class="line">function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; funcSub = <span class="built_in">bind</span>(&amp;Sub::sub, <span class="built_in">Sub</span>(), _1, _2);</span><br><span class="line"><span class="comment">// 注意</span></span><br><span class="line">function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; funcMul = <span class="built_in">bind</span>(Mul, _1, _2, <span class="number">1.5</span>);</span><br><span class="line">map&lt;string, function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt;&gt; opFuncMap =</span><br><span class="line">&#123;</span><br><span class="line">&#123; <span class="string">&quot;+&quot;</span>, Plus&#125;,</span><br><span class="line">&#123; <span class="string">&quot;-&quot;</span>, <span class="built_in">bind</span>(&amp;Sub::sub, <span class="built_in">Sub</span>(), _1, _2)&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt;<span class="string">&quot;funcPlus(1, 2)=&quot;</span> &lt;&lt; <span class="built_in">funcPlus</span>(<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;funcSub(1, 2)=&quot;</span> &lt;&lt; <span class="built_in">funcSub</span>(<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt;<span class="string">&quot;funcMul(2, 2)=&quot;</span>&lt;&lt; <span class="built_in">funcMul</span>(<span class="number">2</span>, <span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt;<span class="string">&quot;opFuncMap[\&quot; + \&quot;](1, 2)=&quot;</span> &lt;&lt; opFuncMap[<span class="string">&quot;+&quot;</span>](<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;opFuncMap[\&quot; - \&quot;](1, 2)=&quot;</span> &lt;&lt; opFuncMap[<span class="string">&quot;-&quot;</span>](<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">2</span>, y = <span class="number">10</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Div(2,10)=&quot;</span> &lt;&lt; <span class="built_in">Div</span>(x, y) &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202301032307091.png"></p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/CPP/">CPP</category>
      
      
      <category domain="http://example.com/tags/C-11/">C++11</category>
      
      
      <comments>http://example.com/2023/01/03/CPP/C++11%EF%BC%88%E4%B8%8B%E7%AF%87%EF%BC%89/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>C++11（右值）</title>
      <link>http://example.com/2022/12/30/CPP/C++11(%E5%8F%B3%E5%80%BC)/</link>
      <guid>http://example.com/2022/12/30/CPP/C++11(%E5%8F%B3%E5%80%BC)/</guid>
      <pubDate>Fri, 30 Dec 2022 15:09:47 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;右值引用和移动语义&quot;&gt;&lt;a href=&quot;#右值引用和移动语义&quot; class=&quot;headerlink&quot; title=&quot;右值引用和移动语义&quot;&gt;&lt;/a&gt;右值引用和移动语义&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;传统的C++语法中就有引用的语法，而C++11中新增了的右</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="右值引用和移动语义"><a href="#右值引用和移动语义" class="headerlink" title="右值引用和移动语义"></a>右值引用和移动语义</h1><blockquote><p>传统的C++语法中就有引用的语法，而C++11中新增了的右值引用语法特性，所以从现在开始我们之前学习的引用就叫做左值引用。无论左值引用还是右值引用，都是给对象取别名。</p></blockquote><h2 id="右值引入"><a href="#右值引入" class="headerlink" title="右值引入"></a>右值引入</h2><blockquote><p>在以前我们知道有引用的语法，我们通常叫做左值引用，那么什么是左值呢？可以看下边的几个例子</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 左值：可以取它的地址</span></span><br><span class="line"><span class="comment">/*int a = 10;</span></span><br><span class="line"><span class="comment">const int b = 20;</span></span><br><span class="line"><span class="comment">int* p = &amp;a;</span></span><br><span class="line"><span class="comment">*p = 100;*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下的p、b、c、*p都是左值</span></span><br><span class="line"><span class="type">int</span>* p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">0</span>);</span><br><span class="line"><span class="type">int</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下几个是对上面左值的左值引用</span></span><br><span class="line"><span class="type">int</span>*&amp; rp = p;</span><br><span class="line"><span class="type">int</span>&amp; rb = b;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; rc = c;</span><br><span class="line"><span class="type">int</span>&amp; pvalue = *p;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> x = <span class="number">1.1</span>, y = <span class="number">2.2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，左值，<strong>可以获取它的地址+可以对它赋值</strong>。当然定义时用const修饰的左值，也不能对他赋值，但是可以<strong>取地址</strong>。左值引用呢，就是给左值的引用。</p><blockquote><p>知道左值后，那么什么是右值呢？右值的形式是什么？右值有什么实际价值？看几个例子</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 右值:不能取地址</span></span><br><span class="line"><span class="number">10</span>; </span><br><span class="line">x + y;</span><br><span class="line"><span class="built_in">fmin</span>(x, y);</span><br><span class="line"><span class="comment">//cout &lt;&lt; &amp;10 &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &amp;(x + y) &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下几个都是对右值的右值引用</span></span><br><span class="line"><span class="type">int</span>&amp;&amp; rr1 = <span class="number">10</span>;</span><br><span class="line"><span class="type">double</span>&amp;&amp; rr2 = x + y;</span><br><span class="line"><span class="type">double</span>&amp;&amp; rr3 = <span class="built_in">fmin</span>(x, y);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里编译会报错</span></span><br><span class="line"><span class="number">10</span> = <span class="number">1</span>;</span><br><span class="line">x + y = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">fmin</span>(x, y) = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上几个例子都是右值，右值也是一个表达数据的表达式，如字面常量、表达式返回值，函数返回值（这个不能是左值引用返回）等等，<strong>右值可以出现在赋值符号右边，但是不能出现在赋值符号的左边，右值不能取地址</strong>。</p><blockquote><p>右值引用就是对右值的引用，给右值取别名</p></blockquote><h2 id="左值右值"><a href="#左值右值" class="headerlink" title="左值右值"></a>左值右值</h2><blockquote><p>左值引用可以引用右值吗？右值引用可以引用右值吗？</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有条件的支持</span></span><br><span class="line"><span class="comment">// 左值引用可以引用右值吗？ const的左值引用可以</span></span><br><span class="line"><span class="comment">//double&amp; r1 = x + y;</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span>&amp; r1 = x + y;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 右值引用可以引用左值吗？可以引用move以后的左值</span></span><br><span class="line"><span class="comment">//int&amp;&amp; rr5 = b;</span></span><br><span class="line"><span class="type">int</span>&amp;&amp; rr5 = <span class="built_in">move</span>(b);</span><br></pre></td></tr></table></figure><p>这里注意：</p><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202212281629905.png"></p><p>11是字面常量，Func函数参数列表是个左值引用，所以会报错，两种修改方法：</p><ul><li>Func(const T&amp; x) </li><li>Func(T&amp;&amp; x)</li></ul><p>第一种方法：<strong>const的左值引用可以接收右值</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// x既能接收左值，也能接收右值</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">(<span class="type">const</span> T&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="左右值总结"><a href="#左右值总结" class="headerlink" title="左右值总结"></a>左右值总结</h2><h3 id="左值引用总结"><a href="#左值引用总结" class="headerlink" title="左值引用总结"></a>左值引用总结</h3><ol><li>左值引用只能引用左值。</li><li>但是const左值引用既可引用左值，也可引用右值。</li></ol><h3 id="右值引用总结"><a href="#右值引用总结" class="headerlink" title="右值引用总结"></a>右值引用总结</h3><ol><li>右值引用只能引用右值，不能引用左值</li><li>右值引用可以引用move之后的左值</li></ol><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202212301753811.png"></p><p>rr1和rr2可以取地址了，它们是左值了。</p><h2 id="左值的不足"><a href="#左值的不足" class="headerlink" title="左值的不足"></a>左值的不足</h2><blockquote><p>引用的价值：减少拷贝</p></blockquote><p>左值引用解决哪些问题？</p><ol><li>做参数。a、减少拷贝，提高效率  b、做输出型参数</li><li>做返回值。 a、减少拷贝，提高效率  b、引用返回，可以修改返回对象（比如：operator[]）</li></ol><p>但是，C++98的左值引用面向下边的场景很难进行处理：</p><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202212301937870.png"></p><p>右边的写法虽然解决了问题，但是并不是太符合使用习惯</p><h3 id="具体例子"><a href="#具体例子" class="headerlink" title="具体例子"></a>具体例子</h3><p>不加移动构造的string</p><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202212302010806.png"></p><p>加移动构造的string类</p><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202212302045284.png"></p><p>不加移动构造移动赋值的string</p><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202212302216855.png"></p><p>加移动构造移动赋值的string类</p><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202212302216109.png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>移动构造和移动赋值解决了传值返回这些类型对象的问题，STL的各个容器在C++11增加移动构造和移动赋值。移动构造本质是将参数右值的资源窃取过来，占位已有，那么就不用做深拷贝了，所以它叫做移动构造，就是窃取别人的资源来构造自己。</p><h1 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h1><h2 id="模板中-amp-amp-万能引用"><a href="#模板中-amp-amp-万能引用" class="headerlink" title="模板中&amp;&amp;万能引用"></a>模板中&amp;&amp;万能引用</h2><blockquote><p>在模板中，&amp;&amp;不代表右值引用，而是万能引用，其既能接收左值又能接收右值，但是引用类型的唯一作用就是限制了接收的类型，后续使用中都退化成了左值。</p></blockquote><p>先看个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Fun</span><span class="params">(<span class="type">int</span>&amp; x)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;左值引用&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Fun</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; x)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;const 左值引用&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Fun</span><span class="params">(<span class="type">int</span>&amp;&amp; x)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;右值引用&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Fun</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp;&amp; x)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;const 右值引用&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PerfectForward</span><span class="params">(T&amp;&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">Fun</span>(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">PerfectForward</span>(<span class="number">10</span>);           <span class="comment">// 右值</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="built_in">PerfectForward</span>(a);            <span class="comment">// 左值</span></span><br><span class="line"><span class="built_in">PerfectForward</span>(std::<span class="built_in">move</span>(a)); <span class="comment">// 右值</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> b = <span class="number">8</span>;</span><br><span class="line"><span class="built_in">PerfectForward</span>(b);      <span class="comment">// const 左值</span></span><br><span class="line"><span class="built_in">PerfectForward</span>(std::<span class="built_in">move</span>(b)); <span class="comment">// const 右值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在我们的预期中，Func函数应该是，左值打印左值，右值打印右值，但是运行结果确如下图所示：</p><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202212302231604.png"></p><p>这里可以看到，所有的都成了左值引用，根本没有调用右值引用的版本，这个就是<strong>引用折叠</strong>的问题。</p><h2 id="std-forward"><a href="#std-forward" class="headerlink" title="std::forward"></a>std::forward</h2><blockquote><p>我们希望能够在传递过程中保持它的左值或者右值的属性, 就需要用完美转发。</p></blockquote><p>针对上边的代码只需要将，T类型的参数t完美转发一下就可以了，<strong>std::forward 完美转发在传参的过程中保留对象原生类型属性</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PerfectForward</span><span class="params">(T&amp;&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">Fun</span>(std::forward&lt;T&gt;(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202212302243796.png"></p><p>可以看到完美转发的效果，左值调用左值，右值调用右值。</p><h2 id="实际应用例子"><a href="#实际应用例子" class="headerlink" title="实际应用例子"></a>实际应用例子</h2><p>在我们模拟实现的list中测试，移动构造</p><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202212302252471.png"></p><p>list插入”world”（右值），代码调用层级如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(T&amp;&amp; x)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">insert</span>(<span class="built_in">end</span>(), std::forward&lt;T&gt;(x)); <span class="comment">//完美转发保留右值属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用insert，这里也是万能引用接收</span></span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator pos, T&amp;&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Node* cur = pos._node;</span><br><span class="line">Node* prev = cur-&gt;_prev;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里调用节点的构造函数，也同样要完美转发，保留右值属性</span></span><br><span class="line">Node* newnode = <span class="keyword">new</span> <span class="built_in">Node</span>(std::forward&lt;T&gt;(x)); </span><br><span class="line"></span><br><span class="line"><span class="comment">// prev newnode cur</span></span><br><span class="line">prev-&gt;_next = newnode;</span><br><span class="line">newnode-&gt;_prev = prev;</span><br><span class="line">newnode-&gt;_next = cur;</span><br><span class="line">cur-&gt;_prev = newnode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">iterator</span>(newnode);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// insert调用了链表节点的构造，同样用万能引用接收</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">list_node</span>(T&amp;&amp; x)</span><br><span class="line">:_data(std::forward&lt;T&gt;(x))  <span class="comment">//完美转发</span></span><br><span class="line">, _next(<span class="literal">nullptr</span>)</span><br><span class="line">, _prev(<span class="literal">nullptr</span>)</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><p>最后的节点的构造，会调用string类的构造，所以那里同样需要完美转发，调用了string类的右值构造</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>(string&amp;&amp; s)</span><br><span class="line">:_str(<span class="literal">nullptr</span>)</span><br><span class="line">, _size(<span class="number">0</span>)</span><br><span class="line">, _capacity(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;string(string&amp;&amp; s) -- 资源转移&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">swap</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/CPP/">CPP</category>
      
      
      <category domain="http://example.com/tags/C-11/">C++11</category>
      
      
      <comments>http://example.com/2022/12/30/CPP/C++11(%E5%8F%B3%E5%80%BC)/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
