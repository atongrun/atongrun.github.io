<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>孙菜菜</title>
    <link>https://atong.run/</link>
    
    <atom:link href="https://atong.run/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>万千不如意，睡得着就过得去</description>
    <pubDate>Tue, 14 Feb 2023 05:42:46 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>7、高并发内存池-释放内存</title>
      <link>https://atong.run/posts/3511365265/</link>
      <guid>https://atong.run/posts/3511365265/</guid>
      <pubDate>Tue, 14 Feb 2023 05:41:56 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;前面几个章节，详细说明了thread cache、central cache、page cache层的结构以及申请内存的逻辑。本节就是讲述回收内存的过程，大致分为下边几步：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;thread cac</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>前面几个章节，详细说明了thread cache、central cache、page cache层的结构以及申请内存的逻辑。本节就是讲述回收内存的过程，大致分为下边几步：</p></blockquote><ul><li>thread cache挂的自由链表过长，将内存释放回central cache</li><li>central cache管理的span的内存块全部回来后，将span释放回page cache</li><li>page cache合并前后相邻的空闲页</li></ul><h1>ThreadCache层回收内存</h1><blockquote><p>当线程释放内存块时，直接将内存块挂到相应的ThreadCache的自由链表，当自由链表的长度达到thread cache层向central cache层申请内存的一个批量的大小我们就进行释放，也就是到MaxSize（慢增长记录）</p></blockquote><pre><code>这里注意，我们增加了FreeList成员_size，并提供了返回它大小的函数Size</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 释放内存</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadCache::Deallocate</span><span class="params">(<span class="type">void</span>* obj, <span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(obj);</span><br><span class="line"><span class="built_in">assert</span>(size &lt;= MAX_BYTES);</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> index = SizeClass::<span class="built_in">Index</span>(size);</span><br><span class="line">_freeLists[index].<span class="built_in">Push</span>(obj);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果自由链表的长度大于申请一个批量的长度就还给central cache </span></span><br><span class="line"><span class="keyword">if</span> (_freeLists[index].<span class="built_in">Size</span>() &gt;= _freeLists[index].<span class="built_in">MaxSize</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">ListTooLong</span>(_freeLists[index], size);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>高并发内存池，ConcurrentDealloc释放内存，内部调用thread cache层的Deallocate函数，Deallocate函数内部调用ListTooLong去处理长链表归还给central cache层</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadCache::ListTooLong</span><span class="params">(FreeList&amp; list, <span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">void</span>* start = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="type">void</span>* end = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先将MaxSize长度的内存，从thread cache层释放出来</span></span><br><span class="line">list.<span class="built_in">PopRange</span>(start, end, list.<span class="built_in">MaxSize</span>());</span><br><span class="line"></span><br><span class="line">CentralCache::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">ReleaseListToSpans</span>(start, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们需要先调用PopRange释放挂在自由链表MaxSize长度（这个之前未实现），然后调用CentralCache层ReleaseListToSpans，来回收这段内存，接下来的工作交给CentralCache层进行处理</p><h1>CentralCache层回收内存</h1><blockquote><p>thread cache层归还回了一段内存，这里就会有一个问题，我们直到Central Cache层的哈希桶结构和映射规则与thread cache层相同，但是central cache层挂的是一个个的span对象，那么这一段内存，应该归还给某个桶的哪个span对象呢？</p></blockquote><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202302131526327.png" alt="image.png"></p><p>在page cache中，申请内存都是按页申请，那么这一页内存到下一页的任何一个地址，右移PAGE_SHIFT位都是这页内存的页号。比如下图的例子，我们就以通过地址来算这块内存应该在那一页，然后去找到对应的span，但是现在我们没办法找到</p><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202302132255489.png" alt="image.png"></p><blockquote><p>为了能通过页号，找到对应span的地址，我们可以建立一个哈希表，映射关系为page_id号和对应span的指针，我们在PageCache类中增加一个哈希表，PageCache层也会用到</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::unordered_map&lt;PAGE_ID, Span*&gt; _idSpanMap;</span><br></pre></td></tr></table></figure><p>这时候就需要记录页号和span* 的对应关系，PageCache的NewSpan函数，返回一个span，我们需要在这个函数里增加相关代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存储nSpan的首尾页跟nSpan建立映射，方便page cache回收内存</span></span><br><span class="line"></span><br><span class="line">_idSpanMap[nSpan-&gt;_pageId] = nSpan;</span><br><span class="line">_idSpanMap[nSpan-&gt;_pageId + nSpan-&gt;_n - <span class="number">1</span>] = nSpan;  <span class="comment">//原理如下图</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回的kSpan，也要建立id和span的映射，方便central cache回收小块内存时，查找对应的span</span></span><br><span class="line"><span class="comment">// 给central层返回的span，会被切分成小块内存，归还的时候地址换成页号就可能是其中的某一页</span></span><br><span class="line"><span class="keyword">for</span> (PAGE_ID i = <span class="number">0</span>; i &lt; kSpan-&gt;_n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">_idSpanMap[kSpan-&gt;_pageId + i] = kSpan;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202302132221620.png" alt="image.png"></p><blockquote><p>记录完映射关系之后，可以继续在封装一个函数，功能就是给我一个地址，我就返回它应该所在的span的地址</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取对象到span的映射</span></span><br><span class="line"><span class="function">Span* <span class="title">PageCache::MapObjectToSpan</span><span class="params">(<span class="type">void</span>* obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">PAGE_ID id = ((PAGE_ID)obj &gt;&gt; PAGE_SHITF);</span><br><span class="line"><span class="keyword">if</span> (_idSpanMap.<span class="built_in">find</span>(id) != _idSpanMap.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _idSpanMap[id];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">assert</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上边前置工作做完之后，可以写ReleaseListToSpans函数了，大致分为以下几点：</p></blockquote><ol><li>通过起始地址，不断向后走，找到对应的span，然后头插进span的自由链表</li><li>让对应的span的_useCount，当减到0说明，这个span的所有内存块都回来了，该span可以被回收</li><li>从spanlist中将对应的span删除掉，然后让pagecache回收</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CentralCache::ReleaseListToSpans</span><span class="params">(<span class="type">void</span>* start, <span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">size_t</span> index = SizeClass::<span class="built_in">Index</span>(size);</span><br><span class="line"></span><br><span class="line">_spanLists[index]._mtx.<span class="built_in">lock</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 问题：换回来的内存挂到哪个span上？</span></span><br><span class="line"><span class="comment">// 通过地址 start&gt;&gt;PAGE_SHIFT，就是span的页号，为了方便，我们可以建立页号和span指针的映射</span></span><br><span class="line"><span class="comment">// 这里可以通过哈希表做- unordered_map&lt;PAGE_ID, Span*&gt; </span></span><br><span class="line"><span class="keyword">while</span> (start)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">void</span>* next = <span class="built_in">NextObj</span>(start);</span><br><span class="line">Span* span = PageCache::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">MapObjectToSpan</span>(start);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 头插进span的管理的链表</span></span><br><span class="line"><span class="built_in">NextObj</span>(start) = span-&gt;_freeList;</span><br><span class="line">span-&gt;_freeList = start;</span><br><span class="line"></span><br><span class="line">span-&gt;_useCount--;</span><br><span class="line"></span><br><span class="line"><span class="comment">// span切分回去的小块内存都回来了</span></span><br><span class="line"><span class="comment">// 将这个span 回收给page cache</span></span><br><span class="line"><span class="keyword">if</span> (span-&gt;_useCount == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">_spanLists[index].<span class="built_in">Erase</span>(span);</span><br><span class="line">span-&gt;_next = <span class="literal">nullptr</span>;</span><br><span class="line">span-&gt;_next = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="comment">// span管理内存，通过页号和页数就可以</span></span><br><span class="line">span-&gt;_freeList = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">_spanLists[index]._mtx.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">PageCache::<span class="built_in">GetInstance</span>()-&gt;_pageMtx.<span class="built_in">lock</span>();</span><br><span class="line">PageCache::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">ReleaseSpanToPageCache</span>(span);</span><br><span class="line"></span><br><span class="line">PageCache::<span class="built_in">GetInstance</span>()-&gt;_pageMtx.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">_spanLists[index]._mtx.<span class="built_in">lock</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">start = next;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//解锁</span></span><br><span class="line">_spanLists[index]._mtx.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>PageCache层回收内存</h1><blockquote><p>page cache就回收span，并且合并相邻的span，可以向前合并也可以向后合并，但是合并有个问题：只能合并没有用的span，如果有的span正在被用就不能合并，大致步骤如下：</p></blockquote><p>首先判断span是否被使用？我们在Span类中增加成员，判断该span对象有没有被使用，默认是没有被使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> _isUse = <span class="literal">false</span>; <span class="comment">//是否被使用</span></span><br></pre></td></tr></table></figure><p>在Central Cache层中我们向PageCache申请新的span，这时需要将isUse改成true，标识这个span被用了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们要计算向page cache层要多少页的span</span></span><br><span class="line">Span* span = PageCache::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">NewSpan</span>(SizeClass::<span class="built_in">NumMovePage</span>(size));</span><br><span class="line">span-&gt;_isUse = <span class="literal">true</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后就是向前向后合并span，需要注意：</p><ul><li>当合并到头了就不再合并了</li><li>前后的页有被使用的也不合并</li><li>合并的长度已经超过128也不再进行合并</li></ul><blockquote><p>向前合并逻辑</p></blockquote><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202302140054029.png" alt="image.png"></p><blockquote><p>向后合并逻辑</p></blockquote><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202302140100674.png" alt="image.png"></p><blockquote><p>整体代码</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 释放空闲span回到PageCache，并合并相邻的span</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PageCache::ReleaseSpanToPageCache</span><span class="params">(Span* span)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 合并相邻的span，向前合并，有问题：前面的span如果被用就不能进行合并</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">PAGE_ID prevId = span-&gt;_pageId - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> ret = _idSpanMap.<span class="built_in">find</span>(prevId);</span><br><span class="line"><span class="comment">//前边的页号没有了就不和并了</span></span><br><span class="line"><span class="keyword">if</span> (ret == _idSpanMap.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前边相邻页在使用，不合并</span></span><br><span class="line">Span* prevSpan = ret-&gt;second;</span><br><span class="line"><span class="keyword">if</span> (prevSpan-&gt;_isUse == <span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//超过128页的span也不合并</span></span><br><span class="line"><span class="keyword">if</span> (prevSpan-&gt;_n + span-&gt;_n &gt; NPAGES - <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进入合并的逻辑</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//span-&gt;_pageId -= prevSpan-&gt;_n;</span></span><br><span class="line">span-&gt;_pageId = prevSpan-&gt;_pageId;</span><br><span class="line">span-&gt;_n += prevSpan-&gt;_n;</span><br><span class="line"></span><br><span class="line">_spanLists[prevSpan-&gt;_n].<span class="built_in">Erase</span>(prevSpan);</span><br><span class="line"><span class="keyword">delete</span> prevSpan;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">PAGE_ID nextID = span-&gt;_pageId + span-&gt;_n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> ret = _idSpanMap.<span class="built_in">find</span>(nextID);</span><br><span class="line"><span class="keyword">if</span> (ret == _idSpanMap.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Span* nextSpan = ret-&gt;second;</span><br><span class="line"><span class="keyword">if</span> (nextSpan-&gt;_isUse == <span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//超过128页的span也不合并</span></span><br><span class="line"><span class="keyword">if</span> (nextSpan-&gt;_n + span-&gt;_n &gt; NPAGES - <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">span-&gt;_n += nextSpan-&gt;_n;</span><br><span class="line"></span><br><span class="line">_spanLists[nextSpan-&gt;_n].<span class="built_in">Erase</span>(nextSpan);</span><br><span class="line"><span class="keyword">delete</span> nextSpan;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">_spanLists[span-&gt;_n].<span class="built_in">PushFront</span>(span);</span><br><span class="line">span-&gt;_isUse = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">_idSpanMap[span-&gt;_pageId] = span;</span><br><span class="line">_idSpanMap[span-&gt;_pageId + span-&gt;_n - <span class="number">1</span>] = span;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://atong.run/categories/%E9%A1%B9%E7%9B%AE/">项目</category>
      
      <category domain="https://atong.run/categories/%E9%A1%B9%E7%9B%AE/%E9%AB%98%E5%B9%B6%E5%8F%91%E5%86%85%E5%AD%98%E6%B1%A0/">高并发内存池</category>
      
      
      <category domain="https://atong.run/tags/%E9%A1%B9%E7%9B%AE/">项目</category>
      
      
      <comments>https://atong.run/posts/3511365265/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>obsidian纯粹版插件推荐</title>
      <link>https://atong.run/posts/3017994336/</link>
      <guid>https://atong.run/posts/3017994336/</guid>
      <pubDate>Sun, 12 Feb 2023 14:24:55 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;只是单纯的记笔记而不是想要all in one，建议别看太多教程，否则你折腾这个软件的功夫很有可能大于你记笔记的功夫（无聊玩随意），如果想要单纯的获得纯粹点的markdown记笔记往下看。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;一、主题篇&quot;&gt;一、主题篇&lt;/h2&gt;
&lt;blockq</description>
        
      
      
      
      <content:encoded><![CDATA[<p>只是单纯的记笔记而不是想要all in one，建议别看太多教程，否则你折腾这个软件的功夫很有可能大于你记笔记的功夫（无聊玩随意），如果想要单纯的获得纯粹点的markdown记笔记往下看。</p><hr><h2 id="一、主题篇">一、主题篇</h2><blockquote><p>适当折腾</p></blockquote><p>建议直接默认即可，默认风格和github README、各种博客平台，无太多美化的个人博客风格差不多，分享时不会差太大。</p><h2 id="二、插件篇">二、插件篇</h2><blockquote><p>少折腾，这里推荐5个，能够带来最单纯简单的使用markdown的体验，大家谨记折腾软件的功夫一定不要大于记笔记的功夫</p></blockquote><h3 id="插件1、Recent-Files">插件1、Recent Files</h3><blockquote><p>这个插件很实用，能看最近打开的文章</p></blockquote><p><img src="https://picx.zhimg.com/80/v2-2a43b3c2f87a0b4e2a0218a404be60e7_1440w.png" alt=""></p><h3 id="插件2、File-Explorer-Note-Count">插件2、File Explorer Note Count</h3><blockquote><p>能显示文件夹下边有几个文件</p></blockquote><p><img src="https://picx.zhimg.com/80/v2-c1070e27a0147824c27ff31952d04a79_1440w.png" alt=""></p><p>​</p><h3 id="插件3、Editing-Toolbar">插件3、Editing Toolbar</h3><blockquote><p>非常实用，将常见的markdown功能，集成为一个小工具条，类似word的上边工具栏</p></blockquote><p><img src="https://picx.zhimg.com/80/v2-6e1c7066841550a84593ef45432964f3_1440w.png" alt=""></p><p>​</p><h3 id="插件4、Advanced-Tables">插件4、Advanced Tables</h3><blockquote><p>obsidian的markdown表格比较难打，这个是增强输入表格功能的插件，只要输入一个 | 加内容然后配合回车和tab键，就可以很方便的搞出来表格，当然它也带了工具栏</p></blockquote><p><img src="https://pic1.zhimg.com/80/v2-46d5ca49fae211260e450719d7bf198f_1440w.png" alt=""></p><p>​</p><h3 id="插件5、Image-Auto-Upload-Plugin">插件5、Image Auto Upload Plugin</h3><blockquote><p>使用markdown图床肯定很重要，我们肯定期望复制图片到笔记软件，图片就能自动上传到图床，然后笔记软件里面有链接，很幸运的是obsidian里面有这个插件，和PicGo配合就可以做到啦，非常方便</p></blockquote><p><img src="https://picx.zhimg.com/80/v2-b6b604e116dc13364e87b1164c0ef1b0_1440w.png" alt=""></p><p>​</p><p><a href="https://post.smzdm.com/p/az6mokvo/">Obsidian和picgo图片自动上传图床教程</a></p><h2 id="三、总结">三、总结</h2><p>切记，记笔记才是正道，别入了折腾软件的坑，然后如果嫌弃obsidian下载插件的网络问题，可以关注我的公众号【孙菜菜】回复 【obsidian】可以获得上边的五个插件。</p><p><img src="https://pica.zhimg.com/80/v2-46fe8b8c98beb6661c01f6443788299b_1440w.png" alt=""></p><p>这几个文件直接拷贝到 你的仓库路径下 \ .obsidian \ plugins里面即可。</p>]]></content:encoded>
      
      
      <category domain="https://atong.run/categories/%E5%B7%A5%E5%85%B7/">工具</category>
      
      <category domain="https://atong.run/categories/%E5%B7%A5%E5%85%B7/obsidian/">obsidian</category>
      
      
      <category domain="https://atong.run/tags/%E7%AC%94%E8%AE%B0/">笔记</category>
      
      
      <comments>https://atong.run/posts/3017994336/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>6、高并发内存池-PageCache</title>
      <link>https://atong.run/posts/2890609329/</link>
      <guid>https://atong.run/posts/2890609329/</guid>
      <pubDate>Fri, 10 Feb 2023 15:16:52 GMT</pubDate>
      
        
        
      <description>&lt;h1&gt;框架结构&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;central cache对应的桶里如果没有span对象，需要向page cache层申请一个非空的span，page cache也是哈希桶的结构，同样通过双向链表组织一个个的span对象，但是映射规则和thread c</description>
        
      
      
      
      <content:encoded><![CDATA[<h1>框架结构</h1><blockquote><p>central cache对应的桶里如果没有span对象，需要向page cache层申请一个非空的span，page cache也是哈希桶的结构，同样通过双向链表组织一个个的span对象，但是映射规则和thread cache和central cache层不同，page cache的逻辑抽象结构如下：</p></blockquote><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202302101543881.png" alt="33250a692c214c8286b38ba3c6c96847.png"></p><pre><code>page cache采用直接定址法，几号桶就是挂的几页的span，pageche的span对象是按页为单位，并没有切分成小对象，central cache会申请固定页数的span，然后进行切分</code></pre><h1>具体实现</h1><h2 id="page-cahe-类">page cahe 类</h2><blockquote><p>page cache 这里设计span最多有128页（128 * 8 * 1024 = 1m），也可以有设计成其他大小，我们设计的thread cahche层最大申请256kb的对象，128页能切成4个，然后我们让几号桶对应几页的span，为了方便整个page cache类设计为129个桶，空出来0号桶</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// page cache桶的个数 - 这里设置为129个，0号桶不用</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">size_t</span> NPAGES = <span class="number">129</span>;</span><br></pre></td></tr></table></figure><blockquote><p>page cahce类在整个进程里只有一个，我们同样设计成单例模式，这里需要注意的是，多个线程申请对象，thread cache层没有内存需要向central cache申请，central cache只需要加桶锁就可以，但是page cache最好整个加锁，因为page cache可能涉及到多页的span切分的问题，并且当central cache归还span，page cache也会尝试将该span和其他桶的span进行合并，这样就会访问page cache的多个桶，造成频繁的加锁和解锁。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PageCache</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//整个进程只有一份，同样设计成单例模式</span></span><br><span class="line"><span class="function"><span class="type">static</span> PageCache* <span class="title">GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> &amp;_sInst;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 要一个k页的span</span></span><br><span class="line"><span class="function">Span* <span class="title">NewSpan</span><span class="params">(<span class="type">size_t</span> k)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">std::mutex _pageMtx;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">PageCache</span>() &#123;&#125;;</span><br><span class="line"><span class="built_in">PageCache</span>(<span class="type">const</span> PageCache&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">SpanList _spanLists[NPAGES];</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> PageCache _sInst;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>类内提供一个获取k页span的接口</p></blockquote><h2 id="实现逻辑">实现逻辑</h2><blockquote><p>我们先继续完善central层的逻辑，上节说从中心缓存获取一定数量的对象给thread cache，用了一个FatchRangeObj的函数，这个函数的内部，首先要保证CentralCache层有一个非空的span，那么如何保证有一个非空的span呢？大致思路是先从central cache对应的桶里找，如果没有就往下找Page Cache层要。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取一个非空的span</span></span><br><span class="line"><span class="function">Span* <span class="title">CentralCache::GetOneSpan</span><span class="params">(SpanList&amp; list, <span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>我们继续完善这个函数</code></pre><blockquote><p>步骤1、先去size 对应的桶里找非空的span，这里涉及到链表的遍历操作，我们可以完善一下SpanList类，提供相应的接口方便我们操作</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在spanlist类中增加一下函数，方便遍历操作</span></span><br><span class="line"><span class="function">Span* <span class="title">Begin</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _head-&gt;_next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Span* <span class="title">End</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Empty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _head == _head-&gt;_next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>步骤2、若有非空的span直接返回，如果没有，需要向下一层的PageCache申请新的一页Span，这里我们涉及到加锁、解锁过程，以及如果向下一层申请SPan具体是要多个少页呢？</p></blockquote><pre><code>我们可以先解决要多少页的问题，在SizeClass类中增加NumMovePage函数</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算一次向系统获取多少个页</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">size_t</span> <span class="title">NumMovePage</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 先获取申请size对象大小的上限(尽可能多要一些)</span></span><br><span class="line"><span class="type">size_t</span> num = <span class="built_in">NumMoveSize</span>(size);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 算一下num个对象总共多少字节，然后右移13位就是多少页</span></span><br><span class="line"><span class="type">size_t</span> npage = (num * size) &gt;&gt; PAGE_SHITF;</span><br><span class="line"><span class="comment">// 最少申请1页</span></span><br><span class="line"><span class="keyword">if</span> (npage == <span class="number">0</span>)</span><br><span class="line">npage = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> npage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>步骤3、申请完span后，就要将里面的大块内存进行切分，我们需要直到大块内存的起始地址和结束地址，不断的切成size大小进行尾插，这里尾插有个好处，它的物理地址是连续的，当被线程使用时，可以提高线程的CPU缓存利用率</p></blockquote><blockquote><p>GetOneSpan整体代码</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取一个非空的span</span></span><br><span class="line"><span class="function">Span* <span class="title">CentralCache::GetOneSpan</span><span class="params">(SpanList&amp; list, <span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 1、先去size 对应的桶里找非空的span</span></span><br><span class="line">Span* it = list.<span class="built_in">Begin</span>();</span><br><span class="line"><span class="keyword">while</span> (it != list.<span class="built_in">End</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (it-&gt;_freeList != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> it;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">it = it-&gt;_next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里可以先将这个桶的桶锁进行解锁，其他线程可以释放内存对象回来不会阻塞</span></span><br><span class="line">list._mtx.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 到这里说明，size对应的CentralCache层里面没有Span对象，那么需要向下一层申请</span></span><br><span class="line"><span class="comment">// 先进行整个page cache层的加锁</span></span><br><span class="line">PageCache::<span class="built_in">GetInstance</span>()-&gt;_pageMtx.<span class="built_in">lock</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们要计算向page cache层要多少页的span</span></span><br><span class="line">Span* span = PageCache::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">NewSpan</span>(SizeClass::<span class="built_in">NumMovePage</span>(size));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解锁</span></span><br><span class="line">PageCache::<span class="built_in">GetInstance</span>()-&gt;_pageMtx.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 申请回来的span对象进行切分，这会不需要加锁，因为这会其他线程访问不到这个span（还没挂到spanLists）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 要计算span的大块内存的起始地址和大块内存的大小</span></span><br><span class="line"><span class="comment">// 页号左移PAGE_SHIFT就是地址</span></span><br><span class="line"><span class="type">char</span>* start = (<span class="type">char</span>*)(span-&gt;_pageId &lt;&lt; PAGE_SHITF);</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> bytes = span-&gt;_n &lt;&lt; PAGE_SHITF;</span><br><span class="line"><span class="type">char</span>* end = start + bytes;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 先切一块做头</span></span><br><span class="line">span-&gt;_freeList = start;</span><br><span class="line">start += size;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进行尾插</span></span><br><span class="line"><span class="type">void</span>* tail = span-&gt;_freeList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(start &lt;end)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">NextObj</span>(tail) = start;</span><br><span class="line">tail = <span class="built_in">NextObj</span>(tail);</span><br><span class="line">start += size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 切好span，将span挂到桶里，加锁</span></span><br><span class="line">list._mtx.<span class="built_in">lock</span>();</span><br><span class="line">list.<span class="built_in">PushFront</span>(span);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> span;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>完成上边的代码后我们看看底层的PageCache::NewSpan(size_t k) ，我们这个获取一个NewSpan的大致逻辑为：首先检查第k个桶里有没有span，如果没有，向后边的桶找更大的Span，然后分成k和n-k，返回k页的Span，n-k页的Span挂到相应的桶里</p></blockquote><hr><blockquote><p>步骤1、判断k个桶有没有span如果有，返回头上那个，这时候需要在在SpanList类里面提供一个PopFront函数，同时我们也提供一个PushFront的函数，方便之后的操作</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头删返回</span></span><br><span class="line"><span class="function">Span* <span class="title">PopFront</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Span* sp = _head-&gt;_next;</span><br><span class="line"><span class="comment">/*head-&gt;_next = sp-&gt;_next;</span></span><br><span class="line"><span class="comment">sp-&gt;_next = nullptr;</span></span><br><span class="line"><span class="comment">return sp;*/</span></span><br><span class="line"><span class="built_in">Erase</span>(sp);</span><br><span class="line"><span class="keyword">return</span> sp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 头插</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PushFront</span><span class="params">(Span* span)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">Insert</span>(<span class="built_in">Begin</span>(), span);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>步骤2、如果没有，遍历后面的桶，如果有，就切成k和n-k，返回k页的span，n-k页的span插入到对应的桶</p></blockquote><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202302102055998.png" alt="image.png"></p><blockquote><p>步骤3、如果从k+1到NPAGES-1桶都没有span，那么只能通过系统调用向堆申请，这里直接申请128页的span，申请成功后，还是走步骤2的逻辑，可以直接递归处理</p></blockquote><blockquote><p>整体代码</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// page cache 返回一个span</span></span><br><span class="line"><span class="function">Span* <span class="title">PageCache::NewSpan</span><span class="params">(<span class="type">size_t</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 先断言一下</span></span><br><span class="line"><span class="built_in">assert</span>(k &gt; <span class="number">0</span> &amp;&amp; k &lt; NPAGES);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先检查第k个桶里有没有Span</span></span><br><span class="line"><span class="keyword">if</span> (!_spanLists[k].<span class="built_in">Empty</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 头删第一个返回这里去实现PopFront的逻辑</span></span><br><span class="line"><span class="keyword">return</span> _spanLists[k].<span class="built_in">PopFront</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果k号桶为空，检查后面的桶，找到一个非空桶，直到最后一个桶</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = k + <span class="number">1</span>; i &lt; NPAGES; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!_spanLists[i].<span class="built_in">Empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">Span* nSpan = _spanLists[i].<span class="built_in">PopFront</span>();</span><br><span class="line"><span class="comment">// ？</span></span><br><span class="line">Span* kSpan = <span class="keyword">new</span> Span;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分成npan 分一个 k页返回，然后n-k页的span挂到n-k的桶上</span></span><br><span class="line"><span class="comment">// 这里注意，只需要改页号和页数就可以了，span挂的内存的地址按页号取</span></span><br><span class="line">kSpan-&gt;_pageId = nSpan-&gt;_pageId;</span><br><span class="line">kSpan-&gt;_n = k;</span><br><span class="line"></span><br><span class="line">nSpan-&gt;_n -= k;</span><br><span class="line">nSpan-&gt;_pageId += k;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">_spanLists[nSpan-&gt;_n].<span class="built_in">PushFront</span>(nSpan);</span><br><span class="line"><span class="keyword">return</span> kSpan;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 到这里说明后面的所有位置都没有大页的span</span></span><br><span class="line"><span class="comment">// 这时候就需要向堆申请一个128页的span</span></span><br><span class="line">Span* bigSpan = <span class="keyword">new</span> Span;</span><br><span class="line"><span class="type">void</span>* ptr = <span class="built_in">SystemAlloc</span>(NPAGES<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bigSpan-&gt;_n = NPAGES - <span class="number">1</span>;</span><br><span class="line">bigSpan-&gt;_pageId = (PAGE_ID)ptr &gt;&gt; PAGE_SHITF;</span><br><span class="line"></span><br><span class="line">_spanLists[bigSpan-&gt;_n].<span class="built_in">PushFront</span>(bigSpan);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">NewSpan</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>这里注意最后几句的逻辑，我们申请了128页的内存，返回了起始的指针ptr，将这个地址转成整形，右移PAGE_SHIFT位，相当于除以2^13，就是管理这块大块内存的span的页号</p></blockquote><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202302102010347.png" alt="image.png"></p>]]></content:encoded>
      
      
      <category domain="https://atong.run/categories/%E9%A1%B9%E7%9B%AE/">项目</category>
      
      <category domain="https://atong.run/categories/%E9%A1%B9%E7%9B%AE/%E9%AB%98%E5%B9%B6%E5%8F%91%E5%86%85%E5%AD%98%E6%B1%A0/">高并发内存池</category>
      
      
      <category domain="https://atong.run/tags/%E9%A1%B9%E7%9B%AE/">项目</category>
      
      
      <comments>https://atong.run/posts/2890609329/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>5、高并发内存池-CentralCache</title>
      <link>https://atong.run/posts/1806624746/</link>
      <guid>https://atong.run/posts/1806624746/</guid>
      <pubDate>Wed, 08 Feb 2023 15:12:01 GMT</pubDate>
      
        
        
      <description>&lt;h1&gt;Central Cache框架设计&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;当申请对象时，thread cache层对应的自由链表为空时，需要向central cache层申请内存。central cache层框架图如下：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;i</description>
        
      
      
      
      <content:encoded><![CDATA[<h1>Central Cache框架设计</h1><blockquote><p>当申请对象时，thread cache层对应的自由链表为空时，需要向central cache层申请内存。central cache层框架图如下：</p></blockquote><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202302081948813.png" alt="9d6481a02fe24f458b37909674fc3d66.png"></p><p>central cache整体也是一个哈希桶结构，类似于thread cache层，但是central cache层所挂的是span的链表</p><ul><li>span是管理大块内存的数据结构，页为单位</li><li>span里面有个自由链表，管理切割出来的小内存块</li><li>映射关系和对齐规则同thread cache</li></ul><h1>Central Cache具体结构</h1><h2 id="span结构">span结构</h2><blockquote><p>span是管理多个连续页大块内存的跨度结构，具体结构代码如下；</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Span</span></span><br><span class="line">&#123;</span><br><span class="line">PAGE_ID _pageId = <span class="number">0</span>; <span class="comment">//大块内存起始页的页号</span></span><br><span class="line"><span class="type">size_t</span> _n = <span class="number">0</span>; <span class="comment">//页的数量</span></span><br><span class="line"></span><br><span class="line">Span* _next = <span class="literal">nullptr</span>; <span class="comment">//双向链表的结构</span></span><br><span class="line">Span* _prev = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> _useCount = <span class="number">0</span>; <span class="comment">//切好的小块内存，被分配给thread cache的计数</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* _freeList =<span class="literal">nullptr</span>; <span class="comment">//切好小块内存的自由链表</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>首先需要注意的是，span是双向链表的结构，双向链表删除元素非常方便，当将某个span对象归还给page cache层时，双向链表删除非常简单</p><blockquote><p>span是管理以页为单位的大块内存，当归还给page cache层时，为了方便相邻页的合并需要一个页号 pageID，我们用了typedef的类型PAGE_ID</p></blockquote><pre><code>假设一页为8k32位下 进程地址空间有4G，能分 2^32/2^13 = 2^19 个页64位下 进程地址空间有16G，能分 2^64/2^13 = 2^51 个页</code></pre><p>所以不同平台下，PAGE_ID 的类型需要动态调整，这里我们用条件编译实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//x64  _WIN32和_WIN64都有定义</span></span><br><span class="line"><span class="comment">//win32 _WIN32有定义，_WIN64没有定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN64</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> PAGE_ID;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> _WIN32</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">size_t</span> PAGE_ID;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// _WIN64</span></span></span><br></pre></td></tr></table></figure><blockquote><p>这里注意先判断 _WIN64</p></blockquote><h2 id="SpanList结构">SpanList结构</h2><blockquote><p>我们知道central cache层每个哈希桶中挂的是span的链表，我们将这个链表结构定义成带头双向的循环链表</p></blockquote><p>我们目前的核心成员有两个</p><ul><li>Span*</li><li>mutex锁（桶锁，多个线程同时申请一个桶的对象时需要加锁）</li></ul><p>提供，插入和删除和删除的接口</p><ul><li><code>void Insert(Span* pos, Span* newSpan)</code></li><li><code>void Eerase(Span *pos)</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SpanList</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">SpanList</span>()</span><br><span class="line">&#123;</span><br><span class="line">_head = <span class="keyword">new</span> Span;</span><br><span class="line">_head-&gt;_next = _head;</span><br><span class="line">_head-&gt;_prev = _head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(Span* pos, Span* newSpan)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 先断言一下有没有问题</span></span><br><span class="line"><span class="built_in">assert</span>(pos);</span><br><span class="line"><span class="built_in">assert</span>(newSpan);</span><br><span class="line"></span><br><span class="line">Span* prev = pos-&gt;_prev;</span><br><span class="line">newSpan-&gt;_next = pos;</span><br><span class="line">pos-&gt;_prev = newSpan;</span><br><span class="line"></span><br><span class="line">prev-&gt;_next = newSpan;</span><br><span class="line">newSpan-&gt;_prev = prev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Eerase</span><span class="params">(Span *pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(pos);</span><br><span class="line"><span class="built_in">assert</span>(pos != _head);</span><br><span class="line"></span><br><span class="line">Span* prev = pos-&gt;_prev;</span><br><span class="line">Span* next = pos-&gt;_next;</span><br><span class="line"></span><br><span class="line">next-&gt;_prev = prev;</span><br><span class="line">prev-&gt;_next = next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Span* _head;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">std::mutex _mtx; <span class="comment">//桶锁</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>注意，erase时，不需要delete，只需要从链表移除即可，会归还给下一层的page cache</p></blockquote><h2 id="Central-Cache结构">Central Cache结构</h2><blockquote><p>首先Central Cache是哈希桶结构，然后我们期望，每个线程都有属于自己的Thread Cache（用TLS实现无锁），但是Central Cache在整个进程中只有一个，所以我们可以设计成单例模式</p></blockquote><pre><code>单例模式采用饿汉模式，构造函数私有，在静态区创建一个对象</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单例模式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CentralCache</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> CentralCache* <span class="title">GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> &amp;_sInst;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接口？？？</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">static</span> CentralCache _sInst;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">CentralCache</span>()&#123;&#125; <span class="comment">//构造函数私有化</span></span><br><span class="line"><span class="built_in">CentralCache</span>(<span class="type">const</span> CentralCache&amp; c) = <span class="keyword">delete</span>; <span class="comment">//禁用拷贝</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">SpanList _spanLists[NFREELIST]; <span class="comment">// SpanList数组（哈希桶）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>Central Cache逻辑实现</h1><blockquote><p>thread cache层，申请对象，对应自由链表为空时，需要向central cache层申请内存，我们在thread cache部分提供了一个接口FetchFromCentralCache，我们先从这里开始，逐步扩展到整体的central cache的逻辑实现</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从中心缓存获取对象</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">ThreadCache::FetchFromCentralCache</span><span class="params">(<span class="type">size_t</span> index, <span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>thread cache向central申请内存时，最好多给一些，避免频繁申请，那么该给多少比较合适呢？这里提出一个慢开始反馈算法，我们核心想法如下：</p></blockquote><ol><li>最开始不会一次向central cache一次批量的要太多，要太多可能会用不完</li><li>如果不断有要size大小内存的的需求，batchNum也会不断的增长直到上限</li><li>size越大，一次向central cache要的batchNum越小</li><li>size越小，一次向central cache要的batchNum越大。</li></ol><blockquote><p>根据上述规则，我们在SizeClass类增加下述函数</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一次thread cache从中心节点获取多少个</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">size_t</span> <span class="title">NumMoveSize</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(size &gt; <span class="number">0</span>);</span><br><span class="line"><span class="type">size_t</span> num = MAX_BYTES / size;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一次批量移动多少个对象的(慢启动)上限值为[2,512]</span></span><br><span class="line"><span class="comment">// 小对象一次批量上限高</span></span><br><span class="line"><span class="comment">// 大对象一次批量上限低</span></span><br><span class="line"><span class="keyword">if</span> (num &lt; <span class="number">2</span>)</span><br><span class="line">num = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (num &gt; <span class="number">512</span>)</span><br><span class="line">num = <span class="number">512</span>;</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>我们就可以在FetchFromCentralCache函数中调用上面函数获取应该给central cache批量层要多少个对象的个数</p></blockquote> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> batchNum = SizeClass::<span class="built_in">NumMoveSize</span>(size);</span><br></pre></td></tr></table></figure><p>但是若size比较小，batchNum刚开始的时候还是比较大，怎么让小对象它开始的时候也没那么大，满足规则2呢？</p><p>我们可以这样处理，在FreeList结构中，增加一个成员 _ maxSize，并初始化为1，这样thread cache层每一个桶的自由链表都有它的maxSize。并可以写下边的逻辑。</p><pre><code>当batchNum和当前所在自由链表的MaxSize相同时，说明上边MaxSize是较小的那个，我们让MaxSize加1，若不断申请size大小的对象，MaxSize就会不断增大，而【2，512】就可以做这个增加的上限</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> batchNum = std::<span class="built_in">min</span>(SizeClass::<span class="built_in">NumMoveSize</span>(size),_freeLists[index].<span class="built_in">MaxSize</span>());</span><br><span class="line"><span class="keyword">if</span> (_freeLists[index].<span class="built_in">MaxSize</span>() == batchNum)</span><br><span class="line">&#123;</span><br><span class="line">_freeLists[index].<span class="built_in">MaxSize</span>() += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>知道要多少个对象后就向central cache层要batchNum个对象，但是这里就会出现一些问题，central cache层可能不够batchNum个对象，我们看下边处理</p></blockquote><pre><code>首先是给CentralCache类提供两个接口。一个是获取非空的Span，另一个就是获取batchNum个对象</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从中心缓存获取一定数量的对象给thread cache</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">CentralCache::FetchRangeObj</span><span class="params">(<span class="type">void</span>*&amp; start, <span class="type">void</span>*&amp; end, <span class="type">size_t</span> batchNum, <span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 先算size大小的对象，对应哪个桶，然后就去哪个桶去申请</span></span><br><span class="line"><span class="type">size_t</span> index = SizeClass::<span class="built_in">Index</span>(size);</span><br><span class="line"><span class="comment">// 申请-加桶锁</span></span><br><span class="line">_spanLists[index]._mtx.<span class="built_in">lock</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 首先保证有一个非空的Span</span></span><br><span class="line">Span* span = <span class="built_in">GetOneSpan</span>(_spanLists[index], size);</span><br><span class="line"><span class="built_in">assert</span>(span);</span><br><span class="line"><span class="built_in">assert</span>(span-&gt;_freeList);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从span中获取batchNum个对象</span></span><br><span class="line"><span class="comment">// 如果不够batchNum，有几个拿几个，返回实际拿到的个数</span></span><br><span class="line"></span><br><span class="line">start = span-&gt;_freeList;</span><br><span class="line">end = start;</span><br><span class="line"><span class="type">int</span> actualNum = <span class="number">1</span>;</span><br><span class="line"><span class="type">size_t</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i&lt;batchNum &amp;&amp; <span class="built_in">NextObj</span>(end) != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">end = <span class="built_in">NextObj</span>(end);</span><br><span class="line">++i;</span><br><span class="line">++actualNum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拿走 actualNum个对象</span></span><br><span class="line">span-&gt;_freeList = <span class="built_in">NextObj</span>(end);</span><br><span class="line"><span class="built_in">NextObj</span>(end) = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解锁</span></span><br><span class="line">_spanLists[index]._mtx.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> actualNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>完善完成上述内容后，我们回到最开始，thread cache向central cache申请内存</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从中心缓存获取对象</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">ThreadCache::FetchFromCentralCache</span><span class="params">(<span class="type">size_t</span> index, <span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 慢开始反馈调节算法</span></span><br><span class="line"><span class="comment">// 先算要多少个size大小的对象</span></span><br><span class="line"><span class="type">size_t</span> batchNum = std::<span class="built_in">min</span>(SizeClass::<span class="built_in">NumMoveSize</span>(size),_freeLists[index].<span class="built_in">MaxSize</span>());</span><br><span class="line"><span class="keyword">if</span> (_freeLists[index].<span class="built_in">MaxSize</span>() == batchNum)</span><br><span class="line">&#123;</span><br><span class="line">_freeLists[index].<span class="built_in">MaxSize</span>() += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 知道要多少个对象后就向central cache层要batchNum个对象</span></span><br><span class="line"><span class="type">void</span>* start;</span><br><span class="line"><span class="type">void</span>* end;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> actualNum = CentralCache::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">FetchRangeObj</span>(start, end, batchNum, size);</span><br><span class="line"><span class="built_in">assert</span>(actualNum &gt;= <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (actualNum == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//只有一个</span></span><br><span class="line"><span class="built_in">assert</span>(start == end);</span><br><span class="line"><span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 将NextObj(start)-end 头插进自由链表，返回start</span></span><br><span class="line">_freeLists[index].<span class="built_in">PushRange</span>(<span class="built_in">NextObj</span>(start), end);</span><br><span class="line"><span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://atong.run/categories/%E9%A1%B9%E7%9B%AE/">项目</category>
      
      <category domain="https://atong.run/categories/%E9%A1%B9%E7%9B%AE/%E9%AB%98%E5%B9%B6%E5%8F%91%E5%86%85%E5%AD%98%E6%B1%A0/">高并发内存池</category>
      
      
      <category domain="https://atong.run/tags/%E9%A1%B9%E7%9B%AE/">项目</category>
      
      
      <comments>https://atong.run/posts/1806624746/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title></title>
      <link>https://atong.run/posts/1/</link>
      <guid>https://atong.run/posts/1/</guid>
      <pubDate>Tue, 07 Feb 2023 13:31:09 GMT</pubDate>
      
      
      
      
      
      
      <comments>https://atong.run/posts/1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Damus下载</title>
      <link>https://atong.run/posts/1935618777/</link>
      <guid>https://atong.run/posts/1935618777/</guid>
      <pubDate>Tue, 07 Feb 2023 13:30:45 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;Damus是一款建立在去中心化网络Nostr（支持加密的端到端私人消息传递等功能）上的应用软件，其中Nostr并不是基于服务器来运行网络，相反，它是利用去中心化中继器来分发消息。中继器（Relay）是托管的服务器，所有人都可以运行中继器。获得其他用</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>Damus是一款建立在去中心化网络Nostr（支持加密的端到端私人消息传递等功能）上的应用软件，其中Nostr并不是基于服务器来运行网络，相反，它是利用去中心化中继器来分发消息。中继器（Relay）是托管的服务器，所有人都可以运行中继器。获得其他用户，比如你好友的更新，需要研究询问多个中继站是否了解其他人的情况；而中继站所做的，就是接受人们的帖子并将其转发给其他人。</p></blockquote><h2 id="下载地址">下载地址</h2><ul><li><p><a href="https://apps.apple.com/ca/app/damus/id1628663131">苹果下载链接Damus</a></p></li><li><p><a href="https://play.google.com/store/apps/details?id=com.vitorpamplona.amethyst&amp;hl=en%E2%80%A6">安卓下载链接Amethyst</a></p></li><li><p><a href="https://snort.social">网页版</a></p></li></ul><blockquote><p>注意不要把你的私钥当做公钥发出来。</p></blockquote><h2 id="换头像方式：">换头像方式：</h2><ul><li>需要图床图片链接</li><li>回到Damus，edit profile，头像的链接粘贴save即可</li></ul><h2 id="使用体验">使用体验</h2><p>已经使用了两天，登录注册体验很不错，不需要提供任何的个人信息，（手机号、邮箱、推特、Facebook…），直接注册给你公钥和私钥，但是使用起来体验十分的差劲，可能是没有监管的原因，各种各样的广告满天飞，没有监管的去中心化社交不大行感觉</p>]]></content:encoded>
      
      
      <category domain="https://atong.run/categories/web3-0/">web3.0</category>
      
      <category domain="https://atong.run/categories/web3-0/%E7%A4%BE%E4%BA%A4/">社交</category>
      
      
      <category domain="https://atong.run/tags/web3-0/">web3.0</category>
      
      
      <comments>https://atong.run/posts/1935618777/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>4、高并发内存池-ThreadCache</title>
      <link>https://atong.run/posts/1785806469/</link>
      <guid>https://atong.run/posts/1785806469/</guid>
      <pubDate>Tue, 07 Feb 2023 12:04:43 GMT</pubDate>
      
        
        
      <description>&lt;h1&gt;框架设计&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;thread cache是哈希桶的结构，每个桶是一个按桶位置映射大小的内存块对象的自由链表，我们知道定长内存池只有一个自由链表，因为它每个内存块对象大小相等，但是我们这个内存池需要支持不同大小的内存块，所以需要多个自由链</description>
        
      
      
      
      <content:encoded><![CDATA[<h1>框架设计</h1><blockquote><p>thread cache是哈希桶的结构，每个桶是一个按桶位置映射大小的内存块对象的自由链表，我们知道定长内存池只有一个自由链表，因为它每个内存块对象大小相等，但是我们这个内存池需要支持不同大小的内存块，所以需要多个自由链表。</p></blockquote><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202302031953455.png" alt="thread_cache.png"></p><p>具体抽象结构大致如上，每个线程都会有一个thread cache对象，这样每个线程在这里获取对象和释放对象的时候是无锁的。</p><h2 id="申请内存">申请内存</h2><ol><li>当内存申请size&lt;=256kb时，先获取线程本地存储的thread cache对象，计算size映射的哈希桶自由链表的下标i</li><li>如果自由链表的freeLists[i] 中有对象，则直接Pop一个内存对象返回</li><li>如果freeLists[i]中没有对象，则批量从central cache中获取一定数量的对象，插入到自由链表，并返回一个对象</li></ol><h2 id="释放内存">释放内存</h2><ol><li>当释放内存小于256kb时将内存释放回thread cache，计算size映射自由链表桶位置i，将对象Push到freeList[i]</li><li>当链表的长度过长，则回收一部分内存对象到central cache</li></ol><h2 id="内存碎片">内存碎片</h2><blockquote><p>外碎片问题前边已经讲过，这里只说一下内碎片的问题，如果我们将每种字节数都用一个自由链表管理，那么256kb就是256* 1024个自由链表，这样自由链表的数量会太多，这些头指针就会占据大量内存。所以可以采取类似上边抽象图。8字节对齐，16字节…</p></blockquote><p>我们所用对象的大小可能并不是准确的8、16…，有可能是1字节，14字节，但是我们仍然给对应的8字节16字节，那么就会有部分内存浪费，也就是内碎片问题</p><h1>具体实现</h1><h2 id="对齐规则">对齐规则</h2><blockquote><p>我们thread cache，底层是哈希桶，我们希望桶的数量不那么多，同时内碎片的浪费综合起来也不那么多。综合考量，使不同范围内的字节数按照不同的对齐数对齐，如下所示：</p></blockquote><table><thead><tr><th style="text-align:center">字节数</th><th style="text-align:center">对齐数</th><th style="text-align:center">哈希桶下标</th></tr></thead><tbody><tr><td style="text-align:center">1 ~ 128</td><td style="text-align:center">8字节对齐</td><td style="text-align:center">0 - 15</td></tr><tr><td style="text-align:center">128+1 ~ 1024</td><td style="text-align:center">16字节对齐</td><td style="text-align:center">16 - 71</td></tr><tr><td style="text-align:center">1024+1 ~ 8*1024</td><td style="text-align:center">128字节对齐</td><td style="text-align:center">72 - 127</td></tr><tr><td style="text-align:center">8*1024+1 ~ 64*1024</td><td style="text-align:center">1024字节对齐</td><td style="text-align:center">128 - 183</td></tr><tr><td style="text-align:center">64*1024+1 ~ 256*1024</td><td style="text-align:center">8*1024字节对齐</td><td style="text-align:center">184 - 207</td></tr></tbody></table><p>举几个例子：</p><ul><li>1~128字节，都按8字节对齐，也就是1字节的话，会给你8字节，浪费7个字节</li><li>129~1024字节，按16字节对齐，申请129会给129+16-1=144字节，会浪费15字节，比重为：15/144</li><li>1025~8*1024字节，按128字节对齐，申请1025会给1025+128-1=1152字节，浪费127字节，比重为：127/1152</li><li>…</li></ul><blockquote><p>1~128字节区间最多浪费7个字节，后面范围浪费字节的比重大概都在10%左右。</p></blockquote><h2 id="功能实现">功能实现</h2><h3 id="ThreadCache类">ThreadCache类</h3><blockquote><p>我们先定义这个threadcache类，功能有申请内存、释放内存和从中心缓存获取对象</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadCache</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 申请内存</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">Allocate</span><span class="params">(<span class="type">size_t</span> size)</span></span>;</span><br><span class="line"><span class="comment">// 释放内存</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Deallocate</span><span class="params">(<span class="type">void</span>* obj, <span class="type">size_t</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从中心缓存获取对象</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">FetchFromCentralCache</span><span class="params">(<span class="type">size_t</span> index, <span class="type">size_t</span> size)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">// 管理各种内存大小的自由链表的哈希桶</span></span><br><span class="line">FreeList _freeLists[NFREELIST];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="自由链表类">自由链表类</h3><blockquote><p>我们的是管理自由链表的哈希桶，自由链表有多个，定义一个类实现，功能和实现我们之前的定长内存池一样，成员就是一个void*的指针，提供push、pop和empty接口。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span>*&amp; <span class="title">NextObj</span><span class="params">(<span class="type">void</span>* obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> *(<span class="type">void</span>**)obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 管理切分好的小对象的自由链表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FreeList</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Push</span><span class="params">(<span class="type">void</span>* obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(obj);</span><br><span class="line"><span class="comment">//头插</span></span><br><span class="line"><span class="built_in">NextObj</span>(obj) = _freeList;</span><br><span class="line">_freeList = obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">Pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(_freeList); </span><br><span class="line"><span class="comment">//头删</span></span><br><span class="line"><span class="type">void</span>* obj = _freeList;</span><br><span class="line">_freeList = <span class="built_in">NextObj</span>(_freeList);</span><br><span class="line"><span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Empty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> _freeList == <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">void</span>* _freeList = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="ThreadCache类实现">ThreadCache类实现</h3><blockquote><p>然后就是 ThreadCache类中成员函数的具体实现，也就是如何申请释放内存</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 申请内存</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">ThreadCache::Allocate</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(size &lt;= MAX_BYTES); </span><br><span class="line"><span class="comment">// 先算size个字节映射到哪个桶，但是不同的字节范围，映射的规则不同，用一个类管理</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 释放内存</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadCache::Deallocate</span><span class="params">(<span class="type">void</span>* obj, <span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从中心缓存获取对象</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">ThreadCache::FetchFromCentralCache</span><span class="params">(<span class="type">size_t</span> index, <span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="对齐-计算下标">对齐+计算下标</h3><blockquote><p>但是开始我们就会面临一个问题，我们申请内存，首先是要看哈希桶的自由链表，我们就要知道申请的字节数对应哪个哈希桶的自由链表，这里涉及到对齐和计算哈希桶下标，我们还是用一个类管理</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算对象大小的对齐映射规则</span></span><br><span class="line"><span class="comment">// 1、需要将对应的字节数先向上取整</span></span><br><span class="line"><span class="comment">// 2、取整后的字节数转换到哈希下标</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SizeClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 整体控制在最多10%左右的内碎片浪费</span></span><br><span class="line"><span class="comment">// [1,128]8byte对齐    freelist[0,16)</span></span><br><span class="line"><span class="comment">// [128+1,1024]16byte对齐    freelist[16,72)</span></span><br><span class="line"><span class="comment">// [1024+1,8*1024]128byte对齐    freelist[72,128)</span></span><br><span class="line"><span class="comment">// [8*1024+1,64*1024]1024byte对齐     freelist[128,184)</span></span><br><span class="line"><span class="comment">// [64*1024+1,256*1024]8*1024byte对齐   freelist[184,208)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 要将对应的字节数先向上取整</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">size_t</span> <span class="title">RoundUp</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (size &lt;= <span class="number">128</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _RoundUp(size, <span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (size &lt;= <span class="number">1024</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _RoundUp(size, <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (size &lt;= <span class="number">8</span> * <span class="number">1024</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _RoundUp(size, <span class="number">128</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (size &lt;= <span class="number">64</span> * <span class="number">1024</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _RoundUp(size, <span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (size &lt;= <span class="number">256</span> * <span class="number">1024</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _RoundUp(size, <span class="number">8</span>*<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//说明出现了不想申请的字节数，直接报错</span></span><br><span class="line"><span class="built_in">assert</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 计算映射的哪一个自由链表桶</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">size_t</span> <span class="title">Index</span><span class="params">(<span class="type">size_t</span> bytes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(bytes &lt;= MAX_BYTES);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每个区间有多少个链</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> group_array[<span class="number">4</span>] = &#123; <span class="number">16</span>, <span class="number">56</span>, <span class="number">56</span>, <span class="number">56</span> &#125;;</span><br><span class="line"><span class="keyword">if</span> (bytes &lt;= <span class="number">128</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> _Index(bytes, <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (bytes &lt;= <span class="number">1024</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> _Index(bytes - <span class="number">128</span>, <span class="number">4</span>) + group_array[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (bytes &lt;= <span class="number">8</span> * <span class="number">1024</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> _Index(bytes - <span class="number">1024</span>, <span class="number">7</span>) + group_array[<span class="number">1</span>] + group_array[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (bytes &lt;= <span class="number">64</span> * <span class="number">1024</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> _Index(bytes - <span class="number">8</span> * <span class="number">1024</span>, <span class="number">10</span>) + group_array[<span class="number">2</span>] + group_array[<span class="number">1</span>] + group_array[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (bytes &lt;= <span class="number">256</span> * <span class="number">1024</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> _Index(bytes - <span class="number">64</span> * <span class="number">1024</span>, <span class="number">13</span>) + group_array[<span class="number">3</span>] + group_array[<span class="number">2</span>] + group_array[<span class="number">1</span>] + group_array[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="对齐">对齐</h4><blockquote><p>我们用一个子函数实现这个功能</p></blockquote><p>常规写法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> _RoundUp(<span class="type">size_t</span> bytes, <span class="type">size_t</span> alignNum)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 常规写法</span></span><br><span class="line"><span class="keyword">if</span> (bytes % alignNum == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> bytes;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 9 对齐到16 | 9/8+1=2 2*8=16</span></span><br><span class="line"><span class="comment">// 就是看当前的size占几个对齐数，然后+1 再乘对齐数</span></span><br><span class="line"><span class="built_in">return</span> (bytes / alignNum + <span class="number">1</span>) * alignNum;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>牛比写法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> _RoundUp(<span class="type">size_t</span> bytes, <span class="type">size_t</span> alignNum)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> ((bytes + alignNum - <span class="number">1</span>) &amp; ~(alignNum - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体例子说明：</p><p>字节数为1，应该对齐到8<br>前半部分：1+8-1=8    二进制：0000 1000<br>后半部分：8-1=7        二进制：0000 0111</p><p>8 &amp;~ 7 = 8</p><p>字节数为10，应该对齐到16<br>前半部分：10+8-1=17  二进制：0001 0001<br>后半部分： 8-1=7         二进制：0000 0111</p><p>10 &amp;~7 = 10000 = 16</p><p>8：1000<br>~7：1111 1000<br>别的数和~7相与，后3位会变成0<br>16：10000<br>~15：1111 0000<br>别的数和~15相与，后4位会变成0<br>…</p><blockquote><p>它的原理是让当前的字节数+对齐数-1，这样就大于或等于一个向上对齐的大小，然后与后面一部分相与，去掉多余的部分</p></blockquote><h4 id="计算下标">计算下标</h4><p>1字节，在0号桶<br>10字节，在1号桶<br>…<br>129字节，在16号桶</p><p>···</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">size_t</span> _Index(<span class="type">size_t</span> bytes, <span class="type">size_t</span> align_shift)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> ((bytes + (<span class="number">1</span> &lt;&lt; align_shift) - <span class="number">1</span>) &gt;&gt; align_shift) - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>和上边算对齐数有点像</p></blockquote><p>比如 1字节：</p><ul><li>1+（1&lt;&lt;3) -1 = 8  （部分是当前字节数加了一个对齐数-1，这个数大于等于当前字节所要对齐的那个对齐数）</li><li>8&gt;&gt;3=1 (相当于除以一个对齐数)</li><li>1-1=0</li></ul><p>比如10字节：</p><ul><li>10+(1&lt;&lt;3)-1=17</li><li>17&gt;&gt;3=2</li><li>2-1=1</li></ul><h3 id="ThreadCache类继续">ThreadCache类继续</h3><blockquote><p>完成上边的功能后，我们可以具体写ThreadCache类的实现了</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">ThreadCache::Allocate</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(size &lt;= MAX_BYTES); </span><br><span class="line"><span class="comment">// 先算size个字节映射到哪个桶，但是不同的字节范围，映射的规则不同，用一个类管理</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//找到当前字节数的对齐数，以及对应哈希桶的下标</span></span><br><span class="line"><span class="type">size_t</span> alignSize = SizeClass::<span class="built_in">RoundUp</span>(size);</span><br><span class="line"><span class="type">size_t</span> index = SizeClass::<span class="built_in">Index</span>(size);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果所在自由链表不为空，头删返回头节点</span></span><br><span class="line"><span class="keyword">if</span> (!_freeLists[index].<span class="built_in">Empty</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _freeLists[index].<span class="built_in">Pop</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//为空，则去CentralCache层获取</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">FetchFromCentralCache</span>(index, alignSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放内存</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadCache::Deallocate</span><span class="params">(<span class="type">void</span>* obj, <span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(obj);</span><br><span class="line"><span class="built_in">assert</span>(size &lt;= MAX_BYTES);</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> index = SizeClass::<span class="built_in">Index</span>(size);</span><br><span class="line">_freeLists[index].<span class="built_in">Push</span>(obj);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ThreadCache无锁访问">ThreadCache无锁访问</h3><blockquote><p>每个线程都有自己的thread cache，如何创建这个thread cache呢？如果创建为全局，那么肯定是需要锁来控制</p></blockquote><p>如果实现每个线程无锁的访问thread cache，就需要用到线程局部存储TLS(Thread Local Storage)，使用该方式存储的遍历在它所在的线程全局是可访问的，但是不能被其他线程访问到，可以保证线程的独立性。</p><blockquote><p>我们在 声明下边这个指针、</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TLS thread local storage</span></span><br><span class="line"><span class="type">static</span> _declspec(thread) ThreadCache* pTLSThreadCache = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><blockquote><p>在整个调用中可以用下述方式</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">ConcurrentAlloc</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pTLSThreadCache == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">pTLSThreadCache = <span class="keyword">new</span> ThreadCache;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码，获取进程的id</span></span><br><span class="line">cout &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; pTLSThreadCache &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> pTLSThreadCache-&gt;<span class="built_in">Allocate</span>(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">ConcurrentDealloc</span><span class="params">(<span class="type">void</span>* ptr, <span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(pTLSThreadCache);</span><br><span class="line">pTLSThreadCache-&gt;<span class="built_in">Deallocate</span>(ptr, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://atong.run/categories/%E9%A1%B9%E7%9B%AE/">项目</category>
      
      <category domain="https://atong.run/categories/%E9%A1%B9%E7%9B%AE/%E9%AB%98%E5%B9%B6%E5%8F%91%E5%86%85%E5%AD%98%E6%B1%A0/">高并发内存池</category>
      
      
      <category domain="https://atong.run/tags/%E9%A1%B9%E7%9B%AE/">项目</category>
      
      
      <comments>https://atong.run/posts/1785806469/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>hexo-butterfly主题-giscus评论</title>
      <link>https://atong.run/posts/3307342311/</link>
      <guid>https://atong.run/posts/3307342311/</guid>
      <pubDate>Sun, 05 Feb 2023 07:39:55 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;1、创建新仓库&quot;&gt;1、创建新仓库&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202302051226551.png&quot; alt=&quot;image.</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="1、创建新仓库">1、创建新仓库</h2><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202302051226551.png" alt="image.png"></p><h2 id="2、安装giscus">2、安装giscus</h2><p>点击这个链接安装：<a href="https://github.com/apps/giscus">GitHub Apps - giscus</a></p><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202302051226562.png" alt="image.png"></p><p>选择刚建立的仓库，点击install</p><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202302051228750.png" alt="image.png"></p><h2 id="3、配置仓库discuss部分">3、配置仓库discuss部分</h2><p>首先打开仓库的setting，将Discussions部分打上对号</p><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202302051535566.png" alt="image.png"></p><p>然后建立一个Announcements的分类</p><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202302051537858.png" alt="image.png"></p><h2 id="4、进入giscus配置">4、进入giscus配置</h2><p>链接在这：<a href="https://giscus.app/zh-CN">giscus</a></p><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202302051524708.png" alt="image.png"></p><p>配置完上述部分后，可以在启动giscus下边复制几个东西</p><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202302051530141.png" alt="image.png"></p><p>将上边复制的东西填到butterfly主题配置文件的这里就可以了</p><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202302051531097.png" alt="image.png"></p><h2 id="5、大功告成">5、大功告成</h2><p>博客文章部分就有了下边的评论区</p><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202302051538865.png" alt="image.png"></p>]]></content:encoded>
      
      
      <category domain="https://atong.run/categories/%E5%B7%A5%E5%85%B7/">工具</category>
      
      <category domain="https://atong.run/categories/%E5%B7%A5%E5%85%B7/%E5%8D%9A%E5%AE%A2/">博客</category>
      
      
      
      <comments>https://atong.run/posts/3307342311/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>3、高并发内存池-框架</title>
      <link>https://atong.run/posts/1235732513/</link>
      <guid>https://atong.run/posts/1235732513/</guid>
      <pubDate>Fri, 03 Feb 2023 11:23:44 GMT</pubDate>
      
        
        
      <description>&lt;h1&gt;问题考虑&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;主要是在多线程高并发的场景下，性能更强，主要考虑下面几个问题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;性能问题&lt;/li&gt;
&lt;li&gt;多线程环境下，锁竞争问题&lt;/li&gt;
&lt;li&gt;内存碎片问题&lt;/li&gt;
&lt;/ol</description>
        
      
      
      
      <content:encoded><![CDATA[<h1>问题考虑</h1><blockquote><p>主要是在多线程高并发的场景下，性能更强，主要考虑下面几个问题</p></blockquote><ol><li>性能问题</li><li>多线程环境下，锁竞争问题</li><li>内存碎片问题</li></ol><h1>组成部分</h1><blockquote><p>concurrent memory pool 主要由三部分构成：thread cache、central cache、page cache，如下图所示</p></blockquote><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202302031859699.png" alt="sdsdasd.drawio.png"></p><ol><li><strong>thread cache</strong> : 线程缓存，是每个线程独有的，用于小于256kb内存的分配，线程从这里申请内存不需要加锁，每个线程独享一个cache，这也是内存池高效的原因</li><li><strong>central cache</strong> : 中心缓存，被所有线程共享，thread cache是按需从central cache 中获取的对象，central cache合适的时机回收thread cache的对象，避免一个线程占用过多的内存，而其他线程内存不足，使得内存分配在多个线程中更均衡的按需调度，cnetral cache是存在竞争的，从这里获取内存对象需要加锁，但是这里用的是<strong>桶锁</strong>，而且只有thread cache没有内存对象时，才会找central  cache，所以这里竞争不会很激烈。</li><li><strong>page cache</strong> : 页缓存，是在central cache缓存上面的一层缓存，存储的内存是以页为单位存储及分配的，central cache没有内存对象时，从page cache分配出一定数量的page，并且切割成定长大小的小块内存，分配给central cache，当一个span的几个跨度页的对象都回收以后，page cache会回收central cache满足条件的span对象，并且合并相邻的页，组成更大的页，缓解内存碎片的问题。</li></ol><h1>总结</h1><blockquote><p>高并发内存池的这三部分都挺复杂，后面也会具体分为三个章节谈论这三个部分的原理以及实现。</p></blockquote>]]></content:encoded>
      
      
      <category domain="https://atong.run/categories/%E9%A1%B9%E7%9B%AE/">项目</category>
      
      <category domain="https://atong.run/categories/%E9%A1%B9%E7%9B%AE/%E9%AB%98%E5%B9%B6%E5%8F%91%E5%86%85%E5%AD%98%E6%B1%A0/">高并发内存池</category>
      
      
      <category domain="https://atong.run/tags/%E9%A1%B9%E7%9B%AE/">项目</category>
      
      
      <comments>https://atong.run/posts/1235732513/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>2、高并发内存池-预备</title>
      <link>https://atong.run/posts/594127029/</link>
      <guid>https://atong.run/posts/594127029/</guid>
      <pubDate>Thu, 02 Feb 2023 08:41:52 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;不积跬步，无以至千里；不积小流，无以成江海，做项目也是一样，先从简单的部分做起，在正式的项目开始前，可以先来个开胃菜，一是可以熟悉简单的内存池是如何控制的，二是会作为之后内存池的一个基本组件。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1&gt;mallo</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>不积跬步，无以至千里；不积小流，无以成江海，做项目也是一样，先从简单的部分做起，在正式的项目开始前，可以先来个开胃菜，一是可以熟悉简单的内存池是如何控制的，二是会作为之后内存池的一个基本组件。</p></blockquote><h1>malloc和定长内存池对比</h1><blockquote><p>malloc场景如下，malloc是一个通用的内存池，在什么场景下都可以使用，但这也意味着malloc在什么场景下都不会有很高的性能，因为malloc并不是针对某种场景专门设计的。</p></blockquote><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  flowchart TDA[场景A] --&gt; B(malloc)E[场景B] --&gt; B(malloc)C[场景C] --&gt; B(malloc)  </pre></div><blockquote><p>定长内存池就是针对固定大小内存块申请和释放的内存池，由于定长内存池只需要支持固定大小内存块的申请和释放，因此我们可以将其性能做到极致，并且在实现定长内存池时不需要考虑内存碎片等问题，因为我们申请/释放的都是固定大小的内存块。</p></blockquote><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  flowchart BTA[内存池A] --&gt; B1(场景A)E[内存池B] --&gt; B2(场景B)C[内存池C] --&gt; B3(场景C)  </pre></div><h1>定长内存池实现</h1><h2 id="框架设计">框架设计</h2><blockquote><p>我们的思路是先申请大块内存，每次申请就切sizeof(T)大小的内存块，释放后，用链表组织起来，每个内存块前4/8个字节存下一个内存块的地址，再次申请内存时，如果_freeList不为空，就重复利用</p></blockquote><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202302012204835.png" alt="image.png"></p><h3 id="核心成员">核心成员</h3><ul><li>_ memory：指向申请大块内存的空间</li><li>_ freeList：组织归还的内存块的链表</li><li>_ remainBytes：大块内存剩余字节数</li></ul><h3 id="存在问题">存在问题</h3><ul><li>大块内存，剩下的内存不足一个T的大小如何处理？</li><li>T的类型大小若是小于指针的大小如何处理？</li><li>内存块的前段内存存指针，这个大小是4？还是8？能不能考虑平台兼容？</li><li>如何取一块内存的前4/8个字节？</li></ul><blockquote><p>这些问题怎么解决呢？我们在下面的内容详细讲解</p></blockquote><h2 id="成员函数">成员函数</h2><h3 id="New">New</h3><blockquote><p>申请内存，返回对应类型的指针，我们首先看一下流程图</p></blockquote><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202302021614783.png" alt="eeee.png"></p><blockquote><p>如果按照上述流程，先申请了大块内存之后，每次切T类型大小的内存块，但是最后的时候剩余的内存块不够的话，就会出现越界问题，所有，我们有了remainBytes成员，这个标识剩余的容量，当剩下的内存不足一个T的大小，我们就直接申请大块内存，初始的时候remainBytes为0，也是小于T的大小，同样进行申请，这就回答了第一个问题，和remainBytes成员的用处。</p></blockquote><p>然后我们来看一下具体申请的两种操作：</p><blockquote><p>1、在大块内存上切内存块，返回_memory的地址，然后让_memory往后移动sizeof(T)的距离。这也是我们为什么将memory成员设置为char * 的原因，因为+1操作就是往后移动一个字节。</p></blockquote><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202302021358722.png" alt="image.png"></p><blockquote><p>2、如过freeList不为空，就头删取头节点返回即可</p></blockquote><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202302021455261.png" alt="image.png"></p><p>New代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T* <span class="title">New</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">T* obj = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">if</span> (_freeList) <span class="comment">//freeList不为空</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 直接进行头删</span></span><br><span class="line">obj = (T*)_freeList;</span><br><span class="line"><span class="comment">/* freeList指向下一个节点，我们首先得取出来freeList指向得内存块中得前</span></span><br><span class="line"><span class="comment">指针大小的字节，但是32位平台下，指针的大小为4，64位平台指针的大小为8，如果是4的话，我们可以将freeList强转为int* 然后解引用拿到了前4个字节，但是在64位平台下指针的大小占8个字节，这个就不行了。</span></span><br><span class="line"><span class="comment">我们可以将 freeList强转为二级指针，解引用就是一级指针，这样就能拿到4或者8个字节了。这就回答了后边两个问题</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">_freeList = *(<span class="type">void</span>**)_freeList;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//说明需要先申请大块内存</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (_remainBytes &lt; <span class="built_in">sizeof</span>(T))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//说明需要先申请大块内存</span></span><br><span class="line">_remainBytes = <span class="number">128</span> * <span class="number">1024</span>;</span><br><span class="line">_memory = (<span class="type">char</span>*)<span class="built_in">malloc</span>(_remainBytes);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">size_t</span> objSize = <span class="built_in">sizeof</span>(T) &gt; <span class="built_in">sizeof</span>(<span class="type">void</span>*) ? <span class="built_in">sizeof</span>(T) : <span class="built_in">sizeof</span>(<span class="type">void</span>*);</span><br><span class="line">obj = (T*)_memory;</span><br><span class="line">_memory += objSize;</span><br><span class="line">_remainBytes -= objSize;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对T类型初始化-使用定位new</span></span><br><span class="line"><span class="keyword">new</span>(obj)T;</span><br><span class="line"><span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Delete">Delete</h3><blockquote><p>释放内存（归还内存）, 直接对freeList进行头插操作即可，具体细节放到代码注释部分</p></blockquote><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202302021448061.png" alt="image.png"><br>Delete代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Delete</span><span class="params">(T* obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (obj == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//先显示调用析构</span></span><br><span class="line">obj-&gt;~<span class="built_in">T</span>();</span><br><span class="line"><span class="comment">//头插 进freeList链表</span></span><br><span class="line">*(<span class="type">void</span>**)obj = _freeList;</span><br><span class="line">_freeList = (<span class="type">void</span>*)obj;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="性能测试">性能测试</h2><blockquote><p>性能测试代码很简单，就是不断的申请释放节点，申请的指针用vector保存，然后记录固定次数的申请释放时间就可以了</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> _val;</span><br><span class="line">TreeNode* _left;</span><br><span class="line">TreeNode* _right;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TreeNode</span>()</span><br><span class="line">:_val(<span class="number">0</span>)</span><br><span class="line">, _left(<span class="literal">nullptr</span>)</span><br><span class="line">, _right(<span class="literal">nullptr</span>)</span><br><span class="line">&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestObjectPool</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 申请释放的轮次</span></span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> Rounds = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每轮申请释放多少次</span></span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> N = <span class="number">1000000</span>;</span><br><span class="line"></span><br><span class="line">std::vector&lt;TreeNode*&gt; v1;</span><br><span class="line">v1.<span class="built_in">reserve</span>(N);</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> begin1 = <span class="built_in">clock</span>(); <span class="comment">//记录开始时间</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; Rounds; ++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">&#123;</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="keyword">new</span> TreeNode);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> v1[i];</span><br><span class="line">&#125;</span><br><span class="line">v1.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> end1 = <span class="built_in">clock</span>(); <span class="comment">// 结束时间</span></span><br><span class="line"></span><br><span class="line">std::vector&lt;TreeNode*&gt; v2;</span><br><span class="line">v2.<span class="built_in">reserve</span>(N);</span><br><span class="line"></span><br><span class="line">ObjectPool&lt;TreeNode&gt; TNPool;</span><br><span class="line"><span class="type">size_t</span> begin2 = <span class="built_in">clock</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; Rounds; ++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">&#123;</span><br><span class="line">v2.<span class="built_in">push_back</span>(TNPool.<span class="built_in">New</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">&#123;</span><br><span class="line">TNPool.<span class="built_in">Delete</span>(v2[i]);</span><br><span class="line">&#125;</span><br><span class="line">v2.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">size_t</span> end2 = <span class="built_in">clock</span>();</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;new花费时间:&quot;</span> &lt;&lt; end1 - begin1 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;定长内存池花费时间:&quot;</span> &lt;&lt; end2 - begin2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>经过性能测试，当N是1000000，Release模式下，定长内存池速度大概为new的10几倍</p></blockquote><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202302021531020.png" alt="image.png"></p><h2 id="整体代码">整体代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// _WIN32</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ObjectPool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">T* <span class="title">New</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">T* obj = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">if</span> (_freeList)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 直接进行头删</span></span><br><span class="line">obj = (T*)_freeList;</span><br><span class="line">_freeList = *(<span class="type">void</span>**)_freeList;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//说明需要先申请大块内存</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (_remainBytes &lt; <span class="built_in">sizeof</span>(T))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//说明需要先申请大块内存</span></span><br><span class="line">_remainBytes = <span class="number">128</span> * <span class="number">1024</span>;</span><br><span class="line">_memory = (<span class="type">char</span>*)<span class="built_in">malloc</span>(_remainBytes);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">size_t</span> objSize = <span class="built_in">sizeof</span>(T) &gt; <span class="built_in">sizeof</span>(<span class="type">void</span>*) ? <span class="built_in">sizeof</span>(T) : <span class="built_in">sizeof</span>(<span class="type">void</span>*);</span><br><span class="line">obj = (T*)_memory;</span><br><span class="line">_memory += objSize;</span><br><span class="line">_remainBytes -= objSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//对T类型初始化-使用定位new</span></span><br><span class="line"><span class="keyword">new</span>(obj)T;</span><br><span class="line"><span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Delete</span><span class="params">(T* obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (obj == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//先显示调用析构</span></span><br><span class="line">obj-&gt;~<span class="built_in">T</span>();</span><br><span class="line"><span class="comment">//头插 进freeList链表</span></span><br><span class="line">*(<span class="type">void</span>**)obj = _freeList;</span><br><span class="line">_freeList = (<span class="type">void</span>*)obj;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">char</span>* _memory = <span class="literal">nullptr</span>; <span class="comment">// 指向大块内存的指针</span></span><br><span class="line"><span class="type">size_t</span> _remainBytes = <span class="number">0</span>; <span class="comment">// 大块内存在切分过程中剩余字节数</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* _freeList = <span class="literal">nullptr</span>; <span class="comment">// 还回来过程中链接的自由链表的头指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="内存申请（系统接口）补充">内存申请（系统接口）补充</h2><blockquote><p>在Windows下，可以调用VirtualAlloc函数，申请堆内存</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接去堆上按页申请空间</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">static</span> <span class="type">void</span>* <span class="title">SystemAlloc</span><span class="params">(<span class="type">size_t</span> kpage)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line"><span class="type">void</span>* ptr = <span class="built_in">VirtualAlloc</span>(<span class="number">0</span>, kpage&lt;&lt;<span class="number">13</span>, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="comment">// linux下brk mmap等</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ptr == <span class="literal">nullptr</span>)</span><br><span class="line"><span class="keyword">throw</span> std::<span class="built_in">bad_alloc</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>VirtualAlloc是Windows API中的一个函数，它在进程的虚拟地址空间内保留或提交内存页。</p></blockquote><p>传递给VirtualAlloc的参数包括：</p><ul><li>0：要分配的区域的起始地址。0表示系统将选择起始地址。</li><li>kpage&lt;&lt;13：要分配的内存区域的大小（以字节为单位）。kpage&lt;&lt;13表示“kpage乘以2的13次方”。</li><li>MEM_COMMIT | MEM_RESERVE：分配的类型，在本例中，分配的是提交内存和保留内存。</li><li>PAGE_READWRITE：分配所需的内存保护，在这种情况下，指定了读写访问。</li></ul><p>该函数返回指向分配内存的第一个字节的指针，该字节存储在ptr变量中</p><blockquote><p>采用系统调用后，New的申请内存可以按下方的写法</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T* <span class="title">New</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">T* obj = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">if</span> (_freeList)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 直接进行头删</span></span><br><span class="line">obj = (T*)_freeList;</span><br><span class="line">_freeList = *(<span class="type">void</span>**)_freeList;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//说明需要先申请大块内存</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (_remainBytes &lt; <span class="built_in">sizeof</span>(T))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//说明需要先申请大块内存</span></span><br><span class="line">_remainBytes = <span class="number">128</span> * <span class="number">1024</span>;</span><br><span class="line"><span class="comment">//_memory = (char*)malloc(_remainBytes);</span></span><br><span class="line">_memory = (<span class="type">char</span>*)<span class="built_in">SystemAlloc</span>(_remainBytes &gt;&gt; <span class="number">13</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">size_t</span> objSize = <span class="built_in">sizeof</span>(T) &gt; <span class="built_in">sizeof</span>(<span class="type">void</span>*) ? <span class="built_in">sizeof</span>(T) : <span class="built_in">sizeof</span>(<span class="type">void</span>*);</span><br><span class="line">obj = (T*)_memory;</span><br><span class="line">_memory += objSize;</span><br><span class="line">_remainBytes -= objSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//对T类型初始化-使用定位new</span></span><br><span class="line"><span class="keyword">new</span>(obj)T;</span><br><span class="line"><span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://atong.run/categories/%E9%A1%B9%E7%9B%AE/">项目</category>
      
      <category domain="https://atong.run/categories/%E9%A1%B9%E7%9B%AE/%E9%AB%98%E5%B9%B6%E5%8F%91%E5%86%85%E5%AD%98%E6%B1%A0/">高并发内存池</category>
      
      
      <category domain="https://atong.run/tags/%E9%A1%B9%E7%9B%AE/">项目</category>
      
      
      <comments>https://atong.run/posts/594127029/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
