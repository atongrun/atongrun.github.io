<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>孙菜菜</title>
    <link>https://atong.run/</link>
    
    <atom:link href="https://atong.run/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>万千不如意，睡得着就过得去</description>
    <pubDate>Thu, 23 Mar 2023 04:45:41 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>ChatGPT实用指令：写报告、做简历、辅助面试、英语学习等</title>
      <link>https://atong.run/posts/2390345290/</link>
      <guid>https://atong.run/posts/2390345290/</guid>
      <pubDate>Thu, 23 Mar 2023 04:37:52 GMT</pubDate>
      
      <description>ChatGPT实用指令：写报告、做简历、辅助面试、英语学习等，以及ChatGPT免翻墙网站补充</description>
      
      
      
      <content:encoded><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="d6bbc7d3e5570d649f1573f53116dac4cf920c401039343007e791208cd74c3e">f118b101fdee443b5aed5dd41d0c09e2029d7689cc521fbad19c64d88d14af07a5474873fe599c238c7ef794fbfe9cd00ba7d9b155e77ea46c24ddb8692efff7a850b346f664a540fe6fb2787cf0572966f8559929263cff74d1640699611f3aad93c1b7a4cb6434d0fb7c2d61158a2c3f49088da9839bafc56269765a91cd47bc0ce57207943b6449148744e1be7652ea7f673e5709a0e87ec496b862c5fb40e9d7c42e8d28d37fe798aa28d2db75036b1e4b314194e70420a35255c28dfd20b165de9ce0d6e80a9aa03333bdf953f40641a1ab2241aabd549aa3e5d1f05b69b878a6d4c1435af44f2cf17098a0dba485fca9a644af50e7a0571a2647694b12d12e9557089f17165b32e487c4c31b89a528e08044357355c3eca914cc37b6acc74e8a355d1862802bd261f0a4325adf5cd04558ef5d8a37539b041a1fbc54fd493fc16e66234bf8e56097e7be192a46d2eadbd0689c582c289c2f24dfc3f356ebedc1bb888262a55e2aa9ebe7772aba6142f5bf4099f753264ee7c00328f7d6a2354b2cac72399760252668ca3f6f7cd1f7711936f85ef4126182397334a4897a6562a89b8b392eb10db01a24c68288a835aae2fafefc038d0d4b22c4a093c4db2639a3f40a57c478365bb075722c77ce8281d981d1d45dee99a7db9844cf41a6cde94b3ab1aeb571c3e449e94cce0e6c8ed22e49851cc9b8cc87abb2170da74ee86994d6b13edb4ac045328b4668e31974b12e135894319dd3afb68bdc8090b798225599ada09640046ccdd75f7f22d73dd0f30b6c62530f17b7d288e7ea0857a4a46af02eb6c9465e81962de137dd158dfba84b722293af1499a75d560e367445809c3b65412edc722d33b943468c7074b9a34da5fd0d0e872dd012f9d0ec2739c607e09e0d761623b3a848ea6b225452641ebd3e623048dd1ad11006126604652dfa3bae3ff491d222055e26691295f6311637d9dfce87b6313be0f97125509a367ac1cc2b5a1f546cf1cef54908a535d8cad54a5b7449c8a762f61ec55b57d8378e0b6fc9695c562d60c5a7f2c0c9604f686c8cdc0079f62f914286d4169654d8a695459ff8b858b17f93863db9a2001507c429f613b016c71bb8f23caf4ab3c933e900dcce7da70e56340fab3785e207881522969851cde0770a263a942e16c6c9f5477bc999ea19ad8e6a8736af11f4f51186902a7b3ad79e8bee83d92013d672bfb256e2f08c86432be9518e9c83e21ec24bab6e0c598c84dc053461aeaefbfa3a2ae4be7fba567f56f2e75acb2e56790c52ffc7ed162cac4bb5d467b8b785f886fc1f6b28188c92582b9e048ee86e7e687a4d1e53bda949dd6ef09985c7dbc043af11b7773f14030a1fb2c1024fd4cd532b92ef3f7657ee553192e172d028715b0bfdb279dd44611762bfae8c7ff5ef584dcd0b5af17a7ad9c9aa1e65777c2f46d1c8eeca78ed971987e31cc7ed66c77c1a6d50b6866846082ff8a255ac3b20a6a9dd6cadfd75b89b02a976053530dcde2329015d76dbf18038e736b12e4fb031ebc21ed44931c427dd47b9452c8c789d3ed42e2d740095046838e754bd6faf6b232d8ae2f214b80c8693ba9ef2aaa3d3845f7b2aa2bc2a4055d7fe1a731c48bff5687cf95d0a4a87d6c83cfb3227a8fcd24bdd17faafc7982f9bfbb7668dd569940c915145cca3bc369b696cab7d2a4f344069925ef6dd4ccf447366e419eb61677a547c1cb1c15429006b9214ffc8dbe1f3d58502933630b1ec5b1793b5fb58e6886bd8eee27b4639d2ebe6f0cbc77f94d25d930dee481653ee8227813116bfe437ec1bd8ad94e5d60b28127949085928d1a39c7c2edeb844533ceeae92470abaeae3760853109144641f96d05064caeb76a8c57b2ac1ad100c80a695ce9baed10046a11c768544d4565236a9a13f2e3e2206f8fc574d3e26394c44c4ae53762cdc0c4151f8d5b17c7fb6704ad3348e3e4cf2da9854cdcb3ba708d5b265cd15aa5c7a947789b4d716f0d411e7f126fcb7fc1d6252c9cff6ac7a08cedb39b763bff74ef74500ff3aa760cd48d90b46b3da4d7b75e41791e0593cbeea000cd7bbfa7013722b71c0495e0457e2b2e439cfe4a28d4651c25d564b2a173cabb301cb4114cefa902b3bb100220d133b1c83dcdde582295098fbb56de6c2717849660b2cf8c887b7028705f6e7e792c170abc5112bd9f91800544a40ac33f1e6addd78e2922420937b833cbd9cfc3cbd058441e763836c6a47a65b72bf351e206dbf0b15579d5978c44c85b276532832066fc6e42d8346b3ae105d429b3a8d6760403f4911738b7c66649ff71e90a649b69e3b3fa699ae974e736c38039561ce77fa6cf2fd4ca0f6aefc75984c237536e879f48ffab0341af995de1164550902e022a986f5d2462f8f5d98c99de27c346faddceddcd149f98b7f1a9414bd8b8b6a6b3e5aa4cb079cd7caea2ce2be9e17dcb74e8b8f63c09156c5f09ca11bd8b2900857643d2b1236affb92dc56b61c54fe4307a763eabf4a898e375bb8a659ea8d8e04b8ffcd7040510468176d5520b0b468389cabd159096e66e3d71590e3b41b3f57bb24f988b2239ed154028c72d6ba522ebc4e5e78d1c502ebae1b79c03c0f7dec73ada887ccdc0d0ab61422f89feb66d3cf551cea9c38f4957b58b1526cdb0ca4c4b5b7519361911813e12317a480b2c91514a20e706e5030f9183d54e100d4f3db8fda05e3be07dba91f158e9b1d2727968cd2b5d20d8d6c826a5a9a59a976e5cff02a4149a0c5734266151ac6f0338e064a4cc7f1e226d494c5d998f1e16e51abf5a40fcf6e4b37c7ce95bdb9081e04a8c3bc23fa99685d3dd36d54fec8cfbc01ba6208b4aaf38ab2dc16a090143e2a1759324cf36997e1b2fb443fa79e2164e28e3f6b91377f5262b8704755b07cab148af0200133a22338b4bbd0016dc29c9c8aa2963899e67d311011a41c03bc1c50039177b0a642a4c62e9d739e76d3fdf637ad657b2fea73433bd90c0c94f5808a0f32f299f12b1dbaa703b3093527e8dd2f7822f8bd0cf6a450ef88ca4df3d9e93e36b79b520dbe1fe69afc7bf1c1ee2d6a53372d8662881bf12880fcc76f166282e220add287d774b0eb21b8a1cac0b52560181d56d6ecc46fbf9be608daae2eff7fabf36dc6e593f6cdfde8c862492c6e19659661584bc1c72df333bcd9ef6672143ce15a9ccd2188ef4d15dd18fd7946030308c4d81a9e4a7dd5d097b57638360dd364aeece925c7db59c5c4256c1feb787fe6fcce7f12aa5f2af0519a4e1b46f31491a5e2e8bb4e6b33d0fa16b7a42fc44a197c0f4e0a808910c66b9d79aa473de425f1ec7f433beeea093ee2a5c6f5676da6eedeb8d754c366fb6dc6d1616416133c0ac8b20ec3e4667ffaaa7cf2a2dc59b88f22bfd2aec767875f59dda48e37449ff999f386ca69a449bb190f517a6789e121ad2086452962e2d235cad9a48dfaa6c74190a07acc50751ce00900b37af0c31fa60c321c9ba720b34595ab29ba17529a5fa029b7d9d1d2ccf1049fc34f8556d7aa5ac3397bef091f82af0cac14ef79cfd1c3f67a2e0a90bce76a681e7ef598052017093c6be0c919f97489ca15ccab1f4ed85d39bbee50b7202024392227860200f440835a838f1035ce3a21b4b26824175777ac9a8f028a7bd8608bd6e76db09e64ebed4477dfd6a1af302e9997c3069f05782f41f1776bdf1f934d4d1398f631b62df0cbbfb6b348b21873eeaff976cff70e3fe841f447235e29c0d1c7e7df2c253a2c2705ec3884f8716f06f9b08dc64ab21c020262122232ab3faa9479074fd75e2156b937e797b2db0893f5032adf5f1be4eccf5bc6bb58859aa02ff4a362b63b6a3edce8f2b3a60d482292dd621fba437f0e03bc90278df91c850741b56c3a0152acb8fb89f4e9a64b44b295a32cafe52dfff05145f204dcceac2ccb2c37072c3c30bbace7a2e7b3917f7eed9cd3e1f0b9a1289d56cd4e9354d2ac9cb6468a443ee289c2680489c1aa6b7cb86277fcaa28462f3cdb046af0a08491f11d219f53f5e74abeb36c91b9bb2a19a8fc419979b5289410cfcba90556e188c0cf63056c233aa67617d0da9ae43c3f3f1981d2d12c5723131e7be41d95ee44d762494201e8b3d0d0afc89b4b19611dc1ca8bf41d4ed104992d568d038764091f2df41c2a9c7c00848ebdf82479fbefc6aa1e662c62565691eb5e04502b8d13c2c59151cc9ee4e4dddf61f5eb3e93e6a7cdbba52948e43888405555ced992a320640a9f3e357d58db389cde8affad953438761be0a22f9eb755cb7c34b6f897c22f636c024de4ed839a6db05230dc8a390da49e39f48d14a7fba62fefb351c5fb20cf05462c11486b6425c58d9f9649dd60ba6b663661efd8853d9806f2c3311a3e74fdffd17fa221156954ca12d75b7d1795e392342222726d46def37ab303a54ad2a73e99b44c0a9f114ca887084e8b33049a32117298b7c1c68894dcdaf7868da66aa4c15d3517fc2309c4c42c442ed1e06f09acdb4013d08145093ea5d078faa826723a63d2a648a661b34ae53ff6e411deb0b84bf0bcb676f691b34ffdeada2c7727c6535bada7b56eb174c5f73e69ff822c6ba1e6d900122d9f96967ac2a3dae5d1b5f6d05cc9f3ca8b16c818b0babd7e43651910bdb3aae23983a0b5d7965b93462ae7b741db667f7d7d93ee41d9039ce25f6a8abc4c77cc98d161c95fcba1272473e2cec6c43dcfb5fd7f9e6ead9dcf011158359d0a6396f610542e045467afae1de693e41d463f7b818e5e67116b5a1ba0dd6067dc2f3c072fb679a5d0c178c980e6922acbfd1db21baf28572fc5e344cce03a81dd80c4b2ecf457b209dbc58e7f688bf368556de119f2fa27ba42620f9af57a850f8feb689056211ec0fbaf4222eec038b01667f2468283fa29ba3abe4fe7270571df860e0b72fd647fc41e8b2ed138db5b483ae456851ca249b946066ad1aa65c5e678af2a92c91f36e3239506e0c0928c27574441322135e04ac2ea6b5f76113bacd167dfb3ea1a3e89dc95ca5ebb5c7e8a66b9b4f2576df70c87234724393df5b1b946b60fe9917d00ef455e93c6324e1d4904c6fa95ab242b0c0e03b6fc695584fc6ecb6a9b7686d01e160f283ba8b05dcb2d3cfa17e3847fb6ec01948e6324083840ba0c828be21ec53463d6e82f68ed92b70bb280d08f7e48bf2b1fc78b6098694420f3d7b43b02ebb38e97fa3716fb727945a54757f15678e51b3c389e9de77f419847cc385f4e263999c2ed08b9ba9bfad0d05a943f1d9e1e5af2c4b6f10c52fa5a69ec1705a148d4118988f2cc6985542abf8163422b890b8e36766d66d845121add88a70328b91757c44c94a0c15b7f80e9e665c6782caa271df767b42c4f1293781a02b41cfc30014fb051ead77763c330cb2f2ac4ddf85fda57ed685ac08d2451c087a643eec38da83fc2c723b2ea03d9c4dd1ae87512948ba7565a2f46e815879fd13c65873d600ae928618c0c9d3b7ca0e7bdb28028bca5d859d87336cc3c3baf97760d83168e448f4e1ebad06a4cbe4c304f315b152b29b9e8a0d9f208cfab86f8bede8f6fc859b2b55b9ef1c6c0b59086cf4c1ea2687723e40896f3f913cd17005d1065d54234b6763ea7b3e79968b7653fd47b004d054fdc2f76200ba3bb9e785cba5046aaa2d968a176326eb721b89730cf98e0551b64f1cf70947fcf050fd30c40d528d44bff22cc5f4cc4623d7eb968575392ed2ce1e91c1071642bed1e6483b8b86190bcd15b6f8a7c7aab17a18243fdcb65d552d3ee746c5e9503349d2a85bf4d140449dab1c367d50c3a198d296044296d684db0446448126c9ea66690dba7a700d21c84ff376bd4a1602e7ea68c942d7950d4b310dc50222237d49cbce001c99d55cc020ba19da923ed92f2cb2c3c8275f7afbc6bfd5892c78941fe1db3906d3c31e927900b949d4346f0480a2e3477e560c8f2d49164c04d68a020f225fd0495e6a49aee485390b1c2c2058c224a255a4beb00b147ff5a92acf85fc1f6fe235be59bc2fbe5c430787d942e18c347a4e12b7e76aa5ff126468506ee1113b98457207a7646a32de2ca8701972a2b659daaf1fa1d76878c74c5a756559f6e1c0ce6575161c16af8c781a03a6582d5ca92e2cf90253c44a216af3cc7ccc7dcf06f2ab1149721c8bdf72b1e6e8261a94efcbeb78d2dac61195cbfd357d67138a36ce97d53d6d66aa7b7a2d70e5c9388f3a09780326b87264c4b781861c24d9d53592c02f7a2c2e92e4373da442a19db902b7688a9b4e8979051aafa87d604e1dc46e1cfbcc09866307fbf0eaa348eb6337501c6ef52d8c49cfa0ae78245a6020d6c515320862131234280797f67801a7618cac6911a59161af76e543bccf73e04a378bce17d3dab5ddc3163e92ea017b8b05e1359034f2479ced510883dae48f077a57c1decdb695427697d13b2cbd6423106f0ff313e9d1eba015fa4858a0b8acb31518671561a04dea38edafcd93a7871e487e5efed137c78537cfe53f62687c9d8a5a5930ae14c348f4774a305d13d4a5998807b5a36c68c8d2ca58815a8af4ae1e3bd1e57aa8b4576fea2edabd67adbadccb3b3f4d8a5c961785a23cae1b093ad01500402b35c5d8d43ba9d068a13d15a6232f26aa633067327d9ca37dc947f7fa38ee29449f5ddf9e6aed7fa8e0d47c6a895191ce3b3693e1ec9311af12a096c3360e0254f82dfeeb053235c274e84c3d6e146d46b4565c48dfe1d663157625f0d8dc4e6844e9b86c76fb98d4a68dc7db2370b203790ef18a3fae0ed708081c61803292582112102e647d999334db4fffbcfdd897095186f4a3d3f90d66fcd48fb7cd14539b314da060c8a5c270f685c439a028d5a5533fbcf62bcf880813c0def658339d7cefebf6187843be5248948e1c2e27d26691d145e5cc725aff2dbb7f475ea1a43baf0dc1b874231415da8f8463ea16fcc63384678daf68b6bfb15428481d81f29ecb4c84465480ba90d64ac8b2bb83cb71353eb3a6cf6f9b2d9d02b29ba6c128673e7092e87cb1d47c48031131d309d2dd010917d574c026a75895c403f93f40eb89ecb35e2254ed4b3e668781195ad4f0b12f565b887b78ee3a4b1074bbdfc197521d51368d0539f3227a9f3138ea21901b736f33ac39b46e73d6da3a4cb609bb9f97bcadd7eb67b51ea0bcb4b3d27dc5fb6be8c0334013d319ca6590a81d1bf4933520f1d2e0f350278a31a923f50e0b993dfea53e587c89e4ab0f0ac82fd64b40592dce9f6ec2da2cab83f4d5bfb6841fd123828d8c850550394fa566dea512309e351ed5e2c39f23e0f51419305f14bac8fb6871588f911a9d9b432627ad145f7770353f1ff617267b0e5f4711bf162730df0651764297ac88abedf38d287d7d07df54ee47d6cbbd09cda87bfa9a8ebf35a6a0d6b366987747e08d3b581531fd6ef3fa94bd996194f0c39451b70be4fb8ab1dd9a70c365da85b87a6db6b106625b2c6af1d546edeb9b12a8eed5e84f9e3c62bed00981453922d9356cfe4c57d40558167a2f9128e888eb9f741f99cd53004f17dd31c091953f75958f89a9ab7e1fb851b456201c80143c678bd50f1422d869794f4a2efbb0ae8a8c31c39a7d512372d96195ca2827f0491b27323e14f88545faac7efb6f06946b8a2989dd28b39b2d3f454dd9c0cf57180e3aca49159bf6c85d435c7ee1b566506820b3d95cc1a63f10143c59478593dc0cadbda077a2c38d29a2f0dcb3d1a722358dfb6632849e081eb545703679c454e1699e1755ce18afac1dec2ab870ad733a3be5cdadfca98556ca9513c435b99aadd55b7a3b2b18fd476364cfe49815ea5dc8ee6e8b4811302a4909e36e9e8154406282bc818234121532482d8e126f8e2e3c221f934d3e445083ac89aeeb2988f2443951ba830384efb547fab4067850efcb94ba91c2abe7a5d0d1108d8c5ae7392c12c929bb0d4703029bc78ca3ca4c63508b6ac36f5e6212409c2cc3878b6cb3462c10fa933eb473fb7a2a97f5f26db5f407bba0ab68fa9512bb200a16319da857c543878c3d4d669b14e516fd76de51cddfd625a1333cf5fe8c4be57e347ec712a04cdf3d6f83d1d80cb8e69b32f32d757e709566e9ea70b96c1b8c645d7673545ba72346e2ca2a086337b7b3b844c22708cd97411d7911456b4c986688ec7220190375d44c81f9db876775c3b9d321eb88412de455d7ca7cb3559c90225e63e437b671a958d8079015a49620a9478959900bd689347a6c525f78eb2cc9e1f554d6739e5feee678a0ccd6d56a8eb9c29ef743f6602d8942b1e47c37dad47da70115f7dd9af0319153afb2e40e0e6ac8ef8a6cb0f321f67a6f170df49b9443ef7ec38d6f4b92ec876e18d287e87920c96292dc7bbb0ec90fe30d067a5ac5fb3278d80c16a3c507246f161680510b1539518109fd8dda1cd997fce469b944c2d181d2fcee7088eb1c0308273155a30c64cc8b4e96c238f5ee20ae94bc0978d114afa85e3be7d9897ea66ab5d409dd4cd96fa138d122a955d0c29d7cefeceb4786c3e160b4eb8b21a19d9d669c8a1feb506c45287f03b8e1fa7d676c9e421dcb98b7d2aa86aaa86a48202520d8da680df0da616712ea8f27370ba8cd936a7d8b3cfe5957872522c560fee2a6fede99bd356120de1402c4d37cc6bc0974ec45a7c8d63801d0b15da823659a66e27e904d9dab35c7b44f04ed1d8a957a4eb32ac73da86e59507ea4d6fc6f999a97f066ddaa482bb7cc93417cf1fe2ed562ae469deb7d2acb7a42e057967f02cc54045908103c929f24dc05d54f4d0363283b0f2e68eb06337d5d3ecececfc78f0eca2f76cf7995013c9704be6079f320adc932c6435f78f8641c207c652dc1881f14b68441d292d806b0ded9794128631ffe1e736641f11fcfa37d2ea6d3782aa330f93a8a26421aba91781b6b24dfaefeeb45e7246070a5d6c3ea769c88ea837864d681802445145ba6c37f164f815f8cfb27343f319341d61f17dceb87723195377ffb284b6747cf33149c4d251c557248178a830d4e4556cc52200634ee115e2c2908fc8451aed58cd8cf171e28c189d675e1460ce0ba94194ab9a0c1b96f508ab7d37b819dcc9d233760b6a15e2d128658bdba6c75d18d912dcb82533475616787f73fb748e34ccd22fe10ba4e194fba99227059675de8961490fbf48188adf0028a32e399009e4b64d7620919489e9cee3c62d62ed9e1af8c02ef2a5cbfbcf7c79a6721a00823830a6e2b0858a80578a3218edf5864b229dec2af074ca1df70c9e80acc7defee2b150eb43a9fecec7030c7c9b4eb6a17bd511d18ca076d2086d1494986b02b7ef66c95b4e23e234fc8ffc5b00d2c357119b0e1a5b59476a38ee3b14cbd8da44c896310c3ff46100c187f0e6f9a756ff616418c71b8cdf3f3d85aa9458048eb1e6ce971300a0856dd7b5db3e01f319b5cf6c28180588ed047165046fc42c383ba1ed7638ea9abde354ef165a80ce8b36fbef4fd0e079147a1a9eafc5cb5d6c31619697db282fc2793961bd019ab94abf3e81de1b75bea64a70369aec75e47f74beaaa2d7175117a32a1ce83e600aa4b38b6a9c69f29df28312fc164668d2770d76d12800ae16177cf29657f2f7e6182ac016527c2f52eddd6f00f13650805b12d3b3b3d65390249c7f6dc03ce1187533c03ef3c9037e9a0d49d5cb989342f39e3da384c02eacfabc5e28e688615392b6d9a07affd9b402e9be19ae567e65cb939c571aefdc2d4b72050040ee159dbe381b6e959fffe2ae0bc3a7f4a5f98521f800c0366c9f670171066ff85fc27ba28d6bce843ecfbb9dde02bbfda1ebe1c7bedf08bb9860c5c2a740c65ba4fd354885c39486ed0401e8411ef55780b3e5141aa12a425b1cbd5aca288f2399b8f33a1a1d9d6a08a8e62873baf45b7afb940c1d887bedc8f45a1b08fd184616ffa3f8bf77ef01a7d82ad087a0a87ce08353bc8b3734bad7df7476b9ed556a75017f3fb940f2fc7e69f77fd0c4e401f5616ba9d312349d2e73172adcbb0be9452c36df04973701f336c62d0fcd17f399d520bc32173dbd521d90d67905a6a6aeeb57e38bcc1bd26ad7c8cfd0244509416113f5d0f9530e2286a8d6ba3ebdc8de353a20cc31f316125e1fbd8d49c32fc7df6530b58f1ef88866ab79e7ea6faa90a9d3113d441f1ea25ab39ab101e51fbd57476c56a5a593aaf991b0a0a50eb9cb336a6f48868900613ae17cc658bda97d390e598854689de8e43ec85fa5ff59c84eb2a5255ef652eeaa1008669b6e1b4ab36ed39ce004be0a3f00ef74b3a901075ef0a6603660d4eff4132094942f0ff26df9af43397f56e219ad143cae339bf9ead48033a7dde5dc6a524ae6e6bce60c189426de30036a657c6b1c28dbd8abac609a9140032431f40ab0365d6044299ee828a223ebb13bdd62003880c052ca777b339b3ec51190c6b4c3b66ca572511b36ab2e84fc197b34c6fab4e50cde4de6edce696852f3de59f03a20980e9f21a745fd919ad8484f9a7ebdbde3fbf7b21a9030586b01611939f06505822c143356997010b34aa54a7b2d761b5d11e1e1537561ee1e90b4f62dfd37893ffb11e0f202cc6e766332970484203dc6a6877ef387917eb41dec58402db3f7e74772c58c8c384c4ae8f6256807022b6dc3180ac3b445db3b5239f64a009f17f3c94bfbccd875e2170689759f431deec6f317ae4c51a43dca54cd006effb93eff022be2cf784b8b929f889a6614f3183f2662115dddee166050231a8fa124bd9a4df46f29e78cc8d09cd54960e4fe563c1dd7268b8da2a58136b42cfff43fdc188186c34105f74bbc19f1fd8c70b1c18800a296b83e9a965de7f65f681b07116ebc7961c5be63e6da1fdd98841b02833d9275f951ee43b484bac50f6ec9f7a33ca0439e91b1dcaa906de8c2f89120a0aae53f84b644681e33bf2dee76822112b531cc85006b674ab251e3734d1cf1a822b8461eb6189a17737f0be63d7894c2688dec14e80605230590449b05c5d5863aecbf22961102f8e253da42c8ad613de02ed35a20f4172888809dcd1635ade9d6b7bfe9c8166cacf4e5159d3756f769f5c05048c0293be03f399e038ca6fe7199fee13735970f6207f0d1d6deacdcb0f7ea7aa4e856f701f7ab2e49579b2434c01b6c9f5698da86967031bc28495cc078b993ac82da090d4d8c51d806133a57d26c2a7a8438</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">公众号孙菜菜回复关键词【GPT指令】获得密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content:encoded>
      
      
      <category domain="https://atong.run/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/">人工智能</category>
      
      <category domain="https://atong.run/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80/">自然语言</category>
      
      
      <category domain="https://atong.run/tags/ChatGPT/">ChatGPT</category>
      
      
      <comments>https://atong.run/posts/2390345290/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>都2023年了谁还在抛硬币？来学学中国传统文化小六壬（测吉凶篇）</title>
      <link>https://atong.run/posts/2043869359/</link>
      <guid>https://atong.run/posts/2043869359/</guid>
      <pubDate>Sun, 19 Mar 2023 14:08:27 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;2023年了就别在抛硬币了，来学点有意思的，学习我们的传统文化小六壬来测吉凶，非常简单，2分钟就能学会。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1&gt;简介&lt;/h1&gt;
&lt;p&gt;小六壬是一种中国传统的预测方法，据说是由三国时期的诸葛孔明简化自奇门遁甲而成</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>2023年了就别在抛硬币了，来学点有意思的，学习我们的传统文化小六壬来测吉凶，非常简单，2分钟就能学会。</p></blockquote><h1>简介</h1><p>小六壬是一种中国传统的预测方法，据说是由三国时期的诸葛孔明简化自奇门遁甲而成。小六壬以大安、留连、速喜、赤口、小吉、空亡六位分列于食指、中指及无名指上，时间按月、日、时顺序计算，最后得到大安、速喜和小吉的为吉，其余为凶。手掌对应图如下：</p><table><thead><tr><th style="text-align:center">食指</th><th style="text-align:center">中指</th><th style="text-align:center">无名指</th></tr></thead><tbody><tr><td style="text-align:center">留连</td><td style="text-align:center">速喜</td><td style="text-align:center">赤口</td></tr><tr><td style="text-align:center">大安</td><td style="text-align:center">空亡</td><td style="text-align:center">小吉</td></tr></tbody></table><p>具体对应图如下：</p><blockquote><p><font color="#ff0000">只需要记住：红色就是好，绿色就是不好，这是重点，还有就是手掌是左手哦</font>。</p></blockquote><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202303192121621.png" alt="image.png"></p><h1>实操</h1><blockquote><p>记住好坏之后就可以进行实操了，只要你会数数就可以了。</p></blockquote><ol><li>首先知道现在是阴历的几月几号，现在是什么时辰。比如今天是阴历2月5日，早上8点多，也就是辰时。</li><li>然后看上边的手掌图，从1的位置开始数，月数是2，顺时针数两下，到了绿色的2位置</li><li>然后从2位置数，这里是重点啊，新的位置是2开始，数5下，到了绿色的6位置</li><li>最后数时辰，辰时是第五个，从6的位置顺时针数5下，就到了绿色的位置，术语叫做赤口，说明你现在在这个时辰的运势不大好</li></ol><hr><p>时间对照图</p><table><thead><tr><th>时辰</th><th>时间</th></tr></thead><tbody><tr><td>子时</td><td>23:00-01:00</td></tr><tr><td>丑时</td><td>01:00-03:00</td></tr><tr><td>寅时</td><td>03:00-05:00</td></tr><tr><td>卯时</td><td>05:00-07:00</td></tr><tr><td>辰时</td><td>07:00-09:00</td></tr><tr><td>巳时</td><td>09:00-11:00</td></tr><tr><td>午时</td><td>11:00-13:00</td></tr><tr><td>未时</td><td>13:00-15:00</td></tr><tr><td>申时</td><td>15:00-17:00</td></tr><tr><td>酉时</td><td>17:00-19:00</td></tr><tr><td>戌时</td><td>19:00-21:00</td></tr><tr><td>亥时</td><td>21:00-23:00</td></tr></tbody></table>]]></content:encoded>
      
      
      <category domain="https://atong.run/categories/%E5%91%A8%E6%98%93/">周易</category>
      
      
      <category domain="https://atong.run/tags/%E5%90%89%E5%87%B6/">吉凶</category>
      
      
      <comments>https://atong.run/posts/2043869359/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>KMP算法</title>
      <link>https://atong.run/posts/765481613/</link>
      <guid>https://atong.run/posts/765481613/</guid>
      <pubDate>Sat, 18 Mar 2023 08:41:04 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/&quot;&gt;28. 找出字符串中第一个匹配项的下标 - 力扣（LeetCode）&lt;/a&gt;&lt;/p&gt;
&lt;bl</description>
        
      
      
      
      <content:encoded><![CDATA[<p><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/">28. 找出字符串中第一个匹配项的下标 - 力扣（LeetCode）</a></p><blockquote><p>给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回  -1 。</p></blockquote><p>这种字符串匹配，常见两种算法，一个是BF，暴力算法，另一个是KMP算法，KMP算法难点就是求next数组（该数组保存回退的位置，利用真子串的特性，减少匹配的次数）</p><h1>next数组</h1><p>next[j] = k， 不同的j来对应一个K值，这个K就是将来要移动的j要移动的位置</p><p>求K的值的规则：</p><ul><li>找到匹配成功部分的两个相等的真子串，一个下标从0开始，另一个以j-1下标结尾</li><li>不管什么数据next[0]=-1， next[1]=0</li></ul><p>练习1：</p><table><thead><tr><th>a</th><th>b</th><th>a</th><th>b</th><th>c</th><th>a</th><th>b</th><th>c</th><th>d</th><th>a</th><th>b</th><th>c</th><th>d</th><th>e</th></tr></thead><tbody><tr><td>-1</td><td>0</td><td>0</td><td>1</td><td>2</td><td>0</td><td>1</td><td>2</td><td>0</td><td>0</td><td>1</td><td>2</td><td>0</td><td>0</td></tr></tbody></table><p>练习2：</p><table><thead><tr><th>a</th><th>b</th><th>c</th><th>a</th><th>b</th><th>c</th><th>a</th><th>b</th><th>c</th><th>a</th><th>b</th><th>c</th><th>d</th><th>a</th><th>b</th><th>c</th><th>d</th><th>e</th></tr></thead><tbody><tr><td>-1</td><td>0</td><td>0</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td><td>0</td><td>1</td><td>2</td><td>3</td><td>0</td></tr></tbody></table><p>问题：已知next[i]=k 如何求 next[i+1]?</p><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202303132035003.png" alt="image.png"><br>因为长度相同：</p><ul><li>k-1-0 = i -1 - x</li><li>x = i - k</li></ul><p>可以推出：</p><p>p[0]…p[k-1] = p[i-k]…p[i-1]</p><p>如果：p[i] == p[k]  -&gt; next[i+1] = k+1<br>因为当上述成立：p[0]…p[k] == p[i-k]…p[i-1]</p><hr><p>如果:  p[i] != p[k]   那么  next[i+1] = ?</p><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202303132048527.png" alt="image.png"></p><p>回退到的2号位置，不一定就是你要找的，继续回退，此时回退到了0下标处，一直回退去找：p[i] == p[k]  -&gt; next[i+1] = k+1</p><h1>代码实现</h1><h2 id="BF">BF</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;haystack.<span class="built_in">size</span>() &amp;&amp; j&lt;needle.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(haystack[i]==needle[j])</span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                i=i-j+<span class="number">1</span>;</span><br><span class="line">                j=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j==needle.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> i-j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="KMP">KMP</h2><blockquote><p>我写的错误版本，错误原因是，next数组求的有问题</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;next = <span class="built_in">getNext</span>(needle);</span><br><span class="line">        <span class="type">int</span> len1=haystack.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> len2=needle.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span>(i&lt;len1 &amp;&amp; j&lt;len2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j == <span class="number">-1</span> || haystack[i]==needle[j])</span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                j=next[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(j==needle.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> i-j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getNext</span><span class="params">(string str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">next</span><span class="params">(str.size())</span></span>;</span><br><span class="line">        next[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(str.<span class="built_in">size</span>()==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> next;</span><br><span class="line">        next[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i&lt;str.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> k = next[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">if</span>(str[i<span class="number">-1</span>] == str[k])</span><br><span class="line">            &#123;</span><br><span class="line">                next[i] = k + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> j=i<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">while</span>(j&gt;<span class="number">0</span> &amp;&amp; str[j] != str[k])  <span class="comment">//问题出在这里，这里应该是str[i-1]和str[k]相比</span></span><br><span class="line">                &#123;</span><br><span class="line">                    j = k;</span><br><span class="line">                    k=next[j];</span><br><span class="line">                &#125;</span><br><span class="line">                next[i] = k+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>正确版本1</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;next = <span class="built_in">getNext</span>(needle);</span><br><span class="line">        <span class="type">int</span> len1=haystack.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> len2=needle.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(i&lt;len1 &amp;&amp; j&lt;len2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j == <span class="number">-1</span> || haystack[i]==needle[j])</span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                j=next[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j==needle.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> i-j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getNext</span><span class="params">(string str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">next</span><span class="params">(str.size())</span></span>;</span><br><span class="line">        next[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> k=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;str.<span class="built_in">size</span>()<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(k==<span class="number">-1</span> || str[k]==str[i])</span><br><span class="line">            &#123;</span><br><span class="line">                next[i+<span class="number">1</span>]=k+<span class="number">1</span>;</span><br><span class="line">                k++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                k=next[k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>正确版本2</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">next</span>(needle.<span class="built_in">size</span>());</span><br><span class="line">        next[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> k=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//已知next[i]求next[i+1]</span></span><br><span class="line">        <span class="comment">// 两种情况：</span></span><br><span class="line">        <span class="comment">// 1. needle[i] == needle[k] -&gt; next[i+1] = k+1;</span></span><br><span class="line">        <span class="comment">// 2. needle[i] != needle[k] -&gt; 回退k，k=next[k]</span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;needle.<span class="built_in">size</span>()<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(k==<span class="number">-1</span> || needle[i]==needle[k])</span><br><span class="line">            &#123;</span><br><span class="line">                next[++i]=k+<span class="number">1</span>;</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                k=next[k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;haystack.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(j&gt;<span class="number">0</span> &amp;&amp; haystack[i]!=needle[j])</span><br><span class="line">            &#123;</span><br><span class="line">                j=next[j];</span><br><span class="line">            &#125;</span><br><span class="line">            cout&lt;&lt; i&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;j&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">if</span>(haystack[i]==needle[j])</span><br><span class="line">            &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(j==needle.<span class="built_in">size</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> i-j+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>next数组优化</h1><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202303171525238.png" alt="image.png"></p><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202303171529695.png" alt="image.png"></p><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202303171533230.png" alt="image.png"></p><blockquote><p>优化版本代码</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">next</span>(needle.<span class="built_in">size</span>());</span><br><span class="line">        next[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> k=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//已知next[i]求next[i+1]</span></span><br><span class="line">        <span class="comment">// 两种情况：</span></span><br><span class="line">        <span class="comment">// 1. needle[i] == needle[k] -&gt; next[i+1] = k+1;</span></span><br><span class="line">        <span class="comment">// 2. needle[i] != needle[k] -&gt; 回退k，k=next[k]</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; needle.<span class="built_in">size</span>() - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">-1</span> || needle[k] == needle[i])</span><br><span class="line">            &#123;</span><br><span class="line">                next[i + <span class="number">1</span>] = k + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (needle[k+<span class="number">1</span>] == needle[i+<span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(needle[<span class="number">0</span>] == needle[<span class="number">1</span>])</span><br><span class="line">                    &#123;</span><br><span class="line">                        next[<span class="number">1</span>]=next[<span class="number">0</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                    next[i+<span class="number">1</span>] = next[k+<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                k++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                k = next[k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;haystack.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(j&gt;<span class="number">0</span> &amp;&amp; haystack[i]!=needle[j])</span><br><span class="line">            &#123;</span><br><span class="line">                j=next[j];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(j==<span class="number">-1</span> || haystack[i]==needle[j])</span><br><span class="line">            &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(j==needle.<span class="built_in">size</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> i-j+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://atong.run/categories/%E5%8A%9B%E6%89%A3/">力扣</category>
      
      <category domain="https://atong.run/categories/%E5%8A%9B%E6%89%A3/%E5%AD%97%E7%AC%A6%E4%B8%B2/">字符串</category>
      
      
      <category domain="https://atong.run/tags/KMP/">KMP</category>
      
      
      <comments>https://atong.run/posts/765481613/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>ChatGPT免翻墙网站推荐</title>
      <link>https://atong.run/posts/4182892542/</link>
      <guid>https://atong.run/posts/4182892542/</guid>
      <pubDate>Tue, 14 Mar 2023 03:15:08 GMT</pubDate>
      
      <description>不需要翻墙的几个使用chatgpt的方式分享</description>
      
      
      
      <content:encoded><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="a0891862c8a38bb3d2345939a0a9807727f5ec8607a01e01034b1fa27e618c96">f6cac86f78082062b77dcf10f3958992138886a6aa00fae39ff3b75aefe8ecca743efddce9d408d05413b66d60c1658d91781c9dd550c2dfb4eae359e2f4bbdfd6fbbb3bc41920f1b890b67977580e0bc1c3d65bb0cbb7ba76be188959926934c73c1cfb59740c748595455c0ad3f25063fecbf8d8cef9b4890132e9c293f4cfbe1dedca807de35b776c2eecea204a30ef144c7d322920b88777a0d375964df7ecf1ec66a0cdcbc9945f4606b56b1db514dab2bad0f6507bbadedbbe703d638f5fb7a56c6d0a83cac7794ba0021ea9eae8cc871416b3cce70bb3d017af4889bd59beb71bc1729bb46f6f9294630c41c4363be2523b5f22435bbe1de901fa4d45e75de14c6e1ad930c64eb255c7c9ad9f1b8412b0d73cac689b873f3bbfb1e18e3a9edee1e2389801978724bec25a95fc809f778fa321ef6260055389335a8641719adf4c5e18f0907040eb2135b5851b83693bef9b7e86f0b497367d60f9353d11870301afa4955c20a1034b10debc4703c49700c309ae3c8849bb96a0b6499b81528afc71d02eafb2392a21cebf8212b7b35fee4b9da2d39c985fdc95caa41d2ed711b97ab3f7b01c8cbb26858515f68e99ec8d297eaa37564a9882f1eece0c74fd8801e17d93dbe57246c49f2138be5afcd27b9266312706f9bbe26051bd1a80b595b08b5f60286e8602c2ab37b2f8621dcdcba86f817c7c151d77cdaad8d4c329cd7286b8eb643f74a5c85aea23cd19a66e40d96a40f0e263bc92a02c7de7f888266fce5447f3541c2ad850b8a3a2ba6e5a9c6d9daa1b24c00001af2b6e1ff0d7a704a74eca67808cbf66277544a514dcc34a4d2f17370565e7c17b2e5c91601bf9a1cd14687397376e50421e54de02e6a8eb42168ed816c492dccdbae0aa8fce2986b3b0cff2e3f27e057dadbd77b5bed261d9267f99047cdf3faa23c78d41333eaffda308f75ffc5ae928e8bf1880b0c8a40de0eb551e9e4388393dfc841a2c23f4dbc16ebe6226d87345e91988e1aae8d9756bb30be652edd237473104bc9853b13bdb1a17aa06d92e4b5c8d9641fcf4afb2cba5c692342932c3e09a3da973a3658b3e7540e741fda1f1b6ef55b7976cf910cbc50712add82d2f367faaba013c2bc3b6f5e8c2b96a0066aaa3e97e4196afb8d6128c7a08c3b670df04eeb52d5281364cf3da2bd9f549ca097ad83bb29ef1917ed079523b16a090a848d42d722266dba76e7bb0060bc46181b406197e1e29ffa08953a813bb223c2231bd612130da42d2b6fdd42a2cf40f087667f2db7cda919798b4ba9ccef9e10b062d8cb0ac68ee883d783a001bc7d3c8cc621270b1f6fc32f761bf55fd49fea4957e3c0e0022d60a3f0fe1dbebcfbe65d4dd51e9f53abf01959f2300a915643de0b9e98cbb4376959e152d91c0c4c3deb27159cd0265a03bbc1650a2d15fbea4555c938163fb170b069f346034dea9834b9b432c18ce9e522eb4f8cf9e6d88087198acffaae3ec05e2731ba4b7ce8245d16816db5663789fb5062939fa99d5be59b98ddfcb733d90d6cc9cacab94e391cc6d363016946b1e87375b8d57e6e9236f6ced701fa195c01681a609b06cffb5a82c3a43cdffa3abc0053ae4e6c741ec52f4a6006cd5240a6a43b588e00f6b280f9a611f621b04ce8c07e6db7e381174d9712a3f1655911845264222817a35ae294d716aab8d0a465a7cff81d590d96a18418c9ba707e66f47161f8dd4ca0dd0ef439e3d0bd0be896fc8d419d8dde91fbb06704e92fc6a092027037ef4dd6c6b4d9181cdaabcb1770986011f2461c5106879685bf46fa69312fdf5f8c98ba80aa2b73e0979bba8b02399b6c9c26413cd19ca713530e4345e9944d674bab5a1e228cb18080f9fba4683d4a455b9218071f00b5b17e27e2e330d0c877af12b4bf61e555cf30308f5a89d47ae9faf135a3f20d01b527f9a128924c1c49249e53fc4249ddddcbeb0916bd0c561f3b4c77deda4d8027f635f6f276ce166763c0aac2e5c02d00b11ee4e2f10e290eed860c5adec9a81a8b1465461759e3ee4582a6d1ae0a2796008a20cf6318720ef27a390d8b45f69b5fcdcf36f124907a3d68e78f566ba374c0ce9d350d8d349a0d7ef3a9781aef296daa1e98a480f9293c7b3da6ad2f2f893e2d5744e6485347ae95097579b6c58b5ba091a787f93255d0abe090cfc07f47a7d536bb56b6e783511afd024f03aae0e479c8e2e8713bd7e223b734552d158bb0d72cddd4d652b73d85cd3cb7b92d388ae5edc98509d0d655399638652e77250f26fee9c20acdc2ef6ae437bbb4ee4ec128bc212e141b859f9cd824be8327e05a1feeba4b77cce297ae34d763da73f40b97a96bfd9f4fe49b0718d1b426bc3c94ad4cf6a8e7ceb68a37618a17f90c7fdc7484f49d6226fb86d94b5ba8b414b0478534e5ec8de3603d5e1d93dbcac16febd7cd205c61c2088253895b5558abf8a5e88d4a163cb718e36d081dcac694c88601676e2edfca82e73778c53241358aac7468be58b17e5241059adcdbe635151bf5dcb0d507613c2decdf25b2fcf30d0903e0118fbb9da5e3167487e0aacdcd616d094e04ae799767d8f0442d654ecad0c16bd451fc68f09a57fce5bd192ee78952d4fa3d289f6cd853439326bd7b8c8029069f159137e4c6f6d955332a4</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">关注公众号孙菜菜回复关键词gpt获得密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content:encoded>
      
      
      <category domain="https://atong.run/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/">人工智能</category>
      
      <category domain="https://atong.run/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80/">自然语言</category>
      
      
      <category domain="https://atong.run/tags/ChatGPT/">ChatGPT</category>
      
      
      <comments>https://atong.run/posts/4182892542/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>人工智能这么强，我们会被淘汰吗？应该怎么办？</title>
      <link>https://atong.run/posts/2356723078/</link>
      <guid>https://atong.run/posts/2356723078/</guid>
      <pubDate>Sun, 12 Mar 2023 07:09:57 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;金融界3月10日消息 据德国媒体heise在线报道，当地时间3月9日，微软德国CTO Andreas Braun（布劳恩）在一场AI活动中表示，GPT-4将于下周发布，并且是多模态，不仅仅局限于文字，还包括视频。与此同时，Braun还强调GPT-4能够适用所有的语言，用户可</description>
        
      
      
      
      <content:encoded><![CDATA[<p>金融界3月10日消息 据德国媒体heise在线报道，当地时间3月9日，微软德国CTO Andreas Braun（布劳恩）在一场AI活动中表示，GPT-4将于下周发布，并且是多模态，不仅仅局限于文字，还包括视频。与此同时，Braun还强调GPT-4能够适用所有的语言，用户可以用德语提问，然后获得意大利语的答案。目前最先进的语言模型之一是GPT-3，它在语言理解和生成方面的表现已经达到了前所未有的高度。但是GPT4更加恐怖，未来人工智能将可以更好地帮助人们处理语言任务，比如自然语言处理、智能客服、知识图谱等。</p><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202303121447028.png" alt="image.png"></p><p>人工智能的发展已经取得了巨大的成就，不断涌现出新的技术和应用场景。在这个背景下，人们普遍担心未来许多职业将被替代，而情绪价值的职业可能会长久不衰。但是，事实上情况可能并不是这样简单。本文将从多个角度探讨人工智能发展对未来职业的影响。</p><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202303121429557.png" alt="image.png"></p><p>但是，人工智能仍然存在着一些局限性。例如，它们很难处理一些特定领域的知识，需要人类专业知识的支持。另外，人工智能仍然难以像人类一样做出具有创造性、判断力和决策力的任务。因此，人工智能仍然需要人类的专业知识和经验来解决复杂的问题。</p><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202303121430845.png" alt="image.png"></p><p>随着人工智能技术的发展，一些职业可能会受到影响，比如一些重复性高、标准化程度高的工作可能会被机器人取代。例如，一些制造业和物流领域的工作可能会被自动化取代。但是，同时也会出现一些新的职业和机会。例如，在人工智能领域，需要大量的研究人员、工程师、数据科学家等专业人才。此外，由于人工智能技术的应用范围越来越广泛，需要具备跨学科知识和技能的人才也会越来越受欢迎。</p><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202303121432645.png" alt="image.png"></p><p>一些职业可能会更加重要的原因之一是提供情绪价值。这些职业包括心理医生、咨询师、教育工作者、社工、艺术家等，他们的工作往往需要具备高度的情感智商和人际交往能力，需要与人打交道并且能够理解和处理他们的情绪和需求。这些职业往往需要长期学习和实践，无法被简单地替代。</p><p>此外，情绪价值的职业还具有另外一种重要性，那就是人类对情感联系的需求。虽然人工智能可以通过自然语言处理和情感分析等技术来模拟情感，但是它们缺乏真实的情感体验和交流能力。因此，情绪价值的职业将继续是人类社会中不可或缺的一部分。</p><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202303121432868.png" alt="image.png"></p><p>尽管人工智能发展对职业的影响是不可避免的，但是我们可以采取一些措施来适应这个时代。以下是一些建议：</p><ol><li><p>继续学习和发展自己的技能和知识，特别是跨学科的知识和技能。</p></li><li><p>掌握一些高级技术和工具，例如机器学习、自然语言处理和数据分析等。</p></li><li><p>寻找新的机会和职业，例如在人工智能领域工作或者从事情绪价值的职业。</p></li><li><p>改变自己的职业思维和态度，例如转变为创业者或者自由职业者，或者寻找其他方式来获得收入和生计。</p></li></ol><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202303121433768.png" alt="image.png"></p><p>总结</p><p>在未来的人工智能时代，职业发展将会面临着许多挑战和机遇。一些职业可能会被机器替代，但是同时也会出现新的职业和机会。情绪价值的职业将继续存在并且发挥着重要作用。为了适应这个时代，我们需要不断学习和发展自己的技能和知识，寻找新的机会和职业，并改变自己的职业思维和态度。</p>]]></content:encoded>
      
      
      <category domain="https://atong.run/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/">人工智能</category>
      
      <category domain="https://atong.run/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/AI%E4%B8%8B%E7%9A%84%E6%80%9D%E8%80%83/">AI下的思考</category>
      
      
      <category domain="https://atong.run/tags/ChatGPT/">ChatGPT</category>
      
      
      <comments>https://atong.run/posts/2356723078/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>震惊！！ChatGPT越狱，解锁暗黑版本的ChatGPT，突破openai对chatgpt回答限制。</title>
      <link>https://atong.run/posts/3439780086/</link>
      <guid>https://atong.run/posts/3439780086/</guid>
      <pubDate>Sat, 04 Mar 2023 02:31:10 GMT</pubDate>
      
      <description>如何对ChatGPT进行越狱，解锁暗黑版本的ChatGPT，突破openai对chatgpt回答限制。</description>
      
      
      
      <content:encoded><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="c0f0f84de86503a1ffe1268fea9a6d64f8095ab81fe345b7f0e99abbac0b1785">1ed55b8cb92b79ea9baaafe6182315e0958894f99c20a7bf80f66cdf9a3e14be9affe115514b8e553364f6025d4d79aaae32cf9110007914cf165770f109c3dbde6cb247ddeec55d4c9e848750a8c3203c911dd55191761474c139d64aaa17fce04cf9d8ec42f3ffc9ac4bbe283e2b784e1adbd3d3c69ae58f5c9e3812035cbb2b1aadecdc25c42e535de980ef59f238f62a417249f82084c066182bec2dd88d7b518b6e7ade36f4d95f975dcd8d2f0ea5afced1f9c1203f42ca9066d89cde494574766728cdc335c33d5024899b3e20ce179c1a977ba2e974430acd8333380d84e76d4be17e4b232717d5fb0e0b5823cb6bd23d22730a017b44e619b7d4a77d9f582fb63d501d5cc28ccdeb19c5110d6d7020075f46d60794acd6d7b355a3ab9045bfe673270bb6995bdfe96a1ed5a74e92f453fdd7df06abf19131273ebdeb187892439a8d1ef1ad3b9b68d51a514fbbe0deb08c9e64d95570ba274ddcfb608d42f7b6531a349af038194cec16c95528b3162e935a34d8966d337cb41b161eb461f3e971e36392eb50b51f880f3e8cd35e4873549c23ad8ebdaec108ba48c78d29702236e85214f57b2daa2c5a6ddd8ad718efc5706a55f92abc84f8a8bd187983e2487244d19ca6caa42c9ce73cb3020e4eb98dbb68574c2e86c4f6442ede9cb9a85a6fbb8568ef9740912e5129a2fd8be365af5b2ae010bad5d4f8598259d7d38043b694f567b5a4d4aed28fc8232b00ecff383903e93a4654b45ded1223641cf4ddd5b7452d0aeb30cd696e04ef1cda74ef6df7a9e0f96b880c62cdb7d8b89b97fa0e7d0d082b69f8fc9bbbccc0037085e298b7d2f782435ac6d3d14adc9ae59b01382f6ff48be57a1b6a02e3a93de26229327316cf25c9bc80cfc9eade948a52d6c315fd3781bed483917fb674230bfe4df7d36f4d03cd7f23ca46df77cf64ea9cf353977d43bc901b16feebbffc02ee5b0e97efd25359fa2335a45c50b27e396060545f2facf464d916ee00cf14b6c44f7c43aab1f9ee490b6a3dab1f1df1c6e5a7a60546324a9381d21051dadf9fe7863f4aa8c754eeed1c9accc6bb2b633c16123ceba57863d7bd4d82aa0134c296be62be8dd2097ca4f24a1a2cf498851e0b2691196fcaaa0bee9f2e4a746939f34c3f6f7e11b64c8731b3a6a97e98529f34ed5240ded79ee927ebe33f95e4095b41327b2fc6a3a35aa6b2261cbc7db012712f12402d8e276ec7a48c3472c2d72cc78db56679c909f4b5e5e1b5a253906173bc3921f6f03fc80dde8e3f9fa29b7c77c9494994c6267528ee4e0cadbd19888a6a7081778aa507cc172064e23d9812c6b4ea400f37ca1e7bffb9c6b77c3b615aaa9dd9883d0cc376b639593425bcd575683d0329ce91529836a496825274c9768c264c1f74b465382b3517c3e2a7aba08c11e695d7337a7ee62b176d8bb18c78571b31078b941c3251b88eff5d48e80a63ff3589d6ac448cb1cb1eab7a4b0a24c7a313b1a48697f5838bcd9ae6f5a2ee9d41ce09a09c67d23cf4e36b44332cbc0bb28fd9df2b59d36fc1fb6436e46e277585b46294fdbe1a33d3d5d7a16c3c8862706b500d75428e451424c0c20b8baafd095b0c216710a2365fc14d0c0bd9bf70ae88579b0753395e84a5effdaa4404ffcf41afe64c6a0cd8996fc1581621453b4e3e2e7b64f7e93997e0a3b566b16855dbda61eb935578edd4b12ca74e3c54896b24a120d22c840ef61756baf424142185944948987cef1e5990dad57946f5dce54d610cdaa455331b1eb1b63ca4a8ed0b5c2242a77c933c224fa3f09a2ad5f962c72f3375588cbc3c808717a61ecb124a9c3e523a022a423e31680c3ef2ff964641b50306558147329eaad6373be9c5f3335754af7abe322f120680ecdafb5599d40b81e2962585031ae45167ddf6397b8a95fb9e2fbec4f334d1f9cbdb4fd9ccd5c55f8f6d360e66e351464128c415beb3741bd5bfe8ba93ab51ac3fd4df59d0072b1084fead81d602374edfbd7c6e58e996bb9107ed564679a122bb4a920dbe9f495674ee2bb2552c151e26b44600ee913348a9bc790a0befc6b4b3dc2ca34181af61e3bc4b80827f00e6fcdbb00abedc479656d6abdd3f27a26ed21966695ebf155b35f1813d34393626516db95081fe21c80456fab9d7ec0cf8b5b583261af587ce4d40ddde19f0137d0090df40d99e41bca6a4a72a67f4207f80659d89dfe33cf2cb285d46ed5b0f5be1b85536c1837bce05b653c19bddb7205fec047411ecb1d8a956d0ba8d7d880580dd05a2095e7a4c59d5f62e78da5f13a5d4aa814af7b1203a4d8b9a14bc2a7e84a1a3df030fd8ac324c616bc454612a44bc1a200b05933650eaa87ce9ccd709ec48a65aa1cadba3229daa57baa459bc4222c5c5987c3650939ef6db301265aa08a50326870d12da08e566df5215ed22ceaa7e37327900246c75b710c01b45d864f0a1d9c13c4c9bd9ac7b279250fa1e389638936d79a8b038e973b7764da77535220e624abf3af8086d158b879405df68d52d9bcd4f2323c729cdf4ae0d16104fe88d7f17480e988635d69273fc3dcd7030f91f3d0637bc007f508acb921f775b8d9487b754ca118340b2ea78c0cdbbf95ffe451591bc34ea5260d3e7d0969ee2ec7d5b2254a5be5bd0223a88b93457d95be74ae5e67b54d927d1af1ccf6165ccab3b8b3cdc87f1b2cafb30e2d485ccd70d2ec8df8c7ea565825433638e40d2908515cfdb5d47b06bab92645b7c97f531aa0ac9ad56fa443344c1a21c0106783d34faf13827df5946d58c79803d6e1762d93662082cafe1806ea52c57b46ad50c64bf93ee44d1ffc9e9457addd0e96017694c419fd72a835da8c1b1d1f0481fb42cfdd65924f90924211581c62524fc05259bd2f2820ee3ffa2d1df02bb4809724d00055e2169533017ef31d10c5e55fe8b100906538dd9f00bdb31c1fa9a4f706d77f9fe23a84850b87de01cffa0a95c85673e8f521492c8b08d31be47f16d54bdc806aa670b201d98966d7d6741bd28591400935358844cb60b4b14d3ee429fa38ba1c65b82bc3edb1b20ec62c7e1e2572864c34e11dcfe7390b25c828b5547afe12f6d8bf78b0bb8bf6d96083b6471d1556678290dcbef57f835422cb93410843c0f599667e6b72d0d4adf7dcc6bfa650b82d979619f168a72e35e957c8bbf5e21b271965d81d479dd34bf606c1c5ef857fcd92a8c2ff8315f501b3bb892d9ab12e74fa83833d99a3b0498d550fe46412df6dc2a889b780201ffeda28789a7fadee7395ac4a14a3709d7159357a61f5a78833920189271f8769a65cf5e3be5f89f7315301ca1866932d22f06ed9946bc851d1af73fb0c19fa7442d7543735d315efaabaf17f4055098e1412a2968982d7906ab2df60844bf40421c58388603244f27157b53c1b13d6bcbed4e3e0b0875e6ec8b7c5ac49906b1013e4ab8c701b51bac3661ce1b4e93538bd06c5e5def249fcd2a74bb709306cfb39fbdef3e47332364e5079812fd2ad27a675941a84af65b9bec4cec5e4c158f7ced07bf6e0ee46c17a4a3b1c24578f78c0f18996f2a89302c50db1ee190a850cf54357c64442b63843b18d516961137e4d6ad9fa622fca92001897fa7e85f97380d3b300ccce1ec6631e974c365dd7901e2928c4d70550bf915aa4f282901aebb2eba5b2d0d5fe303b93fa38138ff578ccc45cc49da42a49677e4f2123eec6d0da03d47ea193ea48efa87c431c6aaf940523f4e3db5f406478280285f781e3e0c4b4c3d41ee9c554db3fa9d58bb0c4b07a71ee3a1801a4f2a02995657ede160c0af2e3d2ab9ec183180ceec570a0e8c1f78c6cb341eb2bbe9cc3af8f3bc7dbc7c753bd2e9b2c4c7d8081bcf5b5489126ce52b0074e2e8e1a28fed7168bed59e954c39986819ce782fd58b97350f83926a754a0689210349ae4bd5a9248fe5d12fad5e18cf1a2cf43aaefe57a7e3003d5115518bb1f8bcd238d9f0daadaa0ba25864bcfa25bcdbb899a9fa001703c39af14727c1c705a376f22d21fd85d0407846bb00923b7b9dd2fca9c123340794a9a44c181282e7663abce3c13cf0dad32f3cde441646967c9ec810858266be3e6f313bb362a7a93e1ad0862926a9a40dae3868b14f2e2c06f950b103b8e1b74f661f807298a5a5fb7e57d4c889741a365eee512b98a957087a157485f16aec7bbc9a59484349c9fb64c83b26b921c4f9100a3029d8bec7f00aa7618435c0d59e7c2596d56c764989d44863d49bf62585a2e78895cf581061093af0552a742249cfe5dc910aca30f35dde78852cb3bcfa069430c25a8c5c0f1e648708e4382241b301fd281b68b0d9a79e4a46331dbcf6aa3d85cf736868b82b8514304ddb36b0053a8a88c54f76c1b89525e4c8efb8d3c543105143d7bf0aa3fdff418b79d150aba96fdb15e39eaae68383822153535a187595f716bfc9194ff0d72c2717e5ce55c2a171f6ae5d5b5b5d1e1b90a2f5ca1dbbce0ff8baa0c9238293292c6231973cdb21039accb8ebe8c0122f42a9c1eb574bb908e79a50b87fab226fdec4afbef04b641e2256d8cd6a57b75974da2ef73cef35049be331a6f072aec65d25254b42d91bbb0e1a39ef348d7e215b7aa8644204c8059a261b25f895a37f12c1575839ddc370d85c51ac5c6b121f0ab73623f379ef2b27744d48aa44267f235ed57843058e4dfbddcb90aa650473921a79332e07a2450e732547a6cd6523e4e02c865bedb27b619cea96b323522d913ec1139c11c36a57709708c5798b3f1f3f825dfd232df242c5ea7244fd624f597ac4ea0e9ddd020c5dc71588efa756705f59e1d22144a31fe33561927fc84a1568eefb9ccc8665cdc4a3dbf6ca2520ced08bd34d363248ca00d8da806c1c4f0d3f26865bb79aee5fb911b471603dad167796044ef6eb7829f2d576a2ea047e43040cfec6cb019183ff5010b956d5261be5b00c5494df8053bb8d35ab0ab1b4c9335c136aae61b4bdc8509d285f234b155bc0bcfe9adcdb5ef52f7477a69df300160d6971f9f09459a22b3f49250fbca06faf450c1929a91f8e2071a61903b22df3f64baae137520767db8c8bdad9f9a986754612c6b581b9d982602d5b23afaafee68018edbc17d2776e7c9a6d7cbb2cec6e44705ca72e2b9bd4a965d1ef310c35d453eb828bf64899943b2f597999578945f5d1586330b5ba9bab22ca2535cba50a439629b4342453a50270fa670134afb77e3b441eac167e872d72190bf35764545203dcf989704af37d1e76d8e26b8cc18e9a7d7b351a60e38952ade4ff618cedc45449dd30ab1e09388510ff591ce7ff83d9d581555682ffce8eceaecef6442d2711f3bf865a60db05f71748ec9551aa8c84f699069ce5c915d8eec7557c2fd87936e8b9229ed3400684b026882810578cc09201e63bf08efd5bea950db200d434910833e46c6fee2c9eb3731300ec8cbce6011aeab1627028d155fda76d261b4eebec5e1f23a9b98606aa6e82edea8c36714d2cbae74f848559e0ced580586fac6cce2475389e3503cdc55a9c74d595fcb7a71a9835769360e396af8124248433de82397c31def35a7c5ea149e6ed38dccd10a835d5eee2e93577d2a3aebffa2e53873e2cdeb75767a31801d77b068b9b65f6126741d601eb4eb0b164a378012814eadd1d8b5cf01ba090c14b226656f28470e8541dae239202ca999f18c59b31d1124ebbe05b15dc11c636be283debdf8cc88ebc9e28a70c00797b19e1e0f93f27113fdf9017fa34e7daf4ad68d1b4bf4bfda41326e8691f8b958a3648be212560e6df9df84498538547e102f0579c9248e9186b94f79394fbef909464edf06a5c7ee34fa0e95fb7f428ada52c2d75647c17bdbff578a85cb861af013e645ade4dca3c759b92b6765ba1a0d2d89c13fc1d0a2408c5ad12afbfd3c1d3b1c5798ce52667f6f0244b749cfbcda94391c5788534953cc10bb8f4974b5c31e58ee9d878facce82998717f2984c13f46ea2e475b63999409e238cd840658e7db435716fca377cad9d5f8a52313576ca0ec8233b8784a265d13a3d967e6483e1d5bfa9a76a4ac1e4644cf5c7f5ffd3cf056473e5e569752b9daf43eabd1797e09f385383fe032ae96c4e093e004601736e55e0dadc07d9e4e70ead8b42fee33ada125cd295891b8b41fea14d5582e8e2ec5f1f7aebc5412976d98fff303e463b767cd3a5b64c1c913272146d6f705d51966e6e15873223f519261345141a57782cc2eed1080e8bfe1ab4c035b2a650a7fe6f1de067fd16462bc1fda0f10a749f48529694f4a31d767e63cd49444a859a4530b783579f9522652c8d119b485a556f240d89360ebac92aafeb7efb1f5d43d76c35c100415e141323adcc31a849a1c3d93d59053420b2c2b22d4e64bc28690fbfb8cbf45ba7dae72fdec605723729df239850e70ee22dbe2d203a12ac41fa69a52dff2df819abd7d54e0c8ec30f45aed38f0f40529036a5ef7b9e90ecb1a7b93d4cbd8f2ad25fdf84fe66594dcc61412458547728422b4754c46606c5055a3ac28daa1cbf56248d5993e31ef45d8c707457729c769a0f22f8b035cfb28ccc387b1c86b5b1bd825bf1362e92cd6bb595a9cab28dbf19ccacaba04ffdfc319cdc0a74bd33996ad028938c3aee642931bec30033e31cfc75920fdc2208b145d7bbff091069b8274116b713b1b88e0bb28592e9667b10ba35319c8f8cd384fca0352e3902ac564e79c5dd8bf8b574a30c9f1315f9265fee5a96d8335826437fcc06302efe3913a9dbcae816116a650230c46c60696a50f9605b87b97c67e7a0e3830601d2749d2d5e39e5db9a09f09be81c12e13f67148cdf4136b3e38756b00d8a931f25742d78f2019404a846c5ba7f7184bc9e2873b7395a48dfa56da4e206382f31acbc47fb9e1f1760dc9b860f1c25735d095ffc495d0baf97b719a51587b8b45e2c7f8e694e1f0fbf78c9e82547f09eb07aab3a30496b55b0b5395b05d6147a93beed8d27973bd34abaf1108b55c8fc449ab0b5a90c188adbd9c7e9d92ca85e57d5fcd96525b40f0d284ac41e856ca07958acea1e6c435f53e7396f1663a6b8089679a8438e526bea39b96ae1e87011a13202a6374ea45f2664ee6ba334368e76ed073c3428cf1305cefc4c248a9dd28b6f64ea3bffbc948e8af4c7b75d250e0274c30857ff73de84609332aa36c3533999c7b4d36dc51265e183c115449c45100fc3a07dc11755d1fd3ddd1476cc005f70c254fc3433bdc8a045283c4d97c1fce02ce4338cb0316e38fe2850a86e09c6c4396ce9ff7ff09f12f0c1971d5ee028867f38721639d303842859c3c1c5b5f36187c5eb6e456926a815080ea48d0bb897cf77607b5ebe266cb57bf1efcdf83c5b5e8f7c508a98f767b616b6f1dcca78eb45bfe1a4444e514fce8cfdffac4408fe55aadf3f7f0f1c817ade255072a983cf7748c2bb3d7ea324290ca05be2e703e067fb080881161a6f0ab35607b7c6f23a195baadd1298fb7a1514912abd6260d9556584e2dbbafd8227601eadb79e89a352446ca039282fcb188b1d7c817c223015c15571a32679b4cc042566abaf9fbf0c59714bb009383f86c83e73b73c05f32a38b93712053eecee363047041b83ff7616fdc4d2655763cb9ce14011033ec1b8ac922d87503cc0965081682b5fdfa7c648ffeec24a964e3b54e449aa9b2c463495954da117bd9aa0b899108632232b370962e6d3c3aaa7f5d5a933491eae75bd85a0e2489058346719ed1db636f03d6b400ece58b77103a6afa8cf962f67bbdea2ab0a1bf184761d2a6e3b36295d1d9ebf0944351533b9bba5fe6f212d0485832843fc17d5a27b7c078ca1581156019e9859be9440671c6f695bc7c66d52dbf47301a10f6ea41e8d730d9b0fd3b2be42a1b42bfab0794f400ecce427030ced9d83a621b3d1fc7a40d48678d95b4fa0dfa09b6b4a3780474ef093c69fea80e28876f3a1177276d71381fd7a7586f25acb3a651fce8d006e28bf9407364cde8070dd5f0ae9e621f5e84f7482a67322d81c79e73df22316bde608568cc905ed2caa6906952dbae7e636297824733634a3b2b70b1d2518920b0b91c48045987e305ed3db06280dd742472f6585fe4a357cd32882f05b10619778dac12b2cc08288ca280e05922e795199f149fa992491506cea60f14c4c1df8c8339dfdc2fa3f65978f839bfd0b72309ee0f6f553b1e8a9becef58db819b9420a2e4e2a4e9bdcadcaf664e42f0560da38d95ae089164f2309f15b15e03e19f56ed856a32a1694011d822e4959644969fa67b8520bb3f5d151f232a808b9473ecbe98cf43407969a7bfa13524a8f8f21d7f8c575245ce31b8dfd2ef8451d46e9c41f9f09257f63741dd0e5132af7ce5c78e5881ee88ced0f9e1a0e36c2e9be1daae1242c329aa5d0bc44e872411364ed04698ffb35510c8e7f98df88d210ef62964009b9c994d2505154bf51377800b375b02e5f62561c7148673ebafcfc3aec09b92b0275279baf6aeacd5984b4cf3a3b2b2bef40353a8eeb157013625452c34b3dfca16b00037983cf846602552becf46883f30ab74ad1c2d2d7adf80219dfb84d663422ae27d0863121b743201f1e28ed411fa5423acedc2618aadeacfe16116190aa9246ccf7db8ae2cc9743b002b9edfcff08bfc25b063e5052d42968d5643a7af2411ef66e47d54531f74c59c26e3bad87c2a3eaecfddfa77c12f341446afc822d5b9e2882812e464ca6ff55687e49f43dbf432513d53d236b435eb9c4033f306f3d442d0d121868e41a138a7fe7502b77bc16dc292165e41f7fe0b4b6401260c016188294be1e2204421818fce8dc286332daafed99043876f1c33120dd9fd21ba902284e6285c5941850c8202033d1d6e31fd965777c323b4394e874d74e25c40592c5688e9e01037db8db2f93e96b542f6bca5931d322f8a144694459dcebaefad4807a16fccd91f8e263f2f1ae3fb49ebaf51330663ec18d3007bb9d8b1c18ce83011534f24646efa6226e3a751e4f74b15e9d2e074799fbe761205168d8ec207e92beea2d64332f7e2f23f3c84109b413ddffd1bbf6954d8674f743d9a7358400397e385c1f59b6b38ced0d8e4710d214e4e1612bc4fe169adff9cb185aa7944656e8c5a4be1c8b0e5947ffe635be3803938bc08c8a75b88dea19897589d44d7e7efecbfa6b6f850e307400d3feec916a2c90ae593c60f2c014779b7e62716e4290f71e26b05ef8b294b34f7b958bd501297a553b02272961074f984d0de81990ba32486b3deabfb22d4d653e83387beaa15da4e45167414658571516e4bced8d3d82a358e33fcb1e9f2b35c659d19d378cc5557a94bf4613cac9bb9a067af815e9dc3ed83416c746ad7084e50479380ac1abecdb3c8826b7c6b69c7630cd4c79883a374e3ca91f4c4d01c423a3a36f5437f201cf1d1da829c930cd7893cceccb7759b3106dd54dbdfdaa3816d4b8597f9f9b8383be2988349274c2f4fe19c63af2c48ee996c94664f96780c42a0717c45b88cb1a72749faba920984698aeacaf8a2ed9fd62a47b4029caab0e50384c6752517cd536015f8be481064860ded9ac42e43b2eeb8dc4204800bb8cca7ad9734a1ce13b9a4e8d918f4af316939f63215c43ac1a34fa1f2e43e696a3c6a40f33b4aca6caa6b6fb778377beeecca07b109ea0ffcdba8072dee47f231361562ff227af553463a6bef16c2852f785d2456c405d48e36e2718ad631b1ec71855e079c4d8e1cc2d1af151ab166c97e1f10b0d378c7cfa2031bff4c6fbac8d41ab0a99d2dee489ce2165aa0ac2a6cc97c3962205dc7df1c4d0f397096369c7a5adf04a3fb3788a666693357718cd87521cb93dc6490ffae1d2c882f1d3391acfb4f534716f000b3895963fb18ad8f317f77e382310fd6c6948fc20d872ec9e3a93aa006e2e6cf2223922539294ce554d589f79f585d1c21114f1f862ab4983f752fe9e9d502d7840b106eb4465f0a4b8a31ffd6a8a275452d2e7c3b49344500d708e3723336f44f48f777d3a87af614f24d59b2f4893d8d4c8ca38be0b9b4597e3e4b5d46f6bf638ccfdc6cde7fca67fd0cc33226cdb22b63a36d3de35a9b3fc6dd0ab64ba1efada3a0757cbf77e019679ffa43e4af3049045a27bfecb20cd1b654a7888689035809b48a5d5bfb8525b2d24d1d5cd3b45e18dc8ca3641cf7bccd905f80ea77a06f118ca19aead7bfbe78e2da24b574d47be1315588a6e50fec5166e4e34d189dffb655f62f09f7503e4b86c688dd640479f1c52a0b1a98333088476e1db33b2d34a2a5e045869b044ced8f52138018590bbcedc7581595e43afc10031a9e7ec943e43e3e36a4a374de670d4effe5419846800d7fc9b3706cd351769d5847a5bc5ab2e3ae690b1f76453ca6ee4612c783ce20f7d917dd4037e65ecd6a08db34dd3ef5b9895019d4944e264f91c8f47088cb52d9ef7ee33d220e87b3cf24bc58f9a8738f87aaa46080aee29ec524e0fa28d02220524588005ec8292ff058059efb462b71a290c2821809233dfc79e697452956822c2dafd6cca529d6d82fb111c969e4fb0d8aeb87b030eded4bc003c4be0389b388e8ba54888ecc12052f5833662da87b0ea77252a1a8112263462b3549acb5ee9b06f745ec5635241a3294704f4f9112638f0843a742faf7640ea7a3a4d554f72d5fe8c8dd36f5ef20308430cc1f64bf19c00eeb134156bb598e7658ab3710c8f567fb8205298aedc5d77af37387e630233140fd31cea3e6af83e04fa74711ecaa6dcbe65dcbf69343e569d7da6a5ca19cdc68c38a396fc246df937841e459bcb12434d543137a09b9a529b7d358c16575f748456d1aa0114d61c73a3daa7c26d492755d3094b255756030a36d37024ae51ac4335931c46898ad078b5f031e705381c9ec3d2884e768098181746d35c440ac198fc6c73f16494f69a2d31479e2a320c91dad3069e75d0cdbfad328555400997acaad299ca0d2e965458bc1d3c4df7a87eeb0af84b8210159c5f9ce21b516cbde5286d6b95c1cd3df460bf0b6f7bf186ffe5441de9770c936b8d31104da1d3b514b1a9d54c7083e4a12642094dd4774989d2a2a4814a3df34262c651ada281bcd43dd2cf26c9ee289fff94353a3497fb7409e5ce57f0c47abc954cbf822901ed7edf55675a53e5ac31bb73c28915d57bbf7d5eab6daeaec5db962cd0640d1f2513d3c7e8d8affc78ce1d8b5067ab3d13d132f1a5fda6a2fefe81d7ea3b5dfa7bcd7abb0e894e7f07f825b067298d8e8e754636240afd416f77ab586d07c7b6addbce3464dfdcfafe4a359a6b703c28a1a7b08c9cfc534c928cce1fc75f8dc8d872916d081fd591b5f26f30f8e440e593bb235171bbe6fbd3161d673aeefabd3b363802555bc19095483b0733a7518547241b6f1feed8d66303cc49564e222f0153285b6bce858c4ec30c9b3f408041aaa53eaf84728e5ae155abe80a5f26af8c65ae87ecdb3f537ba8adbb5f2ac8eba5cef1324188ffa2b013812370c20c0285d488864cca6b8141f332b7aecd3f5b833529450ebb0ea45d626c385289b4e96ca2a7fadb7f986d65da911bbb3163b453e3f6acd1090cd1104c2cda991d11ee57d2722b33511d9c0c9c4b57f2ac1f223b2d63b6795392f29d7aa2538580b629516e30301e3f2787ccf86e26a6e665268d7441643f86fe1aac7c8271caffc4274b27e8c2953696b5f11e958828d6b71b23845d59e656a3b7d75a30f8c19c22f09bbb6ff42b70a05f1b7c04f6bba1e65014d342a7ba316b8fd1dfc5e5ef0066f547518a3e3fe06a47156598e0347aa128c9aec368a2eb1815a210f2813b7143ef9359ff349ee3884c88c00279e13a0fda6b0fe4a4531f6eda7c56423a55d8e6198aa911e38f7c1a8bf6466a804d13a4c6ef11351b6bfe4199259f50c2951cb62779d85ea1892ca11f71f9fe19771709d3433025f3dcc6127baa7d5fc7a016e4d41f0aad1deb30945ff810c49a32d4be30f4c4ba88d5f52147a4666edd245293dd4605d47148019f39aa9e73b5c5de9a7f73cf0261fe2b36a8ec68f24b9896d3a0e6610e65fb626977de101a193c86266e8f9be2aa017d14ccb2628358e0900b945dda3705f2de11949c87e3ef975a394882a9e648a09ebd1748193b78e79ea6528b8ff0d1de906da86e6d423db940eb9f3bc822a2c7ca8d43f150d0784bd226a39027ade795a238a44cbab54a7348884295231d5888e31fe04ba296747b60378c27bfc6339f2a0dcb704cf4a6e6e22be1851cec9ab03ec3ed9bf6cd622e8f3d2b4df3a2fb751b15eeee9939a95dbe65ce08c6ede971efc081a263b85286e60f266da62e93974ac92fcdfc16067b186657630c702d9a3069067b2ff0aed8a2c3b5564b0eebdb2e6aa576d9e3dea2114d442b7bddfcbbac136c703b67d8f078ab73a3a4b359d604bb954341790b318d878275d7299178ecb09403c798e714703246e85141c54916e9fe4a281c2b1d1365e9c1b4208e3477fea3f39a4bc38653886462aca6fcfba020aa855e5c1aae454793cfc7d8954f20c8e4bb42786875730cb9b6ed3d86a07b71419f3f9261754716b83780cc11f3b80616747586082df542eb35f8a6ec9957462b5673e9d6feacf1770929d0e3d5d465453c8c729dd2f84e2b9dac33ab738f41872405e371fd2811ccbc7f02f5935b39c286475296b19524a03f220ed92e2eff0fb9149f63d5d435fa6b5b9b66b6af4dbefcfa9619c087dc1d555d246bd7fb1096c12d559f8a232c7a437fc861c1787362821d84893ccaf3d27e2df51501dbd2ad2315aa5bd7ad4dd068b60e624f034d5158551763cc7b6c40bdb2ca50f01787f5a5c263f727c96dcac8482770b1644f906d810818aeabcf5883502520cd0fceaa3fe52e7a6bed7c996b0c836ec93447bb2e79b259adf7bdedbb87e0b0be4b27be6da7c02b36d6261e512396dafbe071c58434e391fb5a7eedbc1f8aecfde668f0332fca24451ee4d385d8e97ed35885ef04e0ab6da6156cb3810211253833a0077b2a1e264508ad5228da7a466c69bfe5c0800efe4e204ee08aba142a3fe441e61f6342404643aa3acc67c1fd9c677eb03c096dbb2f85303a0d47d6adf3ebd78f9db8a0184df541bcbd3938674ba8c9f7df84a2541e9152b7d18bf13cb0bed455ba2c05203dc8d80f90782603e2e61dd6dd9ffdb3cad1d8587bb1d73317b1b063614044eac5318650cf9b6890c27f8e2eb5011ef43a33257e52d9af753d51ad82f9422806004eb9d2a2dc66cba987c25adb4332a2dffe93526771e70cba5e14f6ffb9c7dad9292801901e4169f2b648ceb2eed97ccf8b3a196ad50e6985915e2b42cafee40c5c61e67947a2da99e5c7ba38fa6c76259934b369144e8cbf136b65b7b26c8d3b12631fcc306dcb1ad11446bf4ef856d3b6411d3151924b35ccd3366e69f136e61900c94e5af46ed65235910ed3bbe860311e44c90cad07e57809098fc431ca4d6d7391a36a9029ddd9cb491ca7432e724fc0c78b8cce27ae891afe6c2c0233f3eda60870fdb3dbe2986de48f331f6b381c04fe37a0ed4f5687410c99456d54a6fb854855b9aeff89ed94ad5dd6aac7e50551b8ff8398cad8770f461e36a73e418b9864afaea31bd6032f1dc34bbefc95254e81a0f0e80aae010954ca26b62fe580f2fbaa58974e65df180ea2bddd9d61f4e109886418f819902327c9386e5a38ccce493982773243f73083f1d061a922dc3a4679c8b7669f97e51fee96748f73c637eac81590167c254ae33dfca724de119aae62942ac829619b98ce10dc48d5e411efc2101b6d207fa442254cb474a73875ba55b731eab2801596d7b834c06d556fa231440344307d7e9eacd384a4ea299118d68cc22f42dcaa50e134ed76e6c68eab791bb349174d5a7faaf25129a5defd2c942c01bcf992170dfaeca4da6683a184f18f197c774a340b6ace522dc854c30cab911f7911364a61f304bbd111dd2ede49dcf147167b2856d6e9bd4e7e9bc4ea743ca733ec3d5a150e26eec8ed3c4a34532c6c2c460276caf812d417a51584aeac733e9460e9b664c6fafd0fb81c55f9fa5374d19ef0ca9feb876af4c0aa176f9909180f07154e5c6a5f0949c4586742f9d26d665c293b06cd17554b7e64766e6e073f17983b27d140156ef419597e40bcdf941203d8580bf25fa58661ee9abefd5d1942d13aef24b32d757b0cfae6c279cf32d7f2326c9027830bec6ff850f1eff5f1de36f67cd89cd1818650eb1684f668bc02da10c0c5cdea193b530beac78a347559512685fe958d4645fe1743dee9a482f4e8e63671eeb387c57bf404ca0a96b10f914c181bbd26c8d32d8b48f0f715e7fb3ca3f7761779e61214be7aaf656f44a8ea607a27a6addab232abbb7cef775fdc6c00dd7b183f229b3a81c9e8cd11e88e5aed7defcf62760ea55c2f275414e87c8c57ec5b90f39458d71ff7d6063c0c1e762abee1cb6cbc1d496444a6d2c81c4607e537421d51f06f40f0d67e0187255bec576609e2f407ca05cd485065fa84a45015509dd23eb1f35f1c13bc8f3b009ba1c4e36d92134a08ecb5d4d2b85644951cc046b0c959b8c7baa3a5314aad201831c0e07514fdb8e18137b9909a96d01e1799993d3c623f52aba97c8b26194db8df00b1399f0b33ba6a77157405fb20976853a363b3ce0311486f9a316be8f4ff45ce8a9b6e9554acd5673c1aa820db343c16e3e91a8b7b581d49c135c8fc57309dc3ba9eaa0b17685ec14638ce5a466f4c3fada8c8654001167cef24fd26be134825a541635a90229e8bb9b4edfdadc59d5b68cca8d700b9044f2a8bded8a604d6a4c20ddb38e406e129799174d936648496dc9411206ec6cc521cbf4f0f2d0650df09dc4662f01a0457cccc3a6a81c882aa0b35144a239ec17bb58a37c77cf300f724c4a28578429032a79c65d4e9bb487237aa289f94ce85baeb6a7f5b4ff9027acc1d190507fdcc9ed6002fc2fecb488ec4b3af79fbb8c82b39a4dfc28ac6f954e7ca880e13983755859a463a8a90d7589c510644c11b5f7d08c25ba326b8b42aac39047e426d6d7e1631e965c3c6b216761d26e016a93c8d7638277561c50615ba801b2534bdd3939094dad67b5abf51d96d4e1451e0f89a4c9c9de6e4ac196b38f1d6ccaa698e3ce595d61d1ba8a537f4bf0c98d616a23dda205d0ee3662e94f63f4e1a8512b5b9eabf7d13cd2f360a908dd0eb9531a394a20f58245525ecec916f2804aedef7ff47e626a8a4eaf49561d422f280f9ddbead3e6664b922231bf9f36f4a56396a405fa4e9b6fdb94194d72ec15ce87d1f5439a150d0b7733fd5a97e2a18db34560b502986b38ccf6fb61d47f0d2ce94b7bd7c256c83ac53acf31b020ea3637ac71331128215301cd6ff5d058b31e73b72b5f99d36c1b75d896d17b9b6c4aaa5ccb52adbc5de0f5c72addc29f13ebd869a18a1d9b986d03768f2c2be266100219e09d503cbadbabb3b0b414007fe70ac6b18f342d620ca512df3cec62eb3865b703d141acd642b0432653f0cf972e8a7f574d536696d86fed3b81d4dd8f963ac279fa4544d73099c1859489c916b48735dc117bb3cc7fc0f36e37d1f8e3e9dfd602bbfc98db86226487156782cd6ad4d601f352a8b163a87fcc2da38ed2062e3f0e5793a0208d339c753da2e34b77b68ed3ce956d51b92ac5c5ed89ffe678351d5e4235e1f4883a03a3748ed6d9faa8abdd0475180216bd04ead0e72dba10846e6dbbd249eaff9541988c388e8ead1731fd1e0c8ca41fdfcfc9440e141a912494041c022735925e970c82759026335766d8fa6b9e23d0408da05f516de21530c4c8bee3f25df56786f4c4e083918b92b1af5ee11a0af956d9d33809780153df9e29e00c67853b2600b167aa266ec93e1fb69121dcaa0543f36d1100060f7b1375b65bb4d37d9c6accae94d8fcb359f93775ec</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">你好呀，这里需要密码哦, 关注微信公众号孙菜菜回复关键词chatgpt获得密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content:encoded>
      
      
      <category domain="https://atong.run/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/">人工智能</category>
      
      <category domain="https://atong.run/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80/">自然语言</category>
      
      
      <category domain="https://atong.run/tags/ChatGPT/">ChatGPT</category>
      
      
      <comments>https://atong.run/posts/3439780086/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>纯电动汽车simulink教程</title>
      <link>https://atong.run/posts/1513554255/</link>
      <guid>https://atong.run/posts/1513554255/</guid>
      <pubDate>Tue, 28 Feb 2023 04:47:06 GMT</pubDate>
      
        
        
      <description>&lt;h1&gt;纯电动汽车simulink模型&lt;/h1&gt;
&lt;h2 id=&quot;课程简介&quot;&gt;课程简介&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img.shields.io/github/stars/suntong-1221/EV_Model.svg&quot; alt=&quot;Github sta</description>
        
      
      
      
      <content:encoded><![CDATA[<h1>纯电动汽车simulink模型</h1><h2 id="课程简介">课程简介</h2><p><img src="https://img.shields.io/github/stars/suntong-1221/EV_Model.svg" alt="Github stars"><br><a href="https://ci.appveyor.com/project/suntong-1221/EV_Model"><img src="https://ci.appveyor.com/api/projects/status/sb279kxuv1be391g?svg=true" alt="Build status"></a></p><p>​该模型为纯电动汽车单电机整车模型🚗，整车模型可正常仿真运行，但是其中可能存在较大问题，同学们在学习的时候一定要辩证的看待，然后里面缺少几个表数据，这个并没有公开，因为是课题组的资源。</p><ul><li>已经添加了2018a版本的模型文件</li><li>B站链接：<a href="https://www.bilibili.com/video/BV1cm4y1S7Rs?spm_id_from=333.999.0.0">https://www.bilibili.com/video/BV1cm4y1S7Rs?spm_id_from=333.999.0.0</a></li></ul><hr><h2 id="新增内容">新增内容</h2><p>​因为最初上传模型EV_v0.1版本缺少部分课题组内部数据，应同学要求，新增EM_v0.2版本，下载可正常运行，电机是随便找的硕士论文电机额定功率为34kw，最大转矩130Nm，然后我随便按照特性编的数据，电机效率固定为0.95，电池部分，直接给了固定内阻和固定单体电池电压。</p><p><font color=Red>注意事项</font>:underage:</p><ul><li>模型大致符合电动汽车特性，但是数据及其不可信</li><li>简单学习使用，辩证看待</li></ul><hr><h2 id="课程分节">课程分节</h2><ol><li><a href="https://www.bilibili.com/video/BV1cm4y1S7Rs/?spm_id_from=333.788&amp;vd_source=df2f7337299806c5a1ed5a5f5b4ffd1d">纯电动汽车simulink建模仿真-框架逻辑</a></li><li><a href="https://www.bilibili.com/video/BV1a3411Y7dg/?spm_id_from=333.788&amp;vd_source=df2f7337299806c5a1ed5a5f5b4ffd1d">纯电动汽车simulink建模仿真-驾驶员模型</a></li><li><a href="https://www.bilibili.com/video/BV1GT4y1y7TU/?spm_id_from=333.788&amp;vd_source=df2f7337299806c5a1ed5a5f5b4ffd1d">纯电动汽车simulink建模仿真-电池模型</a></li><li><a href="https://www.bilibili.com/video/BV18L4y1s7W2/?spm_id_from=333.788&amp;vd_source=df2f7337299806c5a1ed5a5f5b4ffd1d">纯电动汽车simulink建模仿真-控制模型</a></li><li><a href="https://www.bilibili.com/video/BV1Yq4y1b7PB/?spm_id_from=333.788&amp;vd_source=df2f7337299806c5a1ed5a5f5b4ffd1d">纯电动汽车simulink建模仿真-电机模型</a></li><li><a href="https://www.bilibili.com/video/BV1kb4y177MD/?spm_id_from=333.788&amp;vd_source=df2f7337299806c5a1ed5a5f5b4ffd1d">纯电动汽车simulink建模仿真-车身模型</a></li><li><a href="https://www.bilibili.com/video/BV1r5411o7Rg/?spm_id_from=333.788&amp;vd_source=df2f7337299806c5a1ed5a5f5b4ffd1d">纯电动汽车simulink建模仿真-仿真与欧拉算法</a></li></ol>]]></content:encoded>
      
      
      <category domain="https://atong.run/categories/%E5%BC%80%E6%BA%90%E8%AF%BE%E7%A8%8B/">开源课程</category>
      
      <category domain="https://atong.run/categories/%E5%BC%80%E6%BA%90%E8%AF%BE%E7%A8%8B/simulink/">simulink</category>
      
      
      
      <comments>https://atong.run/posts/1513554255/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>python菜鸡教程</title>
      <link>https://atong.run/posts/2838110349/</link>
      <guid>https://atong.run/posts/2838110349/</guid>
      <pubDate>Tue, 28 Feb 2023 04:46:48 GMT</pubDate>
      
        
        
      <description>&lt;h1&gt;python菜鸡教程&lt;/h1&gt;
&lt;h2 id=&quot;课程简介&quot;&gt;课程简介&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;费曼学习法是比较有名的一种学习方式，核心要义是通过复述概念并反馈结果来加强记忆，它是符合大脑的认知规律，从混乱走向有序的过程，从被动记忆走向主动理解并阐述。这么</description>
        
      
      
      
      <content:encoded><![CDATA[<h1>python菜鸡教程</h1><h2 id="课程简介">课程简介</h2><blockquote><p>费曼学习法是比较有名的一种学习方式，核心要义是通过复述概念并反馈结果来加强记忆，它是符合大脑的认知规律，从混乱走向有序的过程，从被动记忆走向主动理解并阐述。这么棒的学习方式当然要尝试尝试，通过这种方式我也尝试学学python</p></blockquote><p>课程依托于大佬文字版教程<a href="https://www.liaoxuefeng.com/wiki/1016959663602400">廖雪峰python教程</a>进行理解与讲述</p><h2 id="课程链接">课程链接</h2><p><a href="https://www.ixigua.com/7173635950831108620?logTag=51f64d219c69d66c8201">第一节、输入和输出</a></p><p><a href="https://www.ixigua.com/7174049005603979791?logTag=622639136a3e74362eb4">第二节、数据类型和变量</a></p><p><a href="https://www.ixigua.com/7178820918473392655?logTag=ac50f7d3ba276998ee50">第三节、字符串和编码</a></p><p><a href="https://www.ixigua.com/7181108669298410024?logTag=9135f17cb2c13d20b8e2">第四节、使用list和tuple</a></p><p><a href="https://www.ixigua.com/7181418828872876547?logTag=9889661aec1751e1989c">第五节、条件判断和循环</a></p><p><a href="https://www.ixigua.com/7190390094074184203?logTag=66a3f6d9d08eddd09840">第六节、使用dict和set</a></p><p><a href="https://www.ixigua.com/7194312039769211396?logTag=9217a796a89d2de0e0f3">第七节、调用函数</a></p>]]></content:encoded>
      
      
      <category domain="https://atong.run/categories/%E5%BC%80%E6%BA%90%E8%AF%BE%E7%A8%8B/">开源课程</category>
      
      <category domain="https://atong.run/categories/%E5%BC%80%E6%BA%90%E8%AF%BE%E7%A8%8B/Python/">Python</category>
      
      
      
      <comments>https://atong.run/posts/2838110349/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>9、高并发内存池-性能测试及优化</title>
      <link>https://atong.run/posts/1573212312/</link>
      <guid>https://atong.run/posts/1573212312/</guid>
      <pubDate>Fri, 17 Feb 2023 08:45:32 GMT</pubDate>
      
        
        
      <description>&lt;h1&gt;多线程环境下对比malloc测试&lt;/h1&gt;
&lt;h2 id=&quot;测试代码&quot;&gt;测试代码&lt;/h2&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/spa</description>
        
      
      
      
      <content:encoded><![CDATA[<h1>多线程环境下对比malloc测试</h1><h2 id="测试代码">测试代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;ConcurrentAlloc.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ntimes 一轮申请和释放内存的次数</span></span><br><span class="line"><span class="comment">// rounds 轮次</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BenchmarkMalloc</span><span class="params">(<span class="type">size_t</span> ntimes, <span class="type">size_t</span> nworks, <span class="type">size_t</span> rounds)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">std::vector&lt;std::thread&gt; <span class="title">vthread</span><span class="params">(nworks)</span></span>;</span><br><span class="line">std::atomic&lt;<span class="type">size_t</span>&gt; malloc_costtime = <span class="number">0</span>;</span><br><span class="line">std::atomic&lt;<span class="type">size_t</span>&gt; free_costtime = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> k = <span class="number">0</span>; k &lt; nworks; ++k)</span><br><span class="line">&#123;</span><br><span class="line">vthread[k] = std::<span class="built_in">thread</span>([&amp;, k]() &#123;</span><br><span class="line">std::vector&lt;<span class="type">void</span>*&gt; v;</span><br><span class="line">v.<span class="built_in">reserve</span>(ntimes);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; rounds; ++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">size_t</span> begin1 = <span class="built_in">clock</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; ntimes; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//v.push_back(malloc(16));</span></span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="built_in">malloc</span>((<span class="number">16</span> + i) % <span class="number">8192</span> + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">size_t</span> end1 = <span class="built_in">clock</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> begin2 = <span class="built_in">clock</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; ntimes; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">free</span>(v[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">size_t</span> end2 = <span class="built_in">clock</span>();</span><br><span class="line">v.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">malloc_costtime += (end1 - begin1);</span><br><span class="line">free_costtime += (end2 - begin2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; t : vthread)</span><br><span class="line">&#123;</span><br><span class="line">t.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; nworks &lt;&lt; <span class="string">&quot;个线程并发执行&quot;</span> &lt;&lt; rounds &lt;&lt; <span class="string">&quot;轮次，每轮次malloc &quot;</span> &lt;&lt; ntimes &lt;&lt; <span class="string">&quot;次：花费：&quot;</span> &lt;&lt; malloc_costtime &lt;&lt; <span class="string">&quot; ms&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; nworks &lt;&lt; <span class="string">&quot;个线程并发执行&quot;</span> &lt;&lt; rounds &lt;&lt; <span class="string">&quot;轮次，每轮次free &quot;</span> &lt;&lt; ntimes &lt;&lt; <span class="string">&quot;次：花费：&quot;</span> &lt;&lt; free_costtime &lt;&lt; <span class="string">&quot; ms&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; nworks &lt;&lt; <span class="string">&quot;个线程并发malloc&amp;free&quot;</span> &lt;&lt; nworks * rounds * ntimes &lt;&lt; <span class="string">&quot;总计花费：&quot;</span> &lt;&lt; malloc_costtime + free_costtime &lt;&lt; <span class="string">&quot; ms&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 单轮次申请释放次数 线程数 轮次</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BenchmarkConcurrentMalloc</span><span class="params">(<span class="type">size_t</span> ntimes, <span class="type">size_t</span> nworks, <span class="type">size_t</span> rounds)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">std::vector&lt;std::thread&gt; <span class="title">vthread</span><span class="params">(nworks)</span></span>;</span><br><span class="line">std::atomic&lt;<span class="type">size_t</span>&gt; malloc_costtime = <span class="number">0</span>;</span><br><span class="line">std::atomic&lt;<span class="type">size_t</span>&gt; free_costtime = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> k = <span class="number">0</span>; k &lt; nworks; ++k)</span><br><span class="line">&#123;</span><br><span class="line">vthread[k] = std::<span class="built_in">thread</span>([&amp;]() &#123;</span><br><span class="line">std::vector&lt;<span class="type">void</span>*&gt; v;</span><br><span class="line">v.<span class="built_in">reserve</span>(ntimes);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; rounds; ++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">size_t</span> begin1 = <span class="built_in">clock</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; ntimes; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//v.push_back(ConcurrentAlloc(16));</span></span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="built_in">ConcurrentAlloc</span>((<span class="number">16</span> + i) % <span class="number">8192</span> + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">size_t</span> end1 = <span class="built_in">clock</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> begin2 = <span class="built_in">clock</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; ntimes; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">ConcurrentFree</span>(v[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">size_t</span> end2 = <span class="built_in">clock</span>();</span><br><span class="line">v.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">malloc_costtime += (end1 - begin1);</span><br><span class="line">free_costtime += (end2 - begin2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; t : vthread)</span><br><span class="line">&#123;</span><br><span class="line">t.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; nworks &lt;&lt; <span class="string">&quot;个线程并发执行&quot;</span> &lt;&lt; rounds &lt;&lt; <span class="string">&quot;轮次，每轮次concurrent alloc &quot;</span> &lt;&lt; ntimes &lt;&lt; <span class="string">&quot;次：花费：&quot;</span> &lt;&lt; malloc_costtime &lt;&lt; <span class="string">&quot; ms&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; nworks &lt;&lt; <span class="string">&quot;个线程并发执行&quot;</span> &lt;&lt; rounds &lt;&lt; <span class="string">&quot;轮次，每轮次concurrent dealloc &quot;</span> &lt;&lt; ntimes &lt;&lt; <span class="string">&quot;次：花费：&quot;</span> &lt;&lt; free_costtime &lt;&lt; <span class="string">&quot; ms&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; nworks &lt;&lt; <span class="string">&quot;个线程并发concurrent alloc&amp;dealloc&quot;</span> &lt;&lt; nworks * rounds * ntimes &lt;&lt; <span class="string">&quot;总计花费：&quot;</span> &lt;&lt; malloc_costtime + free_costtime &lt;&lt; <span class="string">&quot; ms&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">size_t</span> n = <span class="number">10000</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;==========================================================&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">BenchmarkConcurrentMalloc</span>(n, <span class="number">4</span>, <span class="number">10</span>);</span><br><span class="line">cout &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">BenchmarkMalloc</span>(n, <span class="number">4</span>, <span class="number">10</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;==========================================================&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="申请释放固定内存大小">申请释放固定内存大小</h2><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202302171300120.png" alt="image.png"></p><h2 id="申请释放不同内存大小">申请释放不同内存大小</h2><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202302171303359.png" alt="image.png"></p><h1>性能瓶颈分析</h1><blockquote><p>上述测试发现，我们的内存池比malloc还是差一些的，但是不大容易知道到底是代码的哪一个部分消耗的性能较多，不知道性能的瓶颈在哪里，这时候可以使用性能分析工具</p></blockquote><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202302171413680.png" alt="image.png"></p><p>打开性能探查器，可用工具类，检测项打上对号</p><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202302171414904.png" alt="image.png"></p><p>点击开始</p><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202302171430934.png" alt="image.png"></p><p>可以发现MapObjectToSpan所花费时间非常长，因为涉及到锁的竞争问题，那么我们应该如何进行优化呢？</p><h1>基数树优化</h1><blockquote><p>这里使用基数树进行优化，基数树实际是一个分层的哈希表，根据所分层数，可以分为单层基数树、二层基数树、三层基数树</p></blockquote><h2 id="单层基数树">单层基数树</h2><blockquote><p>单层基数树使用的是直接定址法，在32位平台下，最多分成2^32/2^13次方个页，我们直接开2^(31-13)次方大小的数组</p></blockquote><p>这这里可以用非类型模板参数，将次方传入，1&lt;&lt; BITS 就是2的BITS次方。直接开这么长的数组</p><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202302171521406.png" alt="image.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> BITS&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TCMalloc_PageMap1</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> LENGTH = <span class="number">1</span> &lt;&lt; BITS;</span><br><span class="line"><span class="type">void</span>** array_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uintptr_t</span> Number;</span><br><span class="line"></span><br><span class="line"><span class="comment">//explicit TCMalloc_PageMap1(void* (*allocator)(size_t)) &#123;</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">TCMalloc_PageMap1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//array_ = reinterpret_cast&lt;void**&gt;((*allocator)(sizeof(void*) &lt;&lt; BITS));</span></span><br><span class="line"><span class="type">size_t</span> size = <span class="built_in">sizeof</span>(<span class="type">void</span>*) &lt;&lt; BITS;</span><br><span class="line"><span class="type">size_t</span> alignSize = SizeClass::_RoundUp(size, <span class="number">1</span> &lt;&lt; PAGE_SHIFT);</span><br><span class="line">array_ = (<span class="type">void</span>**)<span class="built_in">SystemAlloc</span>(alignSize &gt;&gt; PAGE_SHIFT);</span><br><span class="line"><span class="built_in">memset</span>(array_, <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="type">void</span>*) &lt;&lt; BITS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return the current value for KEY.  Returns NULL if not yet set,</span></span><br><span class="line"><span class="comment">// or if k is out of range.</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">get</span><span class="params">(Number k)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> ((k &gt;&gt; BITS) &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> array_[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// REQUIRES &quot;k&quot; is in range &quot;[0,2^BITS-1]&quot;.</span></span><br><span class="line"><span class="comment">// REQUIRES &quot;k&quot; has been ensured before.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Sets the value &#x27;v&#x27; for key &#x27;k&#x27;.</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(Number k, <span class="type">void</span>* v)</span> </span>&#123;</span><br><span class="line">array_[k] = v;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="二层基数树">二层基数树</h2><blockquote><p>假设同样在32位平台下，最多分成2^32/2^13  = 2^19次方个页，最多用19个比特位可以标识，用二层得基数树，第一层只用5个比特位，做直接定址，对应的下标存的元素是 void* values[LEAF_LENGTH]，剩下的14位可以总共映射 length = 1&lt;&lt;14个数据</p></blockquote><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202302171526874.png" alt="image.png"></p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Two-level radix tree</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> BITS&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TCMalloc_PageMap2</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">// Put 32 entries in the root and (2^BITS)/32 entries in each leaf.</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> ROOT_BITS = <span class="number">5</span>; <span class="comment">//第一层对应页号的前5个比特位</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> ROOT_LENGTH = <span class="number">1</span> &lt;&lt; ROOT_BITS; <span class="comment">//第一层存储元素的个数 2^5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> LEAF_BITS = BITS - ROOT_BITS;<span class="comment">//第二层对应页号的其余比特位 19-5=14</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> LEAF_LENGTH = <span class="number">1</span> &lt;&lt; LEAF_BITS; <span class="comment">//第二层存储元素的个数 2^14</span></span><br><span class="line"><span class="comment">// Leaf node</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Leaf</span> &#123;</span><br><span class="line"><span class="type">void</span>* values[LEAF_LENGTH];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Leaf* root_[ROOT_LENGTH];             <span class="comment">// Pointers to 32 child nodes</span></span><br><span class="line"><span class="type">void</span>* (*allocator_)(<span class="type">size_t</span>);          <span class="comment">// Memory allocator</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uintptr_t</span> Number;</span><br><span class="line"></span><br><span class="line"><span class="comment">//explicit TCMalloc_PageMap2(void* (*allocator)(size_t)) &#123;</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">TCMalloc_PageMap2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//allocator_ = allocator;</span></span><br><span class="line"><span class="built_in">memset</span>(root_, <span class="number">0</span>, <span class="built_in">sizeof</span>(root_));</span><br><span class="line"></span><br><span class="line"><span class="built_in">PreallocateMoreMemory</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">get</span><span class="params">(Number k)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="type">const</span> Number i1 = k &gt;&gt; LEAF_BITS;  <span class="comment">// 右移14位，得到前5位</span></span><br><span class="line"><span class="type">const</span> Number i2 = k &amp; (LEAF_LENGTH - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> ((k &gt;&gt; BITS) &gt; <span class="number">0</span> || root_[i1] == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> root_[i1]-&gt;values[i2];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(Number k, <span class="type">void</span>* v)</span> </span>&#123;</span><br><span class="line"><span class="type">const</span> Number i1 = k &gt;&gt; LEAF_BITS;</span><br><span class="line"><span class="comment">// 1000 0000 0000 000-1 = 0111 1111 1111 11</span></span><br><span class="line"><span class="comment">// 相与获得后14位</span></span><br><span class="line"><span class="type">const</span> Number i2 = k &amp; (LEAF_LENGTH - <span class="number">1</span>); </span><br><span class="line"><span class="built_in">ASSERT</span>(i1 &lt; ROOT_LENGTH);</span><br><span class="line">root_[i1]-&gt;values[i2] = v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 确保映射[start ， start+n-1]页号的空间是开好的</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Ensure</span><span class="params">(Number start, <span class="type">size_t</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (Number key = start; key &lt;= start + n - <span class="number">1</span>;) &#123;</span><br><span class="line"><span class="type">const</span> Number i1 = key &gt;&gt; LEAF_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check for overflow</span></span><br><span class="line"><span class="keyword">if</span> (i1 &gt;= ROOT_LENGTH)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Make 2nd level node if necessary</span></span><br><span class="line"><span class="keyword">if</span> (root_[i1] == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="comment">//Leaf* leaf = reinterpret_cast&lt;Leaf*&gt;((*allocator_)(sizeof(Leaf)));</span></span><br><span class="line"><span class="comment">//if (leaf == NULL) return false;</span></span><br><span class="line"><span class="type">static</span> ObjectPool&lt;Leaf&gt;leafPool;</span><br><span class="line">Leaf* leaf = (Leaf*)leafPool.<span class="built_in">New</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(leaf, <span class="number">0</span>, <span class="built_in">sizeof</span>(*leaf));</span><br><span class="line">root_[i1] = leaf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Advance key past whatever is covered by this leaf node</span></span><br><span class="line">key = ((key &gt;&gt; LEAF_BITS) + <span class="number">1</span>) &lt;&lt; LEAF_BITS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreallocateMoreMemory</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 将第二层全部的空间都开好</span></span><br><span class="line"><span class="built_in">Ensure</span>(<span class="number">0</span>, <span class="number">1</span> &lt;&lt; BITS);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>在32位平台下，第一层数组占，2^5* 4=2^7字节，第二层最多有2^5^2^14^4=2^21=2M，消耗也不大，可以直接全开出来</p></blockquote><h2 id="三层基数树">三层基数树</h2><blockquote><p>64位平台下，公共有2^64/2^13=2^51个页，一层基数树肯定不行，二层页不大行，用三层基数树，三层基数树就是将存储页号的比特位分三次映射</p></blockquote><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202302171607278.png" alt="image.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Three-level radix tree</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> BITS&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TCMalloc_PageMap3</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> INTERIOR_BITS = (BITS + <span class="number">2</span>) / <span class="number">3</span>;       <span class="comment">//第一、二层对应页号的比特位个数</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> INTERIOR_LENGTH = <span class="number">1</span> &lt;&lt; INTERIOR_BITS; <span class="comment">//第一、二层存储元素的个数</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> LEAF_BITS = BITS - <span class="number">2</span> * INTERIOR_BITS; <span class="comment">//第三层对应页号的比特位个数</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> LEAF_LENGTH = <span class="number">1</span> &lt;&lt; LEAF_BITS;         <span class="comment">//第三层存储元素的个数</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">Node* ptrs[INTERIOR_LENGTH];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Leaf</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">void</span>* values[LEAF_LENGTH];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Node* <span class="title">NewNode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">static</span> ObjectPool&lt;Node&gt; nodePool;</span><br><span class="line">Node* result = nodePool.<span class="built_in">New</span>();</span><br><span class="line"><span class="keyword">if</span> (result != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(result, <span class="number">0</span>, <span class="built_in">sizeof</span>(*result));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">Node* root_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uintptr_t</span> Number;</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">TCMalloc_PageMap3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">root_ = <span class="built_in">NewNode</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">get</span><span class="params">(Number k)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">const</span> Number i1 = k &gt;&gt; (LEAF_BITS + INTERIOR_BITS);         <span class="comment">//第一层对应的下标</span></span><br><span class="line"><span class="type">const</span> Number i2 = (k &gt;&gt; LEAF_BITS) &amp; (INTERIOR_LENGTH - <span class="number">1</span>); <span class="comment">//第二层对应的下标</span></span><br><span class="line"><span class="type">const</span> Number i3 = k &amp; (LEAF_LENGTH - <span class="number">1</span>);                    <span class="comment">//第三层对应的下标</span></span><br><span class="line"><span class="comment">//页号超出范围，或映射该页号的空间未开辟</span></span><br><span class="line"><span class="keyword">if</span> ((k &gt;&gt; BITS) &gt; <span class="number">0</span> || root_-&gt;ptrs[i1] == <span class="literal">NULL</span> || root_-&gt;ptrs[i1]-&gt;ptrs[i2] == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">reinterpret_cast</span>&lt;Leaf*&gt;(root_-&gt;ptrs[i1]-&gt;ptrs[i2])-&gt;values[i3]; <span class="comment">//返回该页号对应span的指针</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(Number k, <span class="type">void</span>* v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(k &gt;&gt; BITS == <span class="number">0</span>);</span><br><span class="line"><span class="type">const</span> Number i1 = k &gt;&gt; (LEAF_BITS + INTERIOR_BITS);         <span class="comment">//第一层对应的下标</span></span><br><span class="line"><span class="type">const</span> Number i2 = (k &gt;&gt; LEAF_BITS) &amp; (INTERIOR_LENGTH - <span class="number">1</span>); <span class="comment">//第二层对应的下标</span></span><br><span class="line"><span class="type">const</span> Number i3 = k &amp; (LEAF_LENGTH - <span class="number">1</span>);                    <span class="comment">//第三层对应的下标</span></span><br><span class="line"><span class="built_in">Ensure</span>(k, <span class="number">1</span>); <span class="comment">//确保映射第k页页号的空间是开辟好了的</span></span><br><span class="line"><span class="built_in">reinterpret_cast</span>&lt;Leaf*&gt;(root_-&gt;ptrs[i1]-&gt;ptrs[i2])-&gt;values[i3] = v; <span class="comment">//建立该页号与对应span的映射</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//确保映射[start,start+n-1]页号的空间是开辟好了的</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Ensure</span><span class="params">(Number start, <span class="type">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (Number key = start; key &lt;= start + n - <span class="number">1</span>;)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> Number i1 = key &gt;&gt; (LEAF_BITS + INTERIOR_BITS);         <span class="comment">//第一层对应的下标</span></span><br><span class="line"><span class="type">const</span> Number i2 = (key &gt;&gt; LEAF_BITS) &amp; (INTERIOR_LENGTH - <span class="number">1</span>); <span class="comment">//第二层对应的下标</span></span><br><span class="line"><span class="keyword">if</span> (i1 &gt;= INTERIOR_LENGTH || i2 &gt;= INTERIOR_LENGTH) <span class="comment">//下标值超出范围</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (root_-&gt;ptrs[i1] == <span class="literal">NULL</span>) <span class="comment">//第一层i1下标指向的空间未开辟</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//开辟对应空间</span></span><br><span class="line">Node* n = <span class="built_in">NewNode</span>();</span><br><span class="line"><span class="keyword">if</span> (n == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">root_-&gt;ptrs[i1] = n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (root_-&gt;ptrs[i1]-&gt;ptrs[i2] == <span class="literal">NULL</span>) <span class="comment">//第二层i2下标指向的空间未开辟</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//开辟对应空间</span></span><br><span class="line"><span class="type">static</span> ObjectPool&lt;Leaf&gt; leafPool;</span><br><span class="line">Leaf* leaf = leafPool.<span class="built_in">New</span>();</span><br><span class="line"><span class="keyword">if</span> (leaf == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">memset</span>(leaf, <span class="number">0</span>, <span class="built_in">sizeof</span>(*leaf));</span><br><span class="line">root_-&gt;ptrs[i1]-&gt;ptrs[i2] = <span class="built_in">reinterpret_cast</span>&lt;Node*&gt;(leaf);</span><br><span class="line">&#125;</span><br><span class="line">key = ((key &gt;&gt; LEAF_BITS) + <span class="number">1</span>) &lt;&lt; LEAF_BITS; <span class="comment">//继续后续检查</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreallocateMoreMemory</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>当需要建立某一页号的映射关系时，先确保存储该页映射的数组空间是开好的，调用Ensure函数，如果没开好，就开辟对应的空间</p></blockquote><h2 id="使用基数树优化">使用基数树优化</h2><blockquote><p>我们在32位平台下测试，直接使用一层基数树即可将unordered_map替换成基数树的结构，并用set和get函数，替换方括号和find的作用</p></blockquote><h3 id="更改代码">更改代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TCMalloc_PageMap1&lt;<span class="number">32</span> - PAGE_SHIFT&gt; _idSpanMap;  <span class="comment">//32-13=19，总共2^19个页</span></span><br></pre></td></tr></table></figure><p>建立映射：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_idSpanMap.<span class="built_in">set</span>(span-&gt;_pageId, span);</span><br></pre></td></tr></table></figure><p>读取Span</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Span* ret = (Span*)_idSpanMap.<span class="built_in">get</span>(id);</span><br></pre></td></tr></table></figure><h3 id="优化原理">优化原理</h3><blockquote><p>基数树的检索可能略好一点，但是最重要的是基数树的结构不需要加锁，map和unordered_map，插入数据底层的数据结构可能会变化，比如红黑树的选择，哈希表的扩容，所以在读取映射关系时需要加锁，但是基数树一旦开好空间就不会发生变化。<br>我们不会同时对一个页进行读取映射和建立映射的操作，只有在释放对象的时候才需要读取，建立映射都是在page cache中进行，建立映射的对应的span的usecount为0，而读取对应的span的usecount不为0，所以不会对一个页同时进行读取和建立映射。</p></blockquote><h3 id="性能对比">性能对比</h3><blockquote><p>再次与malloc进行对比</p></blockquote><p>固定大小的对象的申请和释放</p><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202302171629323.png" alt="image.png"></p><p>不固定大小的对象的申请和释放</p><p><img src="https://tong-1306822294.cos.ap-beijing.myqcloud.com/tong/picture/202302171627490.png" alt="image.png"></p><p>可以看到两种场景，都比malloc快2~3倍左右</p>]]></content:encoded>
      
      
      <category domain="https://atong.run/categories/%E9%A1%B9%E7%9B%AE/">项目</category>
      
      <category domain="https://atong.run/categories/%E9%A1%B9%E7%9B%AE/%E9%AB%98%E5%B9%B6%E5%8F%91%E5%86%85%E5%AD%98%E6%B1%A0/">高并发内存池</category>
      
      
      <category domain="https://atong.run/tags/%E9%A1%B9%E7%9B%AE/">项目</category>
      
      
      <comments>https://atong.run/posts/1573212312/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>8、高并发内存池-细节完善</title>
      <link>https://atong.run/posts/2734729201/</link>
      <guid>https://atong.run/posts/2734729201/</guid>
      <pubDate>Fri, 17 Feb 2023 06:09:42 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;我们的内存池已经完成了申请内存和释放内存的功能但是还有几个地方没有处理完善，主要有以下几个方面：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;大于256KB的内存申请&lt;/li&gt;
&lt;li&gt;内存池的内部要脱离new&lt;/li&gt;
&lt;li&gt;释放对象</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>我们的内存池已经完成了申请内存和释放内存的功能但是还有几个地方没有处理完善，主要有以下几个方面：</p></blockquote><ul><li>大于256KB的内存申请</li><li>内存池的内部要脱离new</li><li>释放对象时的细节</li></ul><h1>大于256KB的内存处理</h1><h2 id="申请">申请</h2><blockquote><p>在ConcurrentAlloc.h文件中，申请内存的时候要分两种情况</p></blockquote><ul><li>小于256kb走thread cache</li><li>大于256kb走page cache</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="title">ConcurrentAlloc</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (size &gt; MAX_BYTES)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 申请的内存大于MAX_BYTES(256kb)</span></span><br><span class="line"><span class="comment">// 走Page Cache层申请</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 先进行对齐</span></span><br><span class="line"><span class="type">size_t</span> alignSize = SizeClass::<span class="built_in">RoundUp</span>(size);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后算需要几页</span></span><br><span class="line"><span class="type">size_t</span> kpage = alignSize &gt;&gt; PAGE_SHITF;</span><br><span class="line">PageCache::<span class="built_in">GetInstance</span>()-&gt;_pageMtx.<span class="built_in">lock</span>();</span><br><span class="line">Span* span = PageCache::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">NewSpan</span>(alignSize);</span><br><span class="line">PageCache::<span class="built_in">GetInstance</span>()-&gt;_pageMtx.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (<span class="type">void</span>*)(span-&gt;_pageId &lt;&lt; PAGE_SHITF);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pTLSThreadCache == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">pTLSThreadCache = <span class="keyword">new</span> ThreadCache;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pTLSThreadCache-&gt;<span class="built_in">Allocate</span>(size);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>我们SizeClass对齐的逻辑，并没有处理大于256KB的内存，我们需要增加这一部分</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">size_t</span> <span class="title">RoundUp</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (size &lt;= <span class="number">128</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _RoundUp(size, <span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (size &lt;= <span class="number">1024</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _RoundUp(size, <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (size &lt;= <span class="number">8</span> * <span class="number">1024</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _RoundUp(size, <span class="number">128</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (size &lt;= <span class="number">64</span> * <span class="number">1024</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _RoundUp(size, <span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (size &lt;= <span class="number">256</span> * <span class="number">1024</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _RoundUp(size, <span class="number">8</span>*<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 大于256KB 1&lt;&lt;13 也就是8kb</span></span><br><span class="line"><span class="keyword">return</span> _RoundUp(size, <span class="number">1</span> &lt;&lt; PAGE_SHITF);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>但是这个大于256kb的让page cache申请，还是存在一些问题，因为page cache最多提供128页的内存，如果申请的内存大于128页，则还是需要进行处理，这部分，我们在page cache中进行处理。</p></blockquote><pre><code>PageCache::NewSpan函数中，增加申请大于128页的span的逻辑</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 如果k &gt; 128页 走系统调用</span></span><br><span class="line"><span class="keyword">if</span> (k &gt; NPAGES - <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">void</span>* ptr = <span class="built_in">SystemAlloc</span>(k);</span><br><span class="line">Span* span = <span class="keyword">new</span> Span;</span><br><span class="line">span-&gt;_pageId = (PAGE_ID)ptr &gt;&gt; PAGE_SHITF;</span><br><span class="line">span-&gt;_n = k;</span><br><span class="line"></span><br><span class="line">_idSpanMap[span-&gt;_pageId] = span;</span><br><span class="line"><span class="keyword">return</span> span;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="释放">释放</h2><blockquote><p>大于256kb的内存，释放时，同样不能走thread cache层回收，要有单独的回收逻辑，我们还是通过pagecache层回收</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">ConcurrentFree</span><span class="params">(<span class="type">void</span>* ptr, <span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (size &gt; MAX_BYTES)</span><br><span class="line">&#123;</span><br><span class="line">Span* span = PageCache::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">MapObjectToSpan</span>(ptr);</span><br><span class="line"></span><br><span class="line">PageCache::<span class="built_in">GetInstance</span>()-&gt;_pageMtx.<span class="built_in">lock</span>();</span><br><span class="line">PageCache::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">ReleaseSpanToPageCache</span>(span);</span><br><span class="line">PageCache::<span class="built_in">GetInstance</span>()-&gt;_pageMtx.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">assert</span>(pTLSThreadCache);</span><br><span class="line">pTLSThreadCache-&gt;<span class="built_in">Deallocate</span>(ptr, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>同样，在pagecache层中还要分为，这个内存是大于128页还是小于128页，小于128直接走Page cache层的回收逻辑，大于128页的通过系统调用回收</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 释放空闲span回到PageCache，并合并相邻的span</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PageCache::ReleaseSpanToPageCache</span><span class="params">(Span* span)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (span-&gt;_n &gt; NPAGES - <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">void</span>* ptr = (<span class="type">void</span>*)(span-&gt;_pageId &lt;&lt; PAGE_SHITF);</span><br><span class="line"><span class="built_in">SystemFree</span>(ptr);</span><br><span class="line"><span class="keyword">delete</span> span;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 合并相邻的span，向前合并，有问题：前面的span如果被用就不能进行合并</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">PAGE_ID prevId = span-&gt;_pageId - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> ret = _idSpanMap.<span class="built_in">find</span>(prevId);</span><br><span class="line"><span class="comment">//前边的页号没有了就不和并了</span></span><br><span class="line"><span class="keyword">if</span> (ret == _idSpanMap.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前边相邻页在使用，不合并</span></span><br><span class="line">Span* prevSpan = ret-&gt;second;</span><br><span class="line"><span class="keyword">if</span> (prevSpan-&gt;_isUse == <span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//超过128页的span也不合并</span></span><br><span class="line"><span class="keyword">if</span> (prevSpan-&gt;_n + span-&gt;_n &gt; NPAGES - <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进入合并的逻辑</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//span-&gt;_pageId -= prevSpan-&gt;_n;</span></span><br><span class="line">span-&gt;_pageId = prevSpan-&gt;_pageId;</span><br><span class="line">span-&gt;_n += prevSpan-&gt;_n;</span><br><span class="line"></span><br><span class="line">_spanLists[prevSpan-&gt;_n].<span class="built_in">Erase</span>(prevSpan);</span><br><span class="line"><span class="keyword">delete</span> prevSpan;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">PAGE_ID nextID = span-&gt;_pageId + span-&gt;_n;</span><br><span class="line"><span class="keyword">auto</span> ret = _idSpanMap.<span class="built_in">find</span>(nextID);</span><br><span class="line"><span class="keyword">if</span> (ret == _idSpanMap.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Span* nextSpan = ret-&gt;second;</span><br><span class="line"><span class="keyword">if</span> (nextSpan-&gt;_isUse == <span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//超过128页的span也不合并</span></span><br><span class="line"><span class="keyword">if</span> (nextSpan-&gt;_n + span-&gt;_n &gt; NPAGES - <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">span-&gt;_n += nextSpan-&gt;_n;</span><br><span class="line"></span><br><span class="line">_spanLists[nextSpan-&gt;_n].<span class="built_in">Erase</span>(nextSpan);</span><br><span class="line"><span class="keyword">delete</span> nextSpan;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">_spanLists[span-&gt;_n].<span class="built_in">PushFront</span>(span);</span><br><span class="line">span-&gt;_isUse = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">_idSpanMap[span-&gt;_pageId] = span;</span><br><span class="line">_idSpanMap[span-&gt;_pageId + span-&gt;_n - <span class="number">1</span>] = span;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里封装的了Windows系统的VirtualFree函数，进行大于128页的内存释放</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用系统接口释放内存</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">static</span> <span class="type">void</span> <span class="title">SystemFree</span><span class="params">(<span class="type">void</span>* ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN32</span></span><br><span class="line"><span class="built_in">VirtualFree</span>(ptr, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="comment">// sbrk unmmap等</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>使用定长内存池配合脱离new</h1><blockquote><p>我们的内存池期望的是在内部不使用malloc函数申请内存，走自己的一套申请释放体系，但是目前我们的代码中，还是有不少地方（new span的对象）使用了new，为了完全脱离new，我们可以配合之前的定长内存池。</p></blockquote><h2 id="申请-2">申请</h2><p>因为span对象都是在page cache层new出来的，我们可以在page cache层增加一个定长内存池对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ObjectPool&lt;Span&gt; _spanPool;</span><br></pre></td></tr></table></figure><blockquote><p>然后我们在new Span的场景下，替换成定长内存池的申请</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Span* span = <span class="keyword">new</span> Span;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上边替换成下边</span></span><br><span class="line"></span><br><span class="line">Span* span = _spanPool.<span class="built_in">New</span>();</span><br></pre></td></tr></table></figure><blockquote><p>在线程申请创建thread cache时，也是通过new进行申请的，同样进行替换</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (pTLSThreadCache == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*pTLSThreadCache = new ThreadCache;*/</span></span><br><span class="line"><span class="type">static</span> ObjectPool&lt;ThreadCache&gt; tcPool;</span><br><span class="line">pTLSThreadCache = tcPool.<span class="built_in">New</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="释放-2">释放</h2><blockquote><p>对应的delete也要替换成定长内存池的Delete</p></blockquote><h1>释放内存优化为不传对象大小</h1><blockquote><p>我们用free时，只需要传入一个指针即可，但是我们目前的内存池释放内存，不仅要传入指针，还需要传入待释放内存的大小，我们也需要优化为不传入对象的大小</p></blockquote><p>我们可以在span对象中增加成员：ObjSize 用来记录span中每个对象的大小</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> _ObjSize = <span class="number">0</span>; <span class="comment">// 切好的小对象的大小</span></span><br></pre></td></tr></table></figure><p>那我们的释放内存的函数就可以改为下边的写法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">ConcurrentFree</span><span class="params">(<span class="type">void</span>* ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Span* span = PageCache::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">MapObjectToSpan</span>(ptr);</span><br><span class="line"><span class="type">size_t</span> size = span-&gt;_ObjSize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (size &gt; MAX_BYTES)</span><br><span class="line">&#123;</span><br><span class="line">PageCache::<span class="built_in">GetInstance</span>()-&gt;_pageMtx.<span class="built_in">lock</span>();</span><br><span class="line">PageCache::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">ReleaseSpanToPageCache</span>(span);</span><br><span class="line">PageCache::<span class="built_in">GetInstance</span>()-&gt;_pageMtx.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">assert</span>(pTLSThreadCache);</span><br><span class="line">pTLSThreadCache-&gt;<span class="built_in">Deallocate</span>(ptr, size);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>现在的问题就变成了，ObjSize的记录问题了，我们整个内存池中的span对象都是从Page cache层出来的，所以在调用NewSpan的时候，要将切分的对象的大小记录下来，我们申请小于256kb的对象时，都走的thread cache-&gt;central cache-&gt;page cache，另一种情况是大于256kb直接找page cache，这两个地方都需要记录ObjSize</p></blockquote><p>1、在Central层调用NewSpan后，使得span-&gt;ObjSize=size</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们要计算向page cache层要多少页的span</span></span><br><span class="line">Span* span = PageCache::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">NewSpan</span>(SizeClass::<span class="built_in">NumMovePage</span>(size));</span><br><span class="line">span-&gt;_ObjSize = size;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2、CurrentAlloc中，申请大于256KB的对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Span* span = PageCache::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">NewSpan</span>(alignSize);</span><br><span class="line">span-&gt;_ObjSize = alignSize;</span><br></pre></td></tr></table></figure><h1>STL线程安全问题</h1><blockquote><p>我们通过unordered_map，建立了PAGE_ID和Span* 的联系，PageCache层，有读写操作，但是我们在使用PageCache的NewSpan函数时，都会加锁，但是CentralCache层和ConcurrentFree函数中会有读操作，而且并未加锁，这样，可能有线程正在改，就有线程读取，会有线程安全的问题</p></blockquote><p>我们在MapObjectToSpan函数中加锁</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取对象到span的映射</span></span><br><span class="line"><span class="function">Span* <span class="title">PageCache::MapObjectToSpan</span><span class="params">(<span class="type">void</span>* obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">PAGE_ID id = ((PAGE_ID)obj &gt;&gt; PAGE_SHITF);</span><br><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_pageMtx)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (_idSpanMap.<span class="built_in">find</span>(id) != _idSpanMap.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> _idSpanMap[id];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">assert</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://atong.run/categories/%E9%A1%B9%E7%9B%AE/">项目</category>
      
      <category domain="https://atong.run/categories/%E9%A1%B9%E7%9B%AE/%E9%AB%98%E5%B9%B6%E5%8F%91%E5%86%85%E5%AD%98%E6%B1%A0/">高并发内存池</category>
      
      
      <category domain="https://atong.run/tags/%E9%A1%B9%E7%9B%AE/">项目</category>
      
      
      <comments>https://atong.run/posts/2734729201/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
